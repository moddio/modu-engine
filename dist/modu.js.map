{
  "version": 3,
  "sources": ["../src/math/fixed.ts", "../src/math/vec.ts", "../src/math/quat.ts", "../src/math/random.ts", "../src/core/constants.ts", "../src/core/component.ts", "../src/core/entity-id.ts", "../src/components/index.ts", "../src/core/entity.ts", "../src/core/query.ts", "../src/core/system.ts", "../src/core/snapshot.ts", "../src/core/string-registry.ts", "../src/core/input-history.ts", "../src/core/world.ts", "../src/codec/index.ts", "../src/codec/binary.ts", "../src/game.ts", "../src/plugins/simple-2d-renderer.ts", "../src/plugins/input-plugin.ts", "../src/plugins/camera-system.ts", "../src/plugins/determinism-guard.ts", "../src/version.ts", "../src/plugins/debug-ui.ts", "../src/plugins/physics2d/index.ts", "../src/plugins/physics2d/shapes.ts", "../src/plugins/physics2d/layers.ts", "../src/plugins/physics2d/rigid-body.ts", "../src/plugins/physics2d/collision.ts", "../src/plugins/physics2d/spatial-hash.ts", "../src/plugins/physics2d/world.ts", "../src/plugins/physics2d/quad-tree.ts", "../src/plugins/physics2d/trigger.ts", "../src/plugins/physics2d/system.ts", "../src/plugins/physics3d/index.ts", "../src/plugins/physics3d/shapes.ts", "../src/plugins/physics3d/layers.ts", "../src/plugins/physics3d/rigid-body.ts", "../src/plugins/physics3d/collision.ts", "../src/plugins/physics3d/trigger.ts", "../src/plugins/physics3d/world.ts", "../src/plugins/physics3d/raycast.ts", "../src/plugins/physics3d/state.ts", "../src/sync/rollback.ts"],
  "sourcesContent": ["/**\n * Fixed-Point Math Library for Deterministic Physics\n *\n * Uses 32-bit integers with 16.16 fixed-point format:\n * - 16 bits for integer part (-32768 to 32767)\n * - 16 bits for fractional part (precision ~0.000015)\n *\n * All operations are 100% deterministic across platforms.\n */\n\n// Fixed-point constants\nexport const FP_SHIFT = 16;\nexport const FP_ONE = 1 << FP_SHIFT;  // 65536\nexport const FP_HALF = FP_ONE >> 1;    // 32768\nexport const FP_PI = 205887;           // PI * 65536\nexport const FP_2PI = 411775;          // 2*PI * 65536\nexport const FP_HALF_PI = 102944;      // PI/2 * 65536\n\n// Type alias for fixed-point numbers (just integers)\nexport type Fixed = number;\n\n// ============================================\n// Basic Fixed-Point Operations\n// ============================================\n\n/** Convert float to fixed-point */\nexport function toFixed(f: number): Fixed {\n    return Math.round(f * FP_ONE);\n}\n\n/** Convert fixed-point to float (for rendering only) */\nexport function toFloat(fp: Fixed): number {\n    return fp / FP_ONE;\n}\n\n/** Fixed-point multiplication */\nexport function fpMul(a: Fixed, b: Fixed): Fixed {\n    // Use BigInt for intermediate to avoid overflow\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\n    // (e.g., distance calculations on a 1400x900 canvas can overflow)\n    // JavaScript numbers can safely represent integers up to 2^53\n    return Number((BigInt(a) * BigInt(b)) >> BigInt(FP_SHIFT));\n}\n\n/** Fixed-point division */\nexport function fpDiv(a: Fixed, b: Fixed): Fixed {\n    if (b === 0) return a >= 0 ? 0x7FFFFFFF : -0x7FFFFFFF;\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\n    return Number((BigInt(a) << BigInt(FP_SHIFT)) / BigInt(b));\n}\n\n/** Fixed-point absolute value */\nexport function fpAbs(a: Fixed): Fixed {\n    return a < 0 ? -a : a;\n}\n\n/** Fixed-point sign */\nexport function fpSign(a: Fixed): Fixed {\n    return a > 0 ? FP_ONE : a < 0 ? -FP_ONE : 0;\n}\n\n/** Fixed-point min */\nexport function fpMin(a: Fixed, b: Fixed): Fixed {\n    return a < b ? a : b;\n}\n\n/** Fixed-point max */\nexport function fpMax(a: Fixed, b: Fixed): Fixed {\n    return a > b ? a : b;\n}\n\n/** Fixed-point clamp */\nexport function fpClamp(v: Fixed, min: Fixed, max: Fixed): Fixed {\n    return v < min ? min : v > max ? max : v;\n}\n\n/** Fixed-point floor */\nexport function fpFloor(a: Fixed): Fixed {\n    return a & ~(FP_ONE - 1);\n}\n\n/** Fixed-point ceil */\nexport function fpCeil(a: Fixed): Fixed {\n    return (a + FP_ONE - 1) & ~(FP_ONE - 1);\n}\n\n// ============================================\n// Square Root (using Newton-Raphson)\n// ============================================\n\n/** Fixed-point square root using Newton-Raphson iteration */\nexport function fpSqrt(a: Fixed): Fixed {\n    if (a <= 0) return 0;\n\n    // For 16.16 fixed-point: if a = v * 65536, we want sqrt(v) * 65536\n    // sqrt(a) would give sqrt(v) * 256, which is 256x too small!\n    // Solution: compute sqrt(a * 65536) = sqrt(a) * 256 = sqrt(v) * 65536\n    const scaled = BigInt(a) * BigInt(FP_ONE);\n    if (scaled <= 0n) return 0;\n\n    // Better initial guess using bit length\n    let bitLen = 0n;\n    let temp = scaled;\n    while (temp > 0n) {\n        bitLen++;\n        temp >>= 1n;\n    }\n\n    let x = 1n << (bitLen >> 1n);\n    if (x === 0n) x = 1n;\n\n    // Newton-Raphson with proper convergence check\n    let prevX = 0n;\n    for (let i = 0; i < 30; i++) {\n        const xNew = (x + scaled / x) >> 1n;\n        // Check for true convergence (oscillating between x and x+1)\n        if (xNew === x || xNew === prevX) break;\n        prevX = x;\n        x = xNew;\n    }\n\n    // Final adjustment: ensure x*x <= scaled < (x+1)*(x+1)\n    while (x * x > scaled) x--;\n    while ((x + 1n) * (x + 1n) <= scaled) x++;\n\n    return Number(x);\n}\n\n/**\n * Deterministic square root (float API).\n * Takes a float, returns a float, but uses fixed-point internally for determinism.\n *\n * @example\n * const dist = dSqrt(dx * dx + dy * dy);  // Deterministic!\n */\nexport function dSqrt(x: number): number {\n    return toFloat(fpSqrt(toFixed(x)));\n}\n\n// ============================================\n// Trigonometry (Lookup Tables)\n// ============================================\n\n// Sine lookup table (257 entries for 0 to PI/2, inclusive)\n// PRE-COMPUTED for cross-platform determinism - DO NOT use Math.sin() at runtime!\n// Math.sin() produces different results across browsers/CPUs, breaking determinism.\nconst SIN_TABLE_SIZE = 256;\nconst SIN_TABLE: Fixed[] = [\n    0, 402, 804, 1206, 1608, 2010, 2412, 2814, 3216, 3617, 4019, 4420, 4821, 5222, 5623, 6023,\n    6424, 6824, 7224, 7623, 8022, 8421, 8820, 9218, 9616, 10014, 10411, 10808, 11204, 11600, 11996, 12391,\n    12785, 13180, 13573, 13966, 14359, 14751, 15143, 15534, 15924, 16314, 16703, 17091, 17479, 17867, 18253, 18639,\n    19024, 19409, 19792, 20175, 20557, 20939, 21320, 21699, 22078, 22457, 22834, 23210, 23586, 23961, 24335, 24708,\n    25080, 25451, 25821, 26190, 26558, 26925, 27291, 27656, 28020, 28383, 28745, 29106, 29466, 29824, 30182, 30538,\n    30893, 31248, 31600, 31952, 32303, 32652, 33000, 33347, 33692, 34037, 34380, 34721, 35062, 35401, 35738, 36075,\n    36410, 36744, 37076, 37407, 37736, 38064, 38391, 38716, 39040, 39362, 39683, 40002, 40320, 40636, 40951, 41264,\n    41576, 41886, 42194, 42501, 42806, 43110, 43412, 43713, 44011, 44308, 44604, 44898, 45190, 45480, 45769, 46056,\n    46341, 46624, 46906, 47186, 47464, 47741, 48015, 48288, 48559, 48828, 49095, 49361, 49624, 49886, 50146, 50404,\n    50660, 50914, 51166, 51417, 51665, 51911, 52156, 52398, 52639, 52878, 53114, 53349, 53581, 53812, 54040, 54267,\n    54491, 54714, 54934, 55152, 55368, 55582, 55794, 56004, 56212, 56418, 56621, 56823, 57022, 57219, 57414, 57607,\n    57798, 57986, 58172, 58356, 58538, 58718, 58896, 59071, 59244, 59415, 59583, 59750, 59914, 60075, 60235, 60392,\n    60547, 60700, 60851, 60999, 61145, 61288, 61429, 61568, 61705, 61839, 61971, 62101, 62228, 62353, 62476, 62596,\n    62714, 62830, 62943, 63054, 63162, 63268, 63372, 63473, 63572, 63668, 63763, 63854, 63944, 64031, 64115, 64197,\n    64277, 64354, 64429, 64501, 64571, 64639, 64704, 64766, 64827, 64884, 64940, 64993, 65043, 65091, 65137, 65180,\n    65220, 65259, 65294, 65328, 65358, 65387, 65413, 65436, 65457, 65476, 65492, 65505, 65516, 65525, 65531, 65535,\n    65536  // sin(PI/2) = 1.0 = FP_ONE\n];\n\n// Pre-computed constant: (SIN_TABLE_SIZE * 2 / PI) in fixed-point\n// Used to map angles to table indices. Pre-computed to avoid Math.PI at runtime.\nconst FP_ANGLE_TO_INDEX = 10680707;  // = round(162.9746617261 * 65536)\n\n/** Fixed-point sine using lookup table with linear interpolation */\nexport function fpSin(angle: Fixed): Fixed {\n    // Normalize angle to 0 to 2PI using modulo (avoids infinite loops)\n    // First handle negative angles\n    if (angle < 0) {\n        const periods = ((-angle / FP_2PI) | 0) + 1;\n        angle += periods * FP_2PI;\n    }\n    // Then reduce to 0..2PI range\n    if (angle >= FP_2PI) {\n        angle = angle % FP_2PI;\n    }\n\n    // Determine quadrant\n    let quadrant = 0;\n    if (angle >= FP_PI) {\n        angle -= FP_PI;\n        quadrant = 2;\n    }\n    if (angle >= FP_HALF_PI) {\n        angle = FP_PI - angle;\n        quadrant += 1;\n    }\n\n    // Map angle to table index (0 to 256)\n    const indexFp = fpMul(angle, FP_ANGLE_TO_INDEX);\n    const index = indexFp >> FP_SHIFT;\n    const frac = indexFp & (FP_ONE - 1);\n\n    // Linear interpolation with safe bounds clamping\n    const clampedIndex = index < 0 ? 0 : (index > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : index);\n    const nextIndex = index + 1;\n    const clampedIndexNext = nextIndex < 0 ? 0 : (nextIndex > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : nextIndex);\n    const a = SIN_TABLE[clampedIndex] ?? 0;\n    const b = SIN_TABLE[clampedIndexNext] ?? FP_ONE;\n    let result = a + fpMul(b - a, frac);\n\n    // Apply quadrant sign\n    if (quadrant >= 2) result = -result;\n\n    return result;\n}\n\n/** Fixed-point cosine */\nexport function fpCos(angle: Fixed): Fixed {\n    return fpSin(angle + FP_HALF_PI);\n}\n\n/** Fixed-point atan2 using CORDIC-style approximation */\nexport function fpAtan2(y: Fixed, x: Fixed): Fixed {\n    if (x === 0 && y === 0) return 0;\n\n    const absX = fpAbs(x);\n    const absY = fpAbs(y);\n\n    // Use approximation: atan(y/x) = (PI/4) * (y/x) for |y/x| <= 1\n    let angle: Fixed;\n    if (absX >= absY) {\n        const ratio = fpDiv(absY, absX);\n        // atan approximation for small angles\n        angle = fpMul(ratio, 51472); // PI/4 * 65536 = 51472\n    } else {\n        const ratio = fpDiv(absX, absY);\n        angle = FP_HALF_PI - fpMul(ratio, 51472);\n    }\n\n    // Adjust for quadrant\n    if (x < 0) angle = FP_PI - angle;\n    if (y < 0) angle = -angle;\n\n    return angle;\n}\n", "/**\r\n * Fixed-Point Vector Types\r\n *\r\n * 2D and 3D vectors using fixed-point arithmetic for deterministic physics.\r\n */\r\n\r\nimport { Fixed, FP_ONE, toFixed, toFloat, fpMul, fpDiv, fpSqrt } from './fixed';\r\n\r\n// ============================================\r\n// 2D Vector (Fixed-Point)\r\n// ============================================\r\n\r\nexport interface Vec2 {\r\n    x: Fixed;\r\n    y: Fixed;\r\n}\r\n\r\nexport function vec2(x: number, y: number): Vec2 {\r\n    return { x: toFixed(x), y: toFixed(y) };\r\n}\r\n\r\nexport function vec2Zero(): Vec2 {\r\n    return { x: 0, y: 0 };\r\n}\r\n\r\nexport function vec2FromFixed(x: Fixed, y: Fixed): Vec2 {\r\n    return { x, y };\r\n}\r\n\r\nexport function vec2Clone(v: Vec2): Vec2 {\r\n    return { x: v.x, y: v.y };\r\n}\r\n\r\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\r\n    return { x: a.x + b.x, y: a.y + b.y };\r\n}\r\n\r\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\r\n    return { x: a.x - b.x, y: a.y - b.y };\r\n}\r\n\r\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\r\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\r\n}\r\n\r\nexport function vec2Neg(v: Vec2): Vec2 {\r\n    return { x: -v.x, y: -v.y };\r\n}\r\n\r\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\r\n    return fpMul(a.x, b.x) + fpMul(a.y, b.y);\r\n}\r\n\r\n/** 2D cross product (returns z component of 3D cross) */\r\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\r\n    return fpMul(a.x, b.y) - fpMul(a.y, b.x);\r\n}\r\n\r\nexport function vec2LengthSq(v: Vec2): Fixed {\r\n    return fpMul(v.x, v.x) + fpMul(v.y, v.y);\r\n}\r\n\r\nexport function vec2Length(v: Vec2): Fixed {\r\n    return fpSqrt(vec2LengthSq(v));\r\n}\r\n\r\nexport function vec2Normalize(v: Vec2): Vec2 {\r\n    const len = vec2Length(v);\r\n    if (len === 0) return vec2Zero();\r\n    return { x: fpDiv(v.x, len), y: fpDiv(v.y, len) };\r\n}\r\n\r\nexport function vec2Lerp(a: Vec2, b: Vec2, t: Fixed): Vec2 {\r\n    const oneMinusT = FP_ONE - t;\r\n    return {\r\n        x: fpMul(a.x, oneMinusT) + fpMul(b.x, t),\r\n        y: fpMul(a.y, oneMinusT) + fpMul(b.y, t)\r\n    };\r\n}\r\n\r\nexport function vec2Distance(a: Vec2, b: Vec2): Fixed {\r\n    return vec2Length(vec2Sub(b, a));\r\n}\r\n\r\nexport function vec2DistanceSq(a: Vec2, b: Vec2): Fixed {\r\n    return vec2LengthSq(vec2Sub(b, a));\r\n}\r\n\r\n// ============================================\r\n// 3D Vector (Fixed-Point)\r\n// ============================================\r\n\r\nexport interface Vec3 {\r\n    x: Fixed;\r\n    y: Fixed;\r\n    z: Fixed;\r\n}\r\n\r\nexport function vec3(x: Fixed, y: Fixed, z: Fixed): Vec3 {\r\n    return { x, y, z };\r\n}\r\n\r\nexport function vec3Zero(): Vec3 {\r\n    return { x: 0, y: 0, z: 0 };\r\n}\r\n\r\nexport function vec3FromFloats(x: number, y: number, z: number): Vec3 {\r\n    return { x: toFixed(x), y: toFixed(y), z: toFixed(z) };\r\n}\r\n\r\nexport function vec3ToFloats(v: Vec3): { x: number; y: number; z: number } {\r\n    return { x: toFloat(v.x), y: toFloat(v.y), z: toFloat(v.z) };\r\n}\r\n\r\nexport function vec3Clone(v: Vec3): Vec3 {\r\n    return { x: v.x, y: v.y, z: v.z };\r\n}\r\n\r\nexport function vec3Add(a: Vec3, b: Vec3): Vec3 {\r\n    return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\r\n}\r\n\r\nexport function vec3Sub(a: Vec3, b: Vec3): Vec3 {\r\n    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\r\n}\r\n\r\nexport function vec3Scale(v: Vec3, s: Fixed): Vec3 {\r\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s), z: fpMul(v.z, s) };\r\n}\r\n\r\nexport function vec3Neg(v: Vec3): Vec3 {\r\n    return { x: -v.x, y: -v.y, z: -v.z };\r\n}\r\n\r\nexport function vec3Dot(a: Vec3, b: Vec3): Fixed {\r\n    return fpMul(a.x, b.x) + fpMul(a.y, b.y) + fpMul(a.z, b.z);\r\n}\r\n\r\nexport function vec3Cross(a: Vec3, b: Vec3): Vec3 {\r\n    return {\r\n        x: fpMul(a.y, b.z) - fpMul(a.z, b.y),\r\n        y: fpMul(a.z, b.x) - fpMul(a.x, b.z),\r\n        z: fpMul(a.x, b.y) - fpMul(a.y, b.x)\r\n    };\r\n}\r\n\r\nexport function vec3LengthSq(v: Vec3): Fixed {\r\n    return fpMul(v.x, v.x) + fpMul(v.y, v.y) + fpMul(v.z, v.z);\r\n}\r\n\r\nexport function vec3Length(v: Vec3): Fixed {\r\n    return fpSqrt(vec3LengthSq(v));\r\n}\r\n\r\nexport function vec3Normalize(v: Vec3): Vec3 {\r\n    const len = vec3Length(v);\r\n    if (len === 0) return vec3Zero();\r\n    return { x: fpDiv(v.x, len), y: fpDiv(v.y, len), z: fpDiv(v.z, len) };\r\n}\r\n\r\nexport function vec3Lerp(a: Vec3, b: Vec3, t: Fixed): Vec3 {\r\n    const oneMinusT = FP_ONE - t;\r\n    return {\r\n        x: fpMul(a.x, oneMinusT) + fpMul(b.x, t),\r\n        y: fpMul(a.y, oneMinusT) + fpMul(b.y, t),\r\n        z: fpMul(a.z, oneMinusT) + fpMul(b.z, t)\r\n    };\r\n}\r\n\r\nexport function vec3Distance(a: Vec3, b: Vec3): Fixed {\r\n    return vec3Length(vec3Sub(b, a));\r\n}\r\n\r\nexport function vec3DistanceSq(a: Vec3, b: Vec3): Fixed {\r\n    return vec3LengthSq(vec3Sub(b, a));\r\n}\r\n", "/**\r\n * Fixed-Point Quaternion Operations\r\n *\r\n * Quaternion math for 3D rotations using fixed-point arithmetic.\r\n */\r\n\r\nimport { Fixed, FP_ONE, fpMul, fpDiv, fpSqrt, fpSin, fpCos } from './fixed';\r\nimport { Vec3, vec3, vec3Normalize, vec3Cross, vec3Add, vec3Scale } from './vec';\r\n\r\n// ============================================\r\n// Quaternion (Fixed-Point)\r\n// ============================================\r\n\r\nexport interface Quat {\r\n    x: Fixed;\r\n    y: Fixed;\r\n    z: Fixed;\r\n    w: Fixed;\r\n}\r\n\r\nexport function quatIdentity(): Quat {\r\n    return { x: 0, y: 0, z: 0, w: FP_ONE };\r\n}\r\n\r\nexport function quatFromAxisAngle(axis: Vec3, angle: Fixed): Quat {\r\n    const halfAngle = angle >> 1;\r\n    const s = fpSin(halfAngle);\r\n    const c = fpCos(halfAngle);\r\n    const normAxis = vec3Normalize(axis);\r\n    return {\r\n        x: fpMul(normAxis.x, s),\r\n        y: fpMul(normAxis.y, s),\r\n        z: fpMul(normAxis.z, s),\r\n        w: c\r\n    };\r\n}\r\n\r\nexport function quatFromEulerY(yaw: Fixed): Quat {\r\n    const halfAngle = yaw >> 1;\r\n    return {\r\n        x: 0,\r\n        y: fpSin(halfAngle),\r\n        z: 0,\r\n        w: fpCos(halfAngle)\r\n    };\r\n}\r\n\r\nexport function quatMul(a: Quat, b: Quat): Quat {\r\n    return {\r\n        x: fpMul(a.w, b.x) + fpMul(a.x, b.w) + fpMul(a.y, b.z) - fpMul(a.z, b.y),\r\n        y: fpMul(a.w, b.y) - fpMul(a.x, b.z) + fpMul(a.y, b.w) + fpMul(a.z, b.x),\r\n        z: fpMul(a.w, b.z) + fpMul(a.x, b.y) - fpMul(a.y, b.x) + fpMul(a.z, b.w),\r\n        w: fpMul(a.w, b.w) - fpMul(a.x, b.x) - fpMul(a.y, b.y) - fpMul(a.z, b.z)\r\n    };\r\n}\r\n\r\nexport function quatRotateVec3(q: Quat, v: Vec3): Vec3 {\r\n    // q * v * q^-1 (optimized)\r\n    const qv = vec3(q.x, q.y, q.z);\r\n    const uv = vec3Cross(qv, v);\r\n    const uuv = vec3Cross(qv, uv);\r\n    return vec3Add(v, vec3Add(vec3Scale(uv, q.w << 1), vec3Scale(uuv, FP_ONE << 1)));\r\n}\r\n\r\nexport function quatNormalize(q: Quat): Quat {\r\n    const lenSq = fpMul(q.x, q.x) + fpMul(q.y, q.y) + fpMul(q.z, q.z) + fpMul(q.w, q.w);\r\n    const len = fpSqrt(lenSq);\r\n    if (len === 0) return quatIdentity();\r\n    return {\r\n        x: fpDiv(q.x, len),\r\n        y: fpDiv(q.y, len),\r\n        z: fpDiv(q.z, len),\r\n        w: fpDiv(q.w, len)\r\n    };\r\n}\r\n\r\n/** Quaternion conjugate (inverse for unit quaternions) */\r\nexport function quatConjugate(q: Quat): Quat {\r\n    return { x: -q.x as Fixed, y: -q.y as Fixed, z: -q.z as Fixed, w: q.w };\r\n}\r\n\r\n/** Clone a quaternion */\r\nexport function quatClone(q: Quat): Quat {\r\n    return { x: q.x, y: q.y, z: q.z, w: q.w };\r\n}\r\n", "/**\r\n * Deterministic Random\r\n *\r\n * Simple, deterministic random function. Same seed = same sequence.\r\n * Automatically overrides Math.random() on import for full determinism.\r\n */\r\n\r\n// ============================================\r\n// Internal State\r\n// ============================================\r\n\r\nlet s0 = 1;\r\nlet s1 = 2;\r\n\r\n// ============================================\r\n// Core Random Function\r\n// ============================================\r\n\r\nfunction next(): number {\r\n    let x = s0;\r\n    const y = s1;\r\n    s0 = y;\r\n    x ^= (x << 23) >>> 0;\r\n    x ^= x >>> 17;\r\n    x ^= y;\r\n    x ^= y >>> 26;\r\n    s1 = x >>> 0;\r\n    return (s0 + s1) >>> 0;\r\n}\r\n\r\n// ============================================\r\n// Public API\r\n// ============================================\r\n\r\n/**\r\n * Set the random seed (internal use).\r\n */\r\nfunction setSeed(seed: number): void {\r\n    seed = seed >>> 0;\r\n    if (seed === 0) seed = 1;\r\n\r\n    // Mix the seed into two state values\r\n    let s = seed;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s0 = ((s >>> 16) ^ s) >>> 0;\r\n\r\n    s = (seed * 0x9e3779b9) >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s1 = ((s >>> 16) ^ s) >>> 0;\r\n\r\n    if (s0 === 0 && s1 === 0) s0 = 1;\r\n}\r\n\r\n/**\r\n * Get random float between 0 (inclusive) and 1 (exclusive).\r\n * Works like Math.random() but deterministic.\r\n */\r\nexport function dRandom(): number {\r\n    return next() / 0x100000000;\r\n}\r\n\r\n// ============================================\r\n// State Save/Load (for rollback)\r\n// ============================================\r\n\r\nexport interface RandomState {\r\n    s0: number;\r\n    s1: number;\r\n}\r\n\r\nexport function saveRandomState(): RandomState {\r\n    return { s0, s1 };\r\n}\r\n\r\nexport function loadRandomState(state: RandomState): void {\r\n    s0 = state.s0;\r\n    s1 = state.s1;\r\n}\r\n\r\n// Initialize with default seed\r\nsetSeed(1);\r\n", "/**\r\n * ECS Constants\r\n *\r\n * Core constants for the Entity-Component-System architecture.\r\n */\r\n\r\n/**\r\n * Maximum number of concurrent entities.\r\n *\r\n * This is a hard limit due to TypedArray storage. Exceeding this will\r\n * throw an error. For most games, 10,000 is far more than needed.\r\n *\r\n * Memory usage per component field: MAX_ENTITIES \u00D7 4 bytes = 40 KB\r\n * With 10 components \u00D7 5 fields average = 2 MB total\r\n */\r\nexport const MAX_ENTITIES = 10_000;\r\n\r\n/**\r\n * Entity ID format: [12 bits generation][20 bits index]\r\n * - Generation: Prevents ABA problem when IDs are recycled\r\n * - Index: Direct array index for O(1) component access\r\n */\r\nexport const GENERATION_BITS = 12;\r\nexport const INDEX_BITS = 20;\r\nexport const INDEX_MASK = (1 << INDEX_BITS) - 1;\r\nexport const MAX_GENERATION = (1 << GENERATION_BITS) - 1;\r\n\r\n/**\r\n * System execution phases (in order)\r\n */\r\nexport const SYSTEM_PHASES = [\r\n    'input',\r\n    'update',\r\n    'prePhysics',\r\n    'physics',\r\n    'postPhysics',\r\n    'render'\r\n] as const;\r\n\r\nexport type SystemPhase = typeof SYSTEM_PHASES[number];\r\n", "/**\r\n * Component System\r\n *\r\n * Components are pure data containers. This module handles:\r\n * - Component type definitions with schemas\r\n * - Type inference from default values\r\n * - SoA (Structure of Arrays) storage allocation\r\n * - Pre-generated accessor class creation\r\n */\r\n\r\nimport { MAX_ENTITIES } from './constants';\r\nimport { toFixed, toFloat } from '../math';\r\n\r\n/**\r\n * Supported field types for components.\r\n * - i32: 32-bit integer (default for numbers, uses fixed-point for physics)\r\n * - u8: 8-bit unsigned (for flags, enums)\r\n * - bool: boolean (stored as u8)\r\n * - f32: 32-bit float (ONLY for render-only data, NON-DETERMINISTIC)\r\n */\r\nexport type FieldType = 'i32' | 'u8' | 'bool' | 'f32';\r\n\r\nexport interface FieldDefinition {\r\n    type: FieldType;\r\n    default: number | boolean;\r\n}\r\n\r\nexport interface ComponentSchema {\r\n    [fieldName: string]: FieldDefinition;\r\n}\r\n\r\n/**\r\n * Component storage using Structure of Arrays (SoA) pattern.\r\n * Each field is stored in a separate TypedArray for cache efficiency.\r\n */\r\nexport interface ComponentStorage {\r\n    /** Bitmask tracking which entities have this component */\r\n    mask: Uint32Array;\r\n\r\n    /** Field arrays indexed by entity index */\r\n    fields: Record<string, Int32Array | Uint8Array | Float32Array>;\r\n\r\n    /** Schema defining field types */\r\n    schema: ComponentSchema;\r\n}\r\n\r\n/**\r\n * Options for defining a component.\r\n */\r\nexport interface ComponentOptions {\r\n    /**\r\n     * Whether this component should be synchronized across the network.\r\n     * When false, the component is excluded from:\r\n     * - Network snapshots (not sent to other clients)\r\n     * - State hash computation (doesn't affect determinism checks)\r\n     * - Rollback state (not saved/restored during rollback)\r\n     *\r\n     * Use sync: false for client-only state like cameras, UI, local effects.\r\n     * @default true\r\n     */\r\n    sync?: boolean;\r\n}\r\n\r\n/**\r\n * Component type definition.\r\n */\r\nexport interface ComponentType<T extends Record<string, any> = any> {\r\n    readonly name: string;\r\n    readonly schema: ComponentSchema;\r\n    readonly storage: ComponentStorage;\r\n    readonly AccessorClass: new (index: number) => T;\r\n    readonly fieldNames: string[];\r\n    /** Whether this component is synchronized across network. Default: true */\r\n    readonly sync: boolean;\r\n}\r\n\r\n/**\r\n * Infer field definition from a default value.\r\n * ALL numbers default to i32 for determinism.\r\n * f32 requires explicit declaration and logs a warning.\r\n */\r\nexport function inferFieldDef(value: any): FieldDefinition {\r\n    // Explicit type definition\r\n    if (typeof value === 'object' && value !== null && 'type' in value) {\r\n        const def = value as { type: FieldType; default?: number | boolean };\r\n\r\n        if (def.type === 'f32') {\r\n            console.warn(\r\n                `Component field uses f32 which is NON-DETERMINISTIC. ` +\r\n                `Only use for render-only data, never for synced state.`\r\n            );\r\n        }\r\n\r\n        return {\r\n            type: def.type,\r\n            default: def.default ?? (def.type === 'bool' ? false : 0)\r\n        };\r\n    }\r\n\r\n    // Boolean inference\r\n    if (typeof value === 'boolean') {\r\n        return { type: 'bool', default: value };\r\n    }\r\n\r\n    // Number inference - ALL default to i32 for determinism\r\n    if (typeof value === 'number') {\r\n        return { type: 'i32', default: value };\r\n    }\r\n\r\n    // Null/undefined treated as i32 with 0 default\r\n    if (value === null || value === undefined) {\r\n        return { type: 'i32', default: 0 };\r\n    }\r\n\r\n    throw new Error(\r\n        `Unsupported field type: ${typeof value}. ` +\r\n        `Components can only contain numbers and booleans. ` +\r\n        `Use game.internString() for string values.`\r\n    );\r\n}\r\n\r\n/**\r\n * Create TypedArray for a field type.\r\n */\r\nfunction createFieldArray(type: FieldType): Int32Array | Uint8Array | Float32Array {\r\n    switch (type) {\r\n        case 'i32':\r\n            return new Int32Array(MAX_ENTITIES);\r\n        case 'u8':\r\n        case 'bool':\r\n            return new Uint8Array(MAX_ENTITIES);\r\n        case 'f32':\r\n            return new Float32Array(MAX_ENTITIES);\r\n        default:\r\n            throw new Error(`Unknown field type: ${type}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Create SoA storage for a component schema.\r\n */\r\nexport function createComponentStorage(schema: ComponentSchema): ComponentStorage {\r\n    const fields: Record<string, Int32Array | Uint8Array | Float32Array> = {};\r\n\r\n    for (const [name, def] of Object.entries(schema)) {\r\n        fields[name] = createFieldArray(def.type);\r\n    }\r\n\r\n    return {\r\n        mask: new Uint32Array(Math.ceil(MAX_ENTITIES / 32)),\r\n        fields,\r\n        schema\r\n    };\r\n}\r\n\r\n/**\r\n * Generate an accessor class for a component type.\r\n * Uses Object.defineProperty for optimal V8 performance (not Proxy).\r\n */\r\nexport function generateAccessorClass<T>(\r\n    name: string,\r\n    schema: ComponentSchema,\r\n    storage: ComponentStorage\r\n): new (index: number) => T {\r\n    // Create a class dynamically\r\n    const AccessorClass = function(this: any, index: number) {\r\n        this._index = index;\r\n    } as any;\r\n\r\n    AccessorClass.prototype = {};\r\n\r\n    // Add getter/setter for each field\r\n    for (const [fieldName, fieldDef] of Object.entries(schema)) {\r\n        const fieldArray = storage.fields[fieldName];\r\n        const isFixedPoint = fieldDef.type === 'i32';\r\n        const isBool = fieldDef.type === 'bool';\r\n\r\n        Object.defineProperty(AccessorClass.prototype, fieldName, {\r\n            get: function(this: { _index: number }) {\r\n                const value = fieldArray[this._index];\r\n                if (isBool) return value !== 0;\r\n                if (isFixedPoint) return toFloat(value as number);\r\n                return value;\r\n            },\r\n            set: function(this: { _index: number }, value: any) {\r\n                if (isBool) {\r\n                    fieldArray[this._index] = value ? 1 : 0;\r\n                } else if (isFixedPoint) {\r\n                    fieldArray[this._index] = toFixed(value);\r\n                } else {\r\n                    fieldArray[this._index] = value;\r\n                }\r\n            },\r\n            enumerable: true,\r\n            configurable: false\r\n        });\r\n    }\r\n\r\n    // Add _index property definition\r\n    Object.defineProperty(AccessorClass.prototype, '_index', {\r\n        value: 0,\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    return AccessorClass as new (index: number) => T;\r\n}\r\n\r\n/**\r\n * Component registry - stores all defined components.\r\n */\r\nconst componentRegistry = new Map<string, ComponentType>();\r\n\r\n/**\r\n * Define a new component type.\r\n *\r\n * @param name Unique component name\r\n * @param defaults Default values (type inferred from values)\r\n * @param options Optional configuration (sync, etc.)\r\n * @returns ComponentType for use in entity definitions\r\n *\r\n * @example\r\n * const Health = defineComponent('health', { current: 100, max: 100 });\r\n * const Position = defineComponent('position', { x: 0, y: 0 });\r\n *\r\n * // Client-only component (not synced)\r\n * const Camera2D = defineComponent('camera2d', { zoom: 1, targetZoom: 1 }, { sync: false });\r\n */\r\nexport function defineComponent<T extends Record<string, any>>(\r\n    name: string,\r\n    defaults: T,\r\n    options?: ComponentOptions\r\n): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\r\n    if (componentRegistry.has(name)) {\r\n        throw new Error(`Component '${name}' is already defined`);\r\n    }\r\n\r\n    // Build schema from defaults\r\n    const schema: ComponentSchema = {};\r\n    for (const [fieldName, defaultValue] of Object.entries(defaults)) {\r\n        schema[fieldName] = inferFieldDef(defaultValue);\r\n    }\r\n\r\n    // Create storage\r\n    const storage = createComponentStorage(schema);\r\n\r\n    // Generate accessor class\r\n    const AccessorClass = generateAccessorClass<any>(name, schema, storage);\r\n\r\n    const componentType: ComponentType = {\r\n        name,\r\n        schema,\r\n        storage,\r\n        AccessorClass,\r\n        fieldNames: Object.keys(schema),\r\n        sync: options?.sync !== false // Default to true\r\n    };\r\n\r\n    componentRegistry.set(name, componentType);\r\n\r\n    return componentType as any;\r\n}\r\n\r\n/**\r\n * Get a component type by name.\r\n */\r\nexport function getComponentType(name: string): ComponentType | undefined {\r\n    return componentRegistry.get(name);\r\n}\r\n\r\n/**\r\n * Check if entity has component (via bitmask).\r\n */\r\nexport function hasComponent(storage: ComponentStorage, index: number): boolean {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    return (storage.mask[word] & bit) !== 0;\r\n}\r\n\r\n/**\r\n * Add component to entity (set bit in mask).\r\n */\r\nexport function addComponentToEntity(storage: ComponentStorage, index: number): void {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    storage.mask[word] |= bit;\r\n}\r\n\r\n/**\r\n * Remove component from entity (clear bit in mask).\r\n */\r\nexport function removeComponentFromEntity(storage: ComponentStorage, index: number): void {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    storage.mask[word] &= ~bit;\r\n}\r\n\r\n/**\r\n * Initialize component fields to defaults for an entity.\r\n */\r\nexport function initializeComponentDefaults(storage: ComponentStorage, index: number): void {\r\n    for (const [fieldName, fieldDef] of Object.entries(storage.schema)) {\r\n        const arr = storage.fields[fieldName];\r\n        if (fieldDef.type === 'i32') {\r\n            arr[index] = toFixed(fieldDef.default as number);\r\n        } else if (fieldDef.type === 'bool') {\r\n            arr[index] = fieldDef.default ? 1 : 0;\r\n        } else {\r\n            arr[index] = fieldDef.default as number;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Clear all component registrations (for testing).\r\n */\r\nexport function clearComponentRegistry(): void {\r\n    componentRegistry.clear();\r\n}\r\n\r\n/**\r\n * Get all registered components.\r\n */\r\nexport function getAllComponents(): Map<string, ComponentType> {\r\n    return componentRegistry;\r\n}\r\n", "/**\n * Entity ID Allocator\n *\n * Manages entity ID allocation with generation counters for ABA safety.\n * Entity ID format: [12 bits generation][20 bits index]\n */\n\nimport {\n    MAX_ENTITIES,\n    INDEX_MASK,\n    INDEX_BITS,\n    MAX_GENERATION,\n    GENERATION_BITS\n} from './constants';\n\nexport interface EntityIdAllocatorState {\n    nextIndex: number;\n    freeList: number[];\n    generations: number[];\n}\n\nexport class EntityIdAllocator {\n    /** Generation counter for each entity slot */\n    private generations: Uint16Array;\n\n    /** Free list of available indices (sorted ascending for determinism) */\n    private freeList: number[] = [];\n\n    /** Next index to allocate if free list is empty */\n    private nextIndex: number = 0;\n\n    constructor() {\n        this.generations = new Uint16Array(MAX_ENTITIES);\n    }\n\n    /**\n     * Allocate a new entity ID.\n     * Returns entity ID with generation encoded.\n     */\n    allocate(): number {\n        let index: number;\n\n        if (this.freeList.length > 0) {\n            // Always take the LOWEST available index for determinism\n            index = this.freeList.shift()!;\n        } else {\n            if (this.nextIndex >= MAX_ENTITIES) {\n                throw new Error(\n                    `Entity limit exceeded (MAX_ENTITIES=${MAX_ENTITIES}). ` +\n                    `Consider destroying unused entities or increasing the limit.`\n                );\n            }\n            index = this.nextIndex++;\n        }\n\n        const generation = this.generations[index];\n        return (generation << INDEX_BITS) | index;\n    }\n\n    /**\n     * Free an entity ID, returning it to the pool.\n     * Increments generation to invalidate stale references.\n     */\n    free(eid: number): void {\n        const index = eid & INDEX_MASK;\n\n        // Increment generation (wrap at max)\n        this.generations[index] = ((this.generations[index] + 1) & MAX_GENERATION) as number;\n\n        // Binary search insert to maintain sorted order (deterministic)\n        const insertIdx = this.findInsertIndex(index);\n        this.freeList.splice(insertIdx, 0, index);\n    }\n\n    /**\n     * Check if an entity ID is still valid (generation matches).\n     */\n    isValid(eid: number): boolean {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n        return index < this.nextIndex && this.generations[index] === generation;\n    }\n\n    /**\n     * Get the index portion of an entity ID.\n     */\n    getIndex(eid: number): number {\n        return eid & INDEX_MASK;\n    }\n\n    /**\n     * Get the generation portion of an entity ID.\n     */\n    getGeneration(eid: number): number {\n        return eid >>> INDEX_BITS;\n    }\n\n    /**\n     * Get current state for snapshotting.\n     */\n    getState(): EntityIdAllocatorState {\n        return {\n            nextIndex: this.nextIndex,\n            freeList: [...this.freeList],\n            generations: Array.from(this.generations.slice(0, this.nextIndex))\n        };\n    }\n\n    /**\n     * Restore state from snapshot.\n     */\n    setState(state: EntityIdAllocatorState): void {\n        this.nextIndex = state.nextIndex;\n        this.freeList = [...state.freeList];\n\n        // Restore generations\n        for (let i = 0; i < state.generations.length; i++) {\n            this.generations[i] = state.generations[i];\n        }\n    }\n\n    /**\n     * Reset allocator to initial state.\n     */\n    reset(): void {\n        this.nextIndex = 0;\n        this.freeList = [];\n        this.generations.fill(0);\n    }\n\n    /**\n     * Get number of active entities.\n     */\n    getActiveCount(): number {\n        return this.nextIndex - this.freeList.length;\n    }\n\n    /**\n     * Binary search to find insert position for sorted free list.\n     */\n    /**\n     * Get next ID that will be allocated (for snapshots).\n     */\n    getNextId(): number {\n        return this.nextIndex;\n    }\n\n    /**\n     * Set next ID (for snapshot restore).\n     */\n    setNextId(id: number): void {\n        this.nextIndex = id;\n    }\n\n    /**\n     * Allocate a specific entity ID (for snapshot restore).\n     * This bypasses normal allocation and marks the specific eid as used.\n     * Returns the requested eid.\n     */\n    allocateSpecific(eid: number): number {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n\n        // Extend nextIndex if needed\n        if (index >= this.nextIndex) {\n            this.nextIndex = index + 1;\n        }\n\n        // Remove from free list if present\n        const freeIdx = this.freeList.indexOf(index);\n        if (freeIdx !== -1) {\n            this.freeList.splice(freeIdx, 1);\n        }\n\n        // Set the generation\n        this.generations[index] = generation;\n\n        return eid;\n    }\n\n    private findInsertIndex(index: number): number {\n        let lo = 0;\n        let hi = this.freeList.length;\n\n        while (lo < hi) {\n            const mid = (lo + hi) >>> 1;\n            if (this.freeList[mid] < index) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n}\n", "/**\r\n * Standard ECS Components\r\n *\r\n * Built-in components for common game functionality.\r\n * All numeric values use fixed-point (i32) for determinism.\r\n */\r\n\r\nimport { defineComponent, ComponentType } from '../core/component';\r\n\r\n/**\r\n * Transform2D - Position and rotation.\r\n */\r\nexport const Transform2D = defineComponent('Transform2D', {\r\n    x: 0,\r\n    y: 0,\r\n    angle: 0\r\n});\r\n\r\n/**\r\n * Body2D - Physics body properties.\r\n */\r\nexport const Body2D = defineComponent('Body2D', {\r\n    // Velocity\r\n    vx: 0,\r\n    vy: 0,\r\n\r\n    // Angular velocity\r\n    angularVelocity: 0,\r\n\r\n    // Force accumulator (added to velocity each frame, then cleared)\r\n    forceX: 0,\r\n    forceY: 0,\r\n\r\n    // Impulse accumulator (added to velocity once, then cleared)\r\n    impulseX: 0,\r\n    impulseY: 0,\r\n\r\n    // Size (use width/height OR radius)\r\n    width: 0,\r\n    height: 0,\r\n    radius: 0,\r\n\r\n    // Physics properties\r\n    mass: 1,\r\n    restitution: 0,    // Bounciness (0-1)\r\n    friction: 0,\r\n\r\n    // Body type: 0=dynamic, 1=static, 2=kinematic\r\n    bodyType: 0,\r\n\r\n    // Shape type: 0=rect, 1=circle\r\n    shapeType: 1,\r\n\r\n    // Is sensor (no collision response, just events)\r\n    damping: 0,\r\n    isSensor: false\r\n});\r\n\r\n/**\r\n * Player - Marks an entity as player-controlled.\r\n * This is the ownership component - attach to any entity a player controls.\r\n * clientId is stored as interned string ID (integer).\r\n */\r\nexport const Player = defineComponent('Player', {\r\n    clientId: 0    // Interned clientId string\r\n});\r\n\r\n/**\r\n * Sprite - Visual rendering component.\r\n *\r\n * Can render either:\r\n * - Simple shapes (circle, rect) with color\r\n * - Image sprites (via spriteId)\r\n */\r\nexport const Sprite = defineComponent('Sprite', {\r\n    // Shape type: 0=rect, 1=circle, 2=image\r\n    shape: 1,  // Default circle\r\n\r\n    // Size (for shapes)\r\n    width: 0,\r\n    height: 0,\r\n    radius: 10,\r\n\r\n    // Color (interned string ID, e.g., '#ff0000')\r\n    color: 0,\r\n\r\n    // Image sprite ID (interned string, for shape=SPRITE_IMAGE)\r\n    spriteId: 0,\r\n\r\n    // Render offset from transform position\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n\r\n    // Scale\r\n    scaleX: 1,\r\n    scaleY: 1,\r\n\r\n    // Layer for z-ordering (higher = in front)\r\n    layer: 0,\r\n\r\n    // Visibility\r\n    visible: true\r\n});\r\n\r\n// Sprite shape constants (reuse SHAPE_RECT, SHAPE_CIRCLE, add SPRITE_IMAGE)\r\nexport const SPRITE_IMAGE = 2;\r\n\r\n/**\r\n * Camera2D - 2D camera for viewport control.\r\n *\r\n * This is a client-only component (sync: false) - each client manages\r\n * their own camera independently. The camera is not included in:\r\n * - Network snapshots\r\n * - State hash computation\r\n * - Rollback state\r\n *\r\n * @example\r\n * // Define camera entity\r\n * game.defineEntity('camera')\r\n *     .with(Camera2D)\r\n *     .register();\r\n *\r\n * // Spawn and use camera\r\n * const cam = game.spawn('camera');\r\n * const camera = cam.get(Camera2D);\r\n * camera.x = player.x;\r\n * camera.y = player.y;\r\n * camera.zoom = 1.5;\r\n */\r\nexport const Camera2D = defineComponent('Camera2D', {\r\n    // Position (world coordinates the camera is centered on)\r\n    x: 0,\r\n    y: 0,\r\n\r\n    // Zoom level (1 = normal, >1 = zoomed in, <1 = zoomed out)\r\n    zoom: 1,\r\n\r\n    // Target zoom for smooth transitions\r\n    targetZoom: 1,\r\n\r\n    // Smoothing factor for position interpolation (0-1, higher = snappier)\r\n    smoothing: 0.1,\r\n\r\n    // Optional: follow entity ID (0 = no target)\r\n    followEntity: 0,\r\n\r\n    // Viewport bounds (set by renderer)\r\n    viewportWidth: 0,\r\n    viewportHeight: 0\r\n}, { sync: false });\r\n\r\n// Re-export types for convenience\r\nexport type Transform2DData = {\r\n    x: number;\r\n    y: number;\r\n    angle: number;\r\n};\r\n\r\nexport type Body2DData = {\r\n    vx: number;\r\n    vy: number;\r\n    angularVelocity: number;\r\n    forceX: number;\r\n    forceY: number;\r\n    impulseX: number;\r\n    impulseY: number;\r\n    width: number;\r\n    height: number;\r\n    radius: number;\r\n    mass: number;\r\n    restitution: number;\r\n    friction: number;\r\n    bodyType: number;\r\n    shapeType: number;\r\n    isSensor: boolean;\r\n};\r\n\r\nexport type PlayerType = {\r\n    clientId: number;\r\n};\r\n\r\n// Body type constants\r\nexport const BODY_DYNAMIC = 0;\r\nexport const BODY_STATIC = 1;\r\nexport const BODY_KINEMATIC = 2;\r\n\r\n// Shape type constants\r\nexport const SHAPE_RECT = 0;\r\nexport const SHAPE_CIRCLE = 1;\r\n\r\nexport type Camera2DData = {\r\n    x: number;\r\n    y: number;\r\n    zoom: number;\r\n    targetZoom: number;\r\n    smoothing: number;\r\n    followEntity: number;\r\n    viewportWidth: number;\r\n    viewportHeight: number;\r\n};\r\n", "/**\r\n * Entity Wrapper\r\n *\r\n * Provides an ergonomic API for entity access while using SoA storage internally.\r\n * Entity wrappers are pooled and reused to minimize allocations.\r\n */\r\n\r\nimport {\r\n    ComponentType,\r\n    hasComponent,\r\n    addComponentToEntity,\r\n    removeComponentFromEntity,\r\n    initializeComponentDefaults\r\n} from './component';\r\nimport { INDEX_MASK } from './constants';\r\nimport { toFixed, toFloat, fpMul, fpDiv, fpSqrt, FP_ONE } from '../math';\r\nimport { Transform2D, Body2D } from '../components';\r\n\r\n/**\r\n * Render-only state (client-only, never serialized).\r\n */\r\nexport interface RenderState {\r\n    /** Previous tick X position (for interpolation) */\r\n    prevX: number;\r\n    /** Previous tick Y position */\r\n    prevY: number;\r\n    /** Interpolated X (computed each render) */\r\n    interpX: number;\r\n    /** Interpolated Y */\r\n    interpY: number;\r\n    /** Screen X after camera transform */\r\n    screenX: number;\r\n    /** Screen Y after camera transform */\r\n    screenY: number;\r\n    /** Whether entity is visible */\r\n    visible: boolean;\r\n    /** Custom render properties */\r\n    [key: string]: any;\r\n}\r\n\r\n/**\r\n * Restore callback type - called after snapshot load to reconstruct derived fields.\r\n */\r\nexport type EntityRestoreCallback = (entity: Entity, game: any) => void;\r\n\r\n/**\r\n * Entity definition for spawning.\r\n */\r\nexport interface EntityDefinition {\r\n    name: string;\r\n    components: Array<{\r\n        type: ComponentType;\r\n        defaults?: Record<string, any>;\r\n    }>;\r\n    /** Optional: fields to sync in snapshots. If not set, all fields are synced. */\r\n    syncFields?: string[];\r\n    /** Optional: callback to reconstruct non-synced fields after snapshot load. */\r\n    onRestore?: EntityRestoreCallback;\r\n}\r\n\r\n/**\r\n * Entity wrapper - provides ergonomic access to SoA-stored entity data.\r\n */\r\nexport class Entity {\r\n    /** Entity ID (includes generation) */\r\n    eid: number = -1;\r\n\r\n    /** Entity type name */\r\n    type: string = '';\r\n\r\n    /** Whether entity is destroyed */\r\n    destroyed: boolean = false;\r\n\r\n    /** Render-only state (client-only, never serialized) */\r\n    render: RenderState = {\r\n        prevX: 0,\r\n        prevY: 0,\r\n        interpX: 0,\r\n        interpY: 0,\r\n        screenX: 0,\r\n        screenY: 0,\r\n        visible: true\r\n    };\r\n\r\n    /** Component types this entity has */\r\n    private _components: ComponentType[] = [];\r\n\r\n    /** Cached accessor instances */\r\n    private _accessors: Map<ComponentType, any> = new Map();\r\n\r\n    /** Reference to world for operations */\r\n    private _world: EntityWorld | null = null;\r\n\r\n    /** Current frame's input data (set during tick) */\r\n    private _inputData: Record<string, any> | null = null;\r\n\r\n    /**\r\n     * Get component accessor.\r\n     * Returns typed accessor for reading/writing component data.\r\n     */\r\n    get<T extends Record<string, any>>(component: ComponentType<T>): T {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        // Check if entity has this component\r\n        if (!hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} (type: ${this.type}) does not have component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Get or create accessor\r\n        let accessor = this._accessors.get(component);\r\n        if (!accessor) {\r\n            accessor = new component.AccessorClass(index);\r\n            this._accessors.set(component, accessor);\r\n        } else {\r\n            // Update index in case wrapper was reused\r\n            accessor._index = index;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Check if entity has a component.\r\n     */\r\n    has(component: ComponentType): boolean {\r\n        return hasComponent(component.storage, this.eid & INDEX_MASK);\r\n    }\r\n\r\n    /**\r\n     * Add a component to this entity at runtime.\r\n     */\r\n    addComponent<T extends Record<string, any>>(component: ComponentType<T>, data?: Partial<T>): T {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        if (hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} already has component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Add to storage\r\n        addComponentToEntity(component.storage, index);\r\n        initializeComponentDefaults(component.storage, index);\r\n\r\n        // Track component\r\n        this._components.push(component);\r\n\r\n        // Update query indices\r\n        if (this._world) {\r\n            this._world.queryEngine.addComponent(this.eid, component);\r\n        }\r\n\r\n        // Get accessor and apply data\r\n        const accessor = this.get(component);\r\n        if (data) {\r\n            for (const [key, value] of Object.entries(data)) {\r\n                (accessor as any)[key] = value;\r\n            }\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Remove a component from this entity at runtime.\r\n     */\r\n    removeComponent(component: ComponentType): void {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        if (!hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} does not have component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Remove from storage\r\n        removeComponentFromEntity(component.storage, index);\r\n\r\n        // Remove from tracking\r\n        const idx = this._components.indexOf(component);\r\n        if (idx !== -1) {\r\n            this._components.splice(idx, 1);\r\n        }\r\n\r\n        // Update query indices\r\n        if (this._world) {\r\n            this._world.queryEngine.removeComponent(this.eid, component);\r\n        }\r\n\r\n        // Clear cached accessor\r\n        this._accessors.delete(component);\r\n    }\r\n\r\n    /**\r\n     * Destroy this entity.\r\n     */\r\n    destroy(): void {\r\n        if (this.destroyed) return;\r\n        this.destroyed = true;\r\n\r\n        if (this._world) {\r\n            this._world.destroyEntity(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all components on this entity.\r\n     */\r\n    getComponents(): ComponentType[] {\r\n        return [...this._components];\r\n    }\r\n\r\n    /**\r\n     * Get current frame's input data.\r\n     * Returns null if no input was received this tick.\r\n     */\r\n    get input(): Record<string, any> | null {\r\n        return this._inputData;\r\n    }\r\n\r\n    /**\r\n     * Set input data for this tick (called by World).\r\n     */\r\n    _setInputData(data: Record<string, any> | null): void {\r\n        this._inputData = data;\r\n    }\r\n\r\n    /**\r\n     * Save current position to render.prev* for interpolation.\r\n     * Should be called in prePhysics phase before physics updates position.\r\n     */\r\n    _savePreviousState(): void {\r\n        // Look for common position components (Body2D, Transform, etc.)\r\n        // Store current position as previous for interpolation\r\n        for (const component of this._components) {\r\n            const index = this.eid & INDEX_MASK;\r\n\r\n            // Check for x/y fields in component\r\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\r\n                const xArr = component.storage.fields['x'];\r\n                const yArr = component.storage.fields['y'];\r\n\r\n                // Convert from fixed-point to float for render state\r\n                this.render.prevX = toFloat(xArr[index]);\r\n                this.render.prevY = toFloat(yArr[index]);\r\n                return; // Found position component, done\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate interpolated position for rendering.\r\n     * @param alpha Interpolation factor (0-1) between previous and current state\r\n     */\r\n    interpolate(alpha: number): void {\r\n        // Get current position\r\n        for (const component of this._components) {\r\n            const index = this.eid & INDEX_MASK;\r\n\r\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\r\n                const currentX = toFloat(component.storage.fields['x'][index]);\r\n                const currentY = toFloat(component.storage.fields['y'][index]);\r\n\r\n                // Linear interpolation between previous and current\r\n                this.render.interpX = this.render.prevX + (currentX - this.render.prevX) * alpha;\r\n                this.render.interpY = this.render.prevY + (currentY - this.render.prevY) * alpha;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize entity (called by world).\r\n     */\r\n    _init(\r\n        eid: number,\r\n        type: string,\r\n        components: ComponentType[],\r\n        world: EntityWorld\r\n    ): void {\r\n        this.eid = eid;\r\n        this.type = type;\r\n        this.destroyed = false;\r\n        this._components = components;\r\n        this._world = world;\r\n        this._accessors.clear();\r\n\r\n        // Reset render state\r\n        this.render.prevX = 0;\r\n        this.render.prevY = 0;\r\n        this.render.interpX = 0;\r\n        this.render.interpY = 0;\r\n        this.render.screenX = 0;\r\n        this.render.screenY = 0;\r\n        this.render.visible = true;\r\n\r\n        // Clear input data\r\n        this._inputData = null;\r\n    }\r\n\r\n    /**\r\n     * Clean up entity (called when returned to pool).\r\n     */\r\n    _cleanup(): void {\r\n        this._world = null;\r\n        this._components = [];\r\n        this._accessors.clear();\r\n        this._inputData = null;\r\n    }\r\n\r\n    // ==========================================\r\n    // Movement Helpers (Deterministic)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Set velocity toward a target point.\r\n     * Uses fixed-point math internally for determinism.\r\n     *\r\n     * @param target Target position {x, y}\r\n     * @param speed Speed in units per second\r\n     */\r\n    moveTowards(target: { x: number; y: number }, speed: number): void {\r\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const body = this.get(Body2D);\r\n\r\n        // All math in fixed-point for determinism\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n\r\n        // Distance squared (avoid sqrt if possible)\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        if (distSq === 0) {\r\n            body.vx = 0;\r\n            body.vy = 0;\r\n            return;\r\n        }\r\n\r\n        // Distance\r\n        const dist = fpSqrt(distSq);\r\n\r\n        // Normalize and scale by speed (speed is in units/sec, physics expects units/sec)\r\n        const speedFp = toFixed(speed * 60); // Convert to units per tick at 60fps base\r\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\r\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\r\n    }\r\n\r\n    /**\r\n     * Set velocity toward a target, but stop if within radius.\r\n     *\r\n     * @param target Target position {x, y}\r\n     * @param speed Speed in units per second\r\n     * @param stopRadius Stop moving when within this distance (default: 0)\r\n     */\r\n    moveTowardsWithStop(target: { x: number; y: number }, speed: number, stopRadius: number = 0): void {\r\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const body = this.get(Body2D);\r\n\r\n        // All math in fixed-point for determinism\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        const stopRadiusFp = toFixed(stopRadius);\r\n        const stopRadiusSq = fpMul(stopRadiusFp, stopRadiusFp);\r\n\r\n        // Stop if within radius\r\n        if (distSq <= stopRadiusSq) {\r\n            body.vx = 0;\r\n            body.vy = 0;\r\n            return;\r\n        }\r\n\r\n        const dist = fpSqrt(distSq);\r\n        const speedFp = toFixed(speed * 60);\r\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\r\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\r\n    }\r\n\r\n    /**\r\n     * Stop all movement.\r\n     */\r\n    stop(): void {\r\n        if (!this.has(Body2D)) return;\r\n        const body = this.get(Body2D);\r\n        body.vx = 0;\r\n        body.vy = 0;\r\n    }\r\n\r\n    /**\r\n     * Set velocity directly.\r\n     *\r\n     * @param vx X velocity\r\n     * @param vy Y velocity\r\n     */\r\n    setVelocity(vx: number, vy: number): void {\r\n        if (!this.has(Body2D)) return;\r\n        const body = this.get(Body2D);\r\n        body.vx = vx;\r\n        body.vy = vy;\r\n    }\r\n\r\n    /**\r\n     * Get distance to a point (deterministic).\r\n     */\r\n    distanceTo(target: { x: number; y: number }): number {\r\n        if (!this.has(Transform2D)) return 0;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n\r\n        return toFloat(fpSqrt(distSq));\r\n    }\r\n\r\n    /**\r\n     * Check if within distance of a point (deterministic).\r\n     */\r\n    isWithin(target: { x: number; y: number }, distance: number): boolean {\r\n        if (!this.has(Transform2D)) return false;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        const distFp = toFixed(distance);\r\n        const distSqThreshold = fpMul(distFp, distFp);\r\n\r\n        return distSq <= distSqThreshold;\r\n    }\r\n}\r\n\r\n/**\r\n * Forward declaration for EntityWorld (actual implementation in world.ts).\r\n */\r\nexport interface EntityWorld {\r\n    queryEngine: {\r\n        addComponent(eid: number, component: ComponentType): void;\r\n        removeComponent(eid: number, component: ComponentType): void;\r\n    };\r\n    destroyEntity(entity: Entity): void;\r\n}\r\n\r\n/**\r\n * Entity pool for reusing entity wrappers.\r\n */\r\nexport class EntityPool {\r\n    private pool: Entity[] = [];\r\n    private active: Map<number, Entity> = new Map();\r\n\r\n    /**\r\n     * Get or create an entity wrapper.\r\n     */\r\n    acquire(eid: number): Entity {\r\n        // Check if already have wrapper for this eid\r\n        let entity = this.active.get(eid);\r\n        if (entity) {\r\n            return entity;\r\n        }\r\n\r\n        // Get from pool or create new\r\n        entity = this.pool.pop() || new Entity();\r\n        this.active.set(eid, entity);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Return entity wrapper to pool.\r\n     */\r\n    release(eid: number): void {\r\n        const entity = this.active.get(eid);\r\n        if (entity) {\r\n            entity._cleanup();\r\n            this.active.delete(eid);\r\n            this.pool.push(entity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get entity by eid if it exists.\r\n     */\r\n    get(eid: number): Entity | undefined {\r\n        return this.active.get(eid);\r\n    }\r\n\r\n    /**\r\n     * Check if entity exists.\r\n     */\r\n    has(eid: number): boolean {\r\n        return this.active.has(eid);\r\n    }\r\n\r\n    /**\r\n     * Clear all entities.\r\n     */\r\n    clear(): void {\r\n        for (const entity of this.active.values()) {\r\n            entity._cleanup();\r\n            this.pool.push(entity);\r\n        }\r\n        this.active.clear();\r\n    }\r\n\r\n    /**\r\n     * Get count of active entities.\r\n     */\r\n    get size(): number {\r\n        return this.active.size;\r\n    }\r\n}\r\n", "/**\r\n * Query Engine\r\n *\r\n * Efficient entity queries with caching and iterator support.\r\n * Queries return iterators with snapshot semantics for safe mutation.\r\n */\r\n\r\nimport { ComponentType, hasComponent } from './component';\r\nimport { INDEX_MASK } from './constants';\r\n\r\n/**\r\n * Entity-like interface for query results.\r\n * Actual Entity class will implement this.\r\n */\r\nexport interface QueryableEntity {\r\n    readonly eid: number;\r\n    readonly type: string;\r\n    readonly destroyed: boolean;\r\n}\r\n\r\n/**\r\n * Function to get entity wrapper by eid.\r\n */\r\nexport type EntityGetter = (eid: number) => QueryableEntity | null;\r\n\r\n/**\r\n * Function to check if entity is destroyed.\r\n */\r\nexport type DestroyedChecker = (eid: number) => boolean;\r\n\r\n/**\r\n * Query iterator with snapshot semantics.\r\n * Captures eid list at creation time for safe iteration during mutation.\r\n */\r\nexport class QueryIterator<T extends QueryableEntity> implements Iterable<T> {\r\n    private eids: number[];\r\n    private index: number = 0;\r\n    private getEntity: EntityGetter;\r\n    private isDestroyed: DestroyedChecker;\r\n\r\n    constructor(\r\n        matchingEids: number[],\r\n        getEntity: EntityGetter,\r\n        isDestroyed: DestroyedChecker\r\n    ) {\r\n        // Copy eids at creation time - safe from mutation\r\n        this.eids = matchingEids.slice();\r\n        this.getEntity = getEntity;\r\n        this.isDestroyed = isDestroyed;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<T> {\r\n        this.index = 0;\r\n        return {\r\n            next: (): IteratorResult<T> => {\r\n                while (this.index < this.eids.length) {\r\n                    const eid = this.eids[this.index++];\r\n\r\n                    // Skip destroyed entities\r\n                    if (this.isDestroyed(eid)) continue;\r\n\r\n                    const entity = this.getEntity(eid);\r\n                    if (entity) {\r\n                        return { done: false, value: entity as T };\r\n                    }\r\n                }\r\n                return { done: true, value: undefined as any };\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert to array (allocates).\r\n     */\r\n    toArray(): T[] {\r\n        const result: T[] = [];\r\n        for (const entity of this) {\r\n            result.push(entity);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get first matching entity.\r\n     */\r\n    first(): T | null {\r\n        for (const entity of this) {\r\n            return entity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find entity matching predicate.\r\n     */\r\n    find(predicate: (entity: T) => boolean): T | null {\r\n        for (const entity of this) {\r\n            if (predicate(entity)) {\r\n                return entity;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Count entities without allocating array.\r\n     */\r\n    count(): number {\r\n        let count = 0;\r\n        for (const _ of this) {\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n/**\r\n * Query engine - manages entity indices and cached queries.\r\n */\r\nexport class QueryEngine {\r\n    /** Type index: entity type -> set of eids */\r\n    private typeIndex: Map<string, Set<number>> = new Map();\r\n\r\n    /** Component index: component -> set of eids */\r\n    private componentIndex: Map<ComponentType, Set<number>> = new Map();\r\n\r\n    /** Client ID index: clientId -> eid (O(1) lookup) */\r\n    private clientIdIndex: Map<number, number> = new Map();\r\n\r\n    /** Entity getter function */\r\n    private getEntity: EntityGetter;\r\n\r\n    /** Destroyed checker function */\r\n    private isDestroyed: DestroyedChecker;\r\n\r\n    constructor(getEntity: EntityGetter, isDestroyed: DestroyedChecker) {\r\n        this.getEntity = getEntity;\r\n        this.isDestroyed = isDestroyed;\r\n    }\r\n\r\n    /**\r\n     * Register an entity in the indices.\r\n     */\r\n    addEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\r\n        // Add to type index\r\n        let typeSet = this.typeIndex.get(type);\r\n        if (!typeSet) {\r\n            typeSet = new Set();\r\n            this.typeIndex.set(type, typeSet);\r\n        }\r\n        typeSet.add(eid);\r\n\r\n        // Add to component indices\r\n        for (const component of components) {\r\n            let compSet = this.componentIndex.get(component);\r\n            if (!compSet) {\r\n                compSet = new Set();\r\n                this.componentIndex.set(component, compSet);\r\n            }\r\n            compSet.add(eid);\r\n        }\r\n\r\n        // Add to clientId index if provided\r\n        if (clientId !== undefined) {\r\n            this.clientIdIndex.set(clientId, eid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an entity from all indices.\r\n     */\r\n    removeEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\r\n        // Remove from type index\r\n        this.typeIndex.get(type)?.delete(eid);\r\n\r\n        // Remove from component indices\r\n        for (const component of components) {\r\n            this.componentIndex.get(component)?.delete(eid);\r\n        }\r\n\r\n        // Remove from clientId index\r\n        if (clientId !== undefined) {\r\n            this.clientIdIndex.delete(clientId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add component to an existing entity.\r\n     */\r\n    addComponent(eid: number, component: ComponentType): void {\r\n        let compSet = this.componentIndex.get(component);\r\n        if (!compSet) {\r\n            compSet = new Set();\r\n            this.componentIndex.set(component, compSet);\r\n        }\r\n        compSet.add(eid);\r\n    }\r\n\r\n    /**\r\n     * Remove component from an existing entity.\r\n     */\r\n    removeComponent(eid: number, component: ComponentType): void {\r\n        this.componentIndex.get(component)?.delete(eid);\r\n    }\r\n\r\n    /**\r\n     * Update clientId mapping for an entity.\r\n     */\r\n    setClientId(eid: number, clientId: number): void {\r\n        this.clientIdIndex.set(clientId, eid);\r\n    }\r\n\r\n    /**\r\n     * Remove clientId mapping.\r\n     */\r\n    removeClientId(clientId: number): void {\r\n        this.clientIdIndex.delete(clientId);\r\n    }\r\n\r\n    /**\r\n     * Query by entity type.\r\n     */\r\n    byType<T extends QueryableEntity>(type: string): QueryIterator<T> {\r\n        const typeSet = this.typeIndex.get(type);\r\n        const eids = typeSet ? this.sortedEids(typeSet) : [];\r\n        return new QueryIterator<T>(eids, this.getEntity, this.isDestroyed);\r\n    }\r\n\r\n    /**\r\n     * Query by component(s) - entities must have ALL specified components.\r\n     */\r\n    byComponents<T extends QueryableEntity>(...components: ComponentType[]): QueryIterator<T> {\r\n        if (components.length === 0) {\r\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n        }\r\n\r\n        // Start with the smallest set for efficiency\r\n        let smallestSet: Set<number> | undefined;\r\n        let smallestSize = Infinity;\r\n\r\n        for (const component of components) {\r\n            const compSet = this.componentIndex.get(component);\r\n            if (!compSet || compSet.size === 0) {\r\n                // One component has no entities, result is empty\r\n                return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n            }\r\n            if (compSet.size < smallestSize) {\r\n                smallestSize = compSet.size;\r\n                smallestSet = compSet;\r\n            }\r\n        }\r\n\r\n        if (!smallestSet) {\r\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n        }\r\n\r\n        // Filter to entities that have ALL components\r\n        const result: number[] = [];\r\n        for (const eid of smallestSet) {\r\n            let hasAll = true;\r\n            for (const component of components) {\r\n                if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\r\n                    hasAll = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (hasAll) {\r\n                result.push(eid);\r\n            }\r\n        }\r\n\r\n        // Sort by eid for deterministic order\r\n        result.sort((a, b) => a - b);\r\n\r\n        return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\r\n    }\r\n\r\n    /**\r\n     * Query by type or component.\r\n     */\r\n    query<T extends QueryableEntity>(\r\n        typeOrComponent: string | ComponentType,\r\n        ...moreComponents: ComponentType[]\r\n    ): QueryIterator<T> {\r\n        if (typeof typeOrComponent === 'string') {\r\n            // Query by type\r\n            if (moreComponents.length > 0) {\r\n                // Type + components: filter type results by components\r\n                const typeSet = this.typeIndex.get(typeOrComponent);\r\n                if (!typeSet || typeSet.size === 0) {\r\n                    return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n                }\r\n\r\n                const result: number[] = [];\r\n                for (const eid of typeSet) {\r\n                    let hasAll = true;\r\n                    for (const component of moreComponents) {\r\n                        if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\r\n                            hasAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (hasAll) {\r\n                        result.push(eid);\r\n                    }\r\n                }\r\n\r\n                result.sort((a, b) => a - b);\r\n                return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\r\n            }\r\n\r\n            return this.byType<T>(typeOrComponent);\r\n        }\r\n\r\n        // Query by component(s)\r\n        return this.byComponents<T>(typeOrComponent, ...moreComponents);\r\n    }\r\n\r\n    /**\r\n     * O(1) lookup by clientId.\r\n     */\r\n    getByClientId(clientId: number): number | undefined {\r\n        return this.clientIdIndex.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Get all entity IDs (sorted for determinism).\r\n     */\r\n    getAllEids(): number[] {\r\n        const allEids = new Set<number>();\r\n\r\n        for (const typeSet of this.typeIndex.values()) {\r\n            for (const eid of typeSet) {\r\n                allEids.add(eid);\r\n            }\r\n        }\r\n\r\n        return Array.from(allEids).sort((a, b) => a - b);\r\n    }\r\n\r\n    /**\r\n     * Clear all indices (for reset).\r\n     */\r\n    clear(): void {\r\n        this.typeIndex.clear();\r\n        this.componentIndex.clear();\r\n        this.clientIdIndex.clear();\r\n    }\r\n\r\n    /**\r\n     * Get sorted eids from a set (for deterministic iteration).\r\n     */\r\n    private sortedEids(set: Set<number>): number[] {\r\n        return Array.from(set).sort((a, b) => a - b);\r\n    }\r\n}\r\n", "/**\r\n * System Scheduler\r\n *\r\n * Manages system registration and execution in ordered phases.\r\n * Systems are functions that operate on entities with specific components.\r\n */\r\n\r\nimport { SystemPhase, SYSTEM_PHASES } from './constants';\r\n\r\nexport interface SystemOptions {\r\n    /** Execution phase (default: 'update') */\r\n    phase?: SystemPhase;\r\n\r\n    /** Only run on client (e.g., rendering) */\r\n    client?: boolean;\r\n\r\n    /** Only run on server */\r\n    server?: boolean;\r\n\r\n    /** Execution order within phase (lower = earlier) */\r\n    order?: number;\r\n}\r\n\r\nexport type SystemFn = () => void;\r\n\r\ninterface SystemEntry {\r\n    fn: SystemFn;\r\n    options: SystemOptions;\r\n    order: number;\r\n}\r\n\r\n/**\r\n * System scheduler - manages system registration and execution.\r\n */\r\nexport class SystemScheduler {\r\n    /** Systems organized by phase */\r\n    private systems: Map<SystemPhase, SystemEntry[]> = new Map();\r\n\r\n    /** Whether we're running on client or server */\r\n    private isClient: boolean = true;\r\n\r\n    /** System ID counter for ordering */\r\n    private nextSystemId: number = 0;\r\n\r\n    constructor() {\r\n        // Initialize all phases\r\n        for (const phase of SYSTEM_PHASES) {\r\n            this.systems.set(phase, []);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set whether this scheduler is running on client or server.\r\n     */\r\n    setIsClient(isClient: boolean): void {\r\n        this.isClient = isClient;\r\n    }\r\n\r\n    /**\r\n     * Add a system to the scheduler.\r\n     *\r\n     * @param fn System function to execute\r\n     * @param options System options (phase, client/server, order)\r\n     * @returns Function to remove the system\r\n     */\r\n    add(fn: SystemFn, options: SystemOptions = {}): () => void {\r\n        const phase = options.phase || 'update';\r\n        const systems = this.systems.get(phase);\r\n\r\n        if (!systems) {\r\n            throw new Error(`Unknown system phase: ${phase}`);\r\n        }\r\n\r\n        const entry: SystemEntry = {\r\n            fn,\r\n            options,\r\n            order: options.order ?? this.nextSystemId++\r\n        };\r\n\r\n        systems.push(entry);\r\n\r\n        // Sort by order\r\n        systems.sort((a, b) => a.order - b.order);\r\n\r\n        // Return removal function\r\n        return () => this.remove(fn);\r\n    }\r\n\r\n    /**\r\n     * Remove a system from the scheduler.\r\n     */\r\n    remove(fn: SystemFn): boolean {\r\n        for (const systems of this.systems.values()) {\r\n            const index = systems.findIndex(s => s.fn === fn);\r\n            if (index !== -1) {\r\n                systems.splice(index, 1);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Run all systems in a specific phase.\r\n     */\r\n    runPhase(phase: SystemPhase): void {\r\n        const systems = this.systems.get(phase);\r\n        if (!systems) return;\r\n\r\n        for (const system of systems) {\r\n            // Skip client-only systems on server\r\n            if (system.options.client && !this.isClient) continue;\r\n\r\n            // Skip server-only systems on client\r\n            if (system.options.server && this.isClient) continue;\r\n\r\n            // Execute system\r\n            try {\r\n                const result = system.fn() as unknown;\r\n\r\n                // Check for accidental async systems\r\n                if (result && typeof result === 'object' && 'then' in result) {\r\n                    throw new Error(\r\n                        `System returned a Promise. Async systems are not allowed ` +\r\n                        `as they break determinism. Remove 'await' from your system.`\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                console.error(`Error in system during '${phase}' phase:`, error);\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run all phases in order (except render if not client).\r\n     */\r\n    runAll(): void {\r\n        for (const phase of SYSTEM_PHASES) {\r\n            // Skip render phase on server\r\n            if (phase === 'render' && !this.isClient) continue;\r\n\r\n            this.runPhase(phase);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get count of systems in each phase (for debugging).\r\n     */\r\n    getSystemCounts(): Record<SystemPhase, number> {\r\n        const counts: Partial<Record<SystemPhase, number>> = {};\r\n        for (const [phase, systems] of this.systems) {\r\n            counts[phase] = systems.length;\r\n        }\r\n        return counts as Record<SystemPhase, number>;\r\n    }\r\n\r\n    /**\r\n     * Clear all systems (for testing).\r\n     */\r\n    clear(): void {\r\n        for (const systems of this.systems.values()) {\r\n            systems.length = 0;\r\n        }\r\n        this.nextSystemId = 0;\r\n    }\r\n}\r\n", "/**\r\n * Sparse Snapshot System\r\n *\r\n * Efficient snapshot encoding using entity bitmaps.\r\n * Only active entities are stored, not MAX_ENTITIES slots.\r\n */\r\n\r\nimport { MAX_ENTITIES, INDEX_MASK } from './constants';\r\nimport { ComponentType, getAllComponents } from './component';\r\nimport { EntityIdAllocatorState } from './entity-id';\r\n\r\n/**\r\n * Sparse snapshot format.\r\n * Much smaller than full snapshot when entity count << MAX_ENTITIES.\r\n */\r\nexport interface SparseSnapshot {\r\n    /** Frame number */\r\n    frame: number;\r\n\r\n    /** Sequence number (for network ordering) */\r\n    seq: number;\r\n\r\n    /** Bitmap: which entity indices are active */\r\n    entityMask: Uint32Array;\r\n\r\n    /** Entity metadata (type, clientId) indexed by position in packed arrays */\r\n    entityMeta: EntityMeta[];\r\n\r\n    /** Packed component data for each component type */\r\n    componentData: Map<string, ArrayBuffer>;\r\n\r\n    /** Entity count (for quick reference) */\r\n    entityCount: number;\r\n\r\n    /** Allocator state for deterministic ID recycling */\r\n    allocator: EntityIdAllocatorState;\r\n\r\n    /** String registry for late joiners */\r\n    strings: {\r\n        tables: Record<string, Record<string, number>>;\r\n        nextIds: Record<string, number>;\r\n    };\r\n\r\n    /** RNG state */\r\n    rng?: { s0: number; s1: number };\r\n}\r\n\r\n/**\r\n * Entity metadata stored per-entity in snapshot.\r\n */\r\nexport interface EntityMeta {\r\n    eid: number;\r\n    type: string;\r\n    clientId?: number;\r\n}\r\n\r\n/**\r\n * Sparse snapshot encoder/decoder.\r\n */\r\nexport class SparseSnapshotCodec {\r\n    /**\r\n     * Encode world state to sparse snapshot.\r\n     */\r\n    encode(\r\n        activeEids: number[],\r\n        getEntityType: (eid: number) => string,\r\n        getEntityClientId: (eid: number) => number | undefined,\r\n        getComponentsForEntity: (eid: number) => ComponentType[],\r\n        allocatorState: EntityIdAllocatorState,\r\n        stringsState: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> },\r\n        frame: number = 0,\r\n        seq: number = 0,\r\n        rng?: { s0: number; s1: number }\r\n    ): SparseSnapshot {\r\n        // Build entity bitmap\r\n        const entityMask = new Uint32Array(Math.ceil(MAX_ENTITIES / 32));\r\n        const entityMeta: EntityMeta[] = [];\r\n\r\n        // Sort eids for deterministic order\r\n        const sortedEids = [...activeEids].sort((a, b) => a - b);\r\n\r\n        for (const eid of sortedEids) {\r\n            const index = eid & INDEX_MASK;\r\n            entityMask[index >>> 5] |= (1 << (index & 31));\r\n\r\n            entityMeta.push({\r\n                eid,\r\n                type: getEntityType(eid),\r\n                clientId: getEntityClientId(eid)\r\n            });\r\n        }\r\n\r\n        // Pack component data\r\n        const componentData = new Map<string, ArrayBuffer>();\r\n        const allComponents = getAllComponents();\r\n\r\n        for (const [name, component] of allComponents) {\r\n            // Skip components that are not synced (client-only state)\r\n            if (!component.sync) continue;\r\n\r\n            const fieldCount = component.fieldNames.length;\r\n            if (fieldCount === 0) continue;\r\n\r\n            // Calculate buffer size\r\n            let totalSize = 0;\r\n            for (const fieldName of component.fieldNames) {\r\n                const arr = component.storage.fields[fieldName];\r\n                totalSize += sortedEids.length * arr.BYTES_PER_ELEMENT;\r\n            }\r\n\r\n            const buffer = new ArrayBuffer(totalSize);\r\n            let offset = 0;\r\n\r\n            // Pack each field's data for active entities only\r\n            for (const fieldName of component.fieldNames) {\r\n                const sourceArr = component.storage.fields[fieldName];\r\n                const bytesPerElement = sourceArr.BYTES_PER_ELEMENT;\r\n\r\n                // Create view into packed buffer\r\n                const packedArr = new (sourceArr.constructor as any)(\r\n                    buffer,\r\n                    offset,\r\n                    sortedEids.length\r\n                );\r\n\r\n                // Copy only active entity data\r\n                for (let i = 0; i < sortedEids.length; i++) {\r\n                    const index = sortedEids[i] & INDEX_MASK;\r\n                    packedArr[i] = sourceArr[index];\r\n                }\r\n\r\n                offset += sortedEids.length * bytesPerElement;\r\n            }\r\n\r\n            componentData.set(name, buffer);\r\n        }\r\n\r\n        return {\r\n            frame,\r\n            seq,\r\n            entityMask,\r\n            entityMeta,\r\n            componentData,\r\n            entityCount: sortedEids.length,\r\n            allocator: allocatorState,\r\n            strings: stringsState,\r\n            rng\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decode sparse snapshot back to world state.\r\n     */\r\n    decode(\r\n        snapshot: SparseSnapshot,\r\n        clearWorld: () => void,\r\n        setAllocatorState: (state: EntityIdAllocatorState) => void,\r\n        setStringsState: (state: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> }) => void,\r\n        createEntity: (eid: number, type: string, clientId?: number) => void,\r\n        setRng?: (rng: { s0: number; s1: number }) => void\r\n    ): void {\r\n        // Clear existing state\r\n        clearWorld();\r\n\r\n        // Restore allocator state\r\n        setAllocatorState(snapshot.allocator);\r\n\r\n        // Restore strings\r\n        setStringsState(snapshot.strings);\r\n\r\n        // Restore RNG if provided\r\n        if (snapshot.rng && setRng) {\r\n            setRng(snapshot.rng);\r\n        }\r\n\r\n        // Get component types\r\n        const allComponents = getAllComponents();\r\n\r\n        // Unpack entities from metadata\r\n        for (let i = 0; i < snapshot.entityMeta.length; i++) {\r\n            const meta = snapshot.entityMeta[i];\r\n            createEntity(meta.eid, meta.type, meta.clientId);\r\n        }\r\n\r\n        // Unpack component data\r\n        for (const [name, buffer] of snapshot.componentData) {\r\n            const component = allComponents.get(name);\r\n            if (!component) continue;\r\n\r\n            let offset = 0;\r\n\r\n            for (const fieldName of component.fieldNames) {\r\n                const targetArr = component.storage.fields[fieldName];\r\n                const bytesPerElement = targetArr.BYTES_PER_ELEMENT;\r\n\r\n                // Create view into packed buffer\r\n                const packedArr = new (targetArr.constructor as any)(\r\n                    buffer,\r\n                    offset,\r\n                    snapshot.entityCount\r\n                );\r\n\r\n                // Unpack to entity indices\r\n                for (let i = 0; i < snapshot.entityMeta.length; i++) {\r\n                    const index = snapshot.entityMeta[i].eid & INDEX_MASK;\r\n                    targetArr[index] = packedArr[i];\r\n                }\r\n\r\n                offset += snapshot.entityCount * bytesPerElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate snapshot size in bytes.\r\n     */\r\n    getSize(snapshot: SparseSnapshot): number {\r\n        let size = 0;\r\n\r\n        // Entity mask\r\n        size += snapshot.entityMask.byteLength;\r\n\r\n        // Entity metadata (rough estimate)\r\n        size += snapshot.entityMeta.length * 32; // ~32 bytes per entity meta\r\n\r\n        // Component data\r\n        for (const buffer of snapshot.componentData.values()) {\r\n            size += buffer.byteLength;\r\n        }\r\n\r\n        // Allocator state\r\n        size += snapshot.allocator.freeList.length * 4;\r\n        size += snapshot.allocator.generations.length * 2;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Serialize snapshot to binary for network transfer.\r\n     */\r\n    toBinary(snapshot: SparseSnapshot): ArrayBuffer {\r\n        // Calculate total size\r\n        const metaJson = JSON.stringify({\r\n            frame: snapshot.frame,\r\n            seq: snapshot.seq,\r\n            entityMeta: snapshot.entityMeta,\r\n            allocator: snapshot.allocator,\r\n            strings: snapshot.strings,\r\n            rng: snapshot.rng,\r\n            componentNames: Array.from(snapshot.componentData.keys())\r\n        });\r\n\r\n        const metaBytes = new TextEncoder().encode(metaJson);\r\n        const metaLength = metaBytes.length;\r\n\r\n        // Calculate component data size\r\n        let componentDataSize = 0;\r\n        const componentSizes: number[] = [];\r\n        for (const buffer of snapshot.componentData.values()) {\r\n            componentSizes.push(buffer.byteLength);\r\n            componentDataSize += buffer.byteLength;\r\n        }\r\n\r\n        // Total: 4 (meta length) + meta + 4 (mask length) + mask + component data\r\n        const totalSize = 4 + metaLength + 4 + snapshot.entityMask.byteLength + componentDataSize;\r\n\r\n        const buffer = new ArrayBuffer(totalSize);\r\n        const view = new DataView(buffer);\r\n        let offset = 0;\r\n\r\n        // Write meta length and data\r\n        view.setUint32(offset, metaLength, true);\r\n        offset += 4;\r\n        new Uint8Array(buffer, offset, metaLength).set(metaBytes);\r\n        offset += metaLength;\r\n\r\n        // Write entity mask\r\n        view.setUint32(offset, snapshot.entityMask.byteLength, true);\r\n        offset += 4;\r\n        new Uint8Array(buffer, offset, snapshot.entityMask.byteLength).set(\r\n            new Uint8Array(snapshot.entityMask.buffer)\r\n        );\r\n        offset += snapshot.entityMask.byteLength;\r\n\r\n        // Write component data\r\n        for (const compBuffer of snapshot.componentData.values()) {\r\n            new Uint8Array(buffer, offset, compBuffer.byteLength).set(\r\n                new Uint8Array(compBuffer)\r\n            );\r\n            offset += compBuffer.byteLength;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Deserialize snapshot from binary.\r\n     */\r\n    fromBinary(buffer: ArrayBuffer): SparseSnapshot {\r\n        const view = new DataView(buffer);\r\n        let offset = 0;\r\n\r\n        // Read meta\r\n        const metaLength = view.getUint32(offset, true);\r\n        offset += 4;\r\n        const metaBytes = new Uint8Array(buffer, offset, metaLength);\r\n        const metaJson = new TextDecoder().decode(metaBytes);\r\n        const meta = JSON.parse(metaJson);\r\n        offset += metaLength;\r\n\r\n        // Read entity mask\r\n        const maskLength = view.getUint32(offset, true);\r\n        offset += 4;\r\n        const entityMask = new Uint32Array(\r\n            buffer.slice(offset, offset + maskLength)\r\n        );\r\n        offset += maskLength;\r\n\r\n        // Read component data\r\n        const componentData = new Map<string, ArrayBuffer>();\r\n        const allComponents = getAllComponents();\r\n\r\n        for (const name of meta.componentNames) {\r\n            const component = allComponents.get(name);\r\n            if (!component) continue;\r\n\r\n            // Calculate size for this component\r\n            let compSize = 0;\r\n            for (const fieldName of component.fieldNames) {\r\n                const arr = component.storage.fields[fieldName];\r\n                compSize += meta.entityMeta.length * arr.BYTES_PER_ELEMENT;\r\n            }\r\n\r\n            const compBuffer = buffer.slice(offset, offset + compSize);\r\n            componentData.set(name, compBuffer);\r\n            offset += compSize;\r\n        }\r\n\r\n        return {\r\n            frame: meta.frame,\r\n            seq: meta.seq,\r\n            entityMask,\r\n            entityMeta: meta.entityMeta,\r\n            componentData,\r\n            entityCount: meta.entityMeta.length,\r\n            allocator: meta.allocator,\r\n            strings: meta.strings,\r\n            rng: meta.rng\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Rollback buffer - stores snapshots for rewinding state.\r\n */\r\nexport class RollbackBuffer {\r\n    private snapshots: Map<number, SparseSnapshot> = new Map();\r\n    private codec: SparseSnapshotCodec = new SparseSnapshotCodec();\r\n\r\n    constructor(private maxFrames: number = 60) {}\r\n\r\n    /**\r\n     * Save a snapshot for a frame.\r\n     */\r\n    save(frame: number, snapshot: SparseSnapshot): void {\r\n        this.snapshots.set(frame, snapshot);\r\n\r\n        // Prune old snapshots (keep exactly maxFrames snapshots)\r\n        const minFrame = frame - this.maxFrames + 1;\r\n        for (const f of this.snapshots.keys()) {\r\n            if (f < minFrame) {\r\n                this.snapshots.delete(f);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get snapshot for a frame.\r\n     */\r\n    get(frame: number): SparseSnapshot | undefined {\r\n        return this.snapshots.get(frame);\r\n    }\r\n\r\n    /**\r\n     * Check if snapshot exists for frame.\r\n     */\r\n    has(frame: number): boolean {\r\n        return this.snapshots.has(frame);\r\n    }\r\n\r\n    /**\r\n     * Get oldest available frame.\r\n     */\r\n    getOldestFrame(): number | undefined {\r\n        let oldest: number | undefined;\r\n        for (const frame of this.snapshots.keys()) {\r\n            if (oldest === undefined || frame < oldest) {\r\n                oldest = frame;\r\n            }\r\n        }\r\n        return oldest;\r\n    }\r\n\r\n    /**\r\n     * Get newest available frame.\r\n     */\r\n    getNewestFrame(): number | undefined {\r\n        let newest: number | undefined;\r\n        for (const frame of this.snapshots.keys()) {\r\n            if (newest === undefined || frame > newest) {\r\n                newest = frame;\r\n            }\r\n        }\r\n        return newest;\r\n    }\r\n\r\n    /**\r\n     * Clear all snapshots.\r\n     */\r\n    clear(): void {\r\n        this.snapshots.clear();\r\n    }\r\n\r\n    /**\r\n     * Get number of stored snapshots.\r\n     */\r\n    get size(): number {\r\n        return this.snapshots.size;\r\n    }\r\n}\r\n", "/**\r\n * String Registry - Deterministic string interning\r\n *\r\n * Converts strings to integer IDs for efficient storage and comparison.\r\n * Used for entity types, colors, sprite IDs, etc.\r\n *\r\n * DETERMINISM: ID allocation order must be identical across all clients.\r\n * Strings are assigned IDs in order of first intern() call.\r\n */\r\n\r\nexport interface StringRegistryState {\r\n    tables: Record<string, Record<string, number>>;\r\n    nextIds: Record<string, number>;\r\n}\r\n\r\n/**\r\n * String registry for interning strings.\r\n *\r\n * Provides bidirectional mapping between strings and integer IDs,\r\n * organized by namespace (e.g., 'color', 'sprite', 'entityType').\r\n */\r\nexport class StringRegistry {\r\n    private stringToId: Map<string, Map<string, number>> = new Map();\r\n    private idToString: Map<string, Map<number, string>> = new Map();\r\n    private nextId: Map<string, number> = new Map();\r\n\r\n    /**\r\n     * Intern a string, get back an integer ID.\r\n     * If the string was already interned, returns the existing ID.\r\n     *\r\n     * @param namespace - Category for the string (e.g., 'color', 'sprite')\r\n     * @param str - The string to intern\r\n     * @returns Integer ID for the string\r\n     */\r\n    intern(namespace: string, str: string): number {\r\n        let nsMap = this.stringToId.get(namespace);\r\n        if (!nsMap) {\r\n            nsMap = new Map();\r\n            this.stringToId.set(namespace, nsMap);\r\n        }\r\n\r\n        const existing = nsMap.get(str);\r\n        if (existing !== undefined) return existing;\r\n\r\n        const id = this.nextId.get(namespace) ?? 1;\r\n        this.nextId.set(namespace, id + 1);\r\n\r\n        nsMap.set(str, id);\r\n\r\n        let idMap = this.idToString.get(namespace);\r\n        if (!idMap) {\r\n            idMap = new Map();\r\n            this.idToString.set(namespace, idMap);\r\n        }\r\n        idMap.set(id, str);\r\n\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Look up string by ID.\r\n     *\r\n     * @param namespace - Category for the string\r\n     * @param id - Integer ID to look up\r\n     * @returns The original string, or null if not found\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.idToString.get(namespace)?.get(id) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Get state for snapshotting.\r\n     * Returns a serializable representation of all interned strings.\r\n     */\r\n    getState(): StringRegistryState {\r\n        const tables: Record<string, Record<string, number>> = {};\r\n        const nextIds: Record<string, number> = {};\r\n\r\n        for (const [ns, nsMap] of this.stringToId) {\r\n            tables[ns] = Object.fromEntries(nsMap);\r\n            nextIds[ns] = this.nextId.get(ns) ?? 1;\r\n        }\r\n\r\n        return { tables, nextIds };\r\n    }\r\n\r\n    /**\r\n     * Restore state from snapshot.\r\n     * Replaces all current data with the snapshot state.\r\n     */\r\n    setState(state: StringRegistryState): void {\r\n        this.stringToId.clear();\r\n        this.idToString.clear();\r\n        this.nextId.clear();\r\n\r\n        for (const [ns, table] of Object.entries(state.tables)) {\r\n            const nsMap = new Map(Object.entries(table));\r\n            this.stringToId.set(ns, nsMap);\r\n\r\n            const idMap = new Map<number, string>();\r\n            for (const [str, id] of nsMap) {\r\n                idMap.set(id, str);\r\n            }\r\n            this.idToString.set(ns, idMap);\r\n\r\n            this.nextId.set(ns, state.nextIds[ns] ?? 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all data.\r\n     */\r\n    clear(): void {\r\n        this.stringToId.clear();\r\n        this.idToString.clear();\r\n        this.nextId.clear();\r\n    }\r\n}\r\n", "/**\r\n * InputHistory - Stores confirmed server inputs for rollback resimulation\r\n *\r\n * This class is CRITICAL for determinism in rollback netcode. It stores all\r\n * inputs (both predictions and server-confirmed) so that resimulation can\r\n * replay the exact same sequence of inputs after a rollback.\r\n *\r\n * Key guarantees:\r\n * 1. Inputs are stored per-frame with deterministic iteration order (sorted by clientId)\r\n * 2. Server-confirmed inputs replace any local predictions\r\n * 3. Serialization produces bit-exact snapshots for late joiners\r\n * 4. Memory is bounded by maxFrames through pruning\r\n */\r\n\r\n/**\r\n * Input data for a single frame, containing all client inputs.\r\n */\r\nexport interface FrameInput {\r\n    /** The frame number */\r\n    frame: number;\r\n\r\n    /** Client inputs for this frame (clientId -> input data) */\r\n    inputs: Map<number, Record<string, any>>;\r\n\r\n    /** Whether this frame has been confirmed by the server */\r\n    confirmed: boolean;\r\n\r\n    /**\r\n     * Get inputs in deterministic (sorted) order for resimulation.\r\n     * CRITICAL: Iteration order must be identical across all clients.\r\n     */\r\n    getSortedInputs(): Array<[number, Record<string, any>]>;\r\n}\r\n\r\n/**\r\n * Internal FrameInput implementation.\r\n */\r\nclass FrameInputImpl implements FrameInput {\r\n    frame: number;\r\n    inputs: Map<number, Record<string, any>>;\r\n    confirmed: boolean;\r\n\r\n    constructor(frame: number) {\r\n        this.frame = frame;\r\n        this.inputs = new Map();\r\n        this.confirmed = false;\r\n    }\r\n\r\n    /**\r\n     * Get inputs sorted by clientId for deterministic iteration.\r\n     */\r\n    getSortedInputs(): Array<[number, Record<string, any>]> {\r\n        const entries = Array.from(this.inputs.entries());\r\n        // Sort by clientId (numeric) for determinism\r\n        entries.sort((a, b) => a[0] - b[0]);\r\n        return entries;\r\n    }\r\n}\r\n\r\n/**\r\n * Serialized state for snapshots.\r\n */\r\nexport interface InputHistoryState {\r\n    frames: Array<{\r\n        frame: number;\r\n        inputs: Array<{ clientId: number; data: Record<string, any> }>;\r\n        confirmed: boolean;\r\n    }>;\r\n}\r\n\r\n/**\r\n * InputHistory stores inputs for resimulation during rollback.\r\n */\r\nexport class InputHistory {\r\n    /** Stored frames: frame number -> FrameInput */\r\n    private history: Map<number, FrameInputImpl> = new Map();\r\n\r\n    /** Maximum frames to keep (for memory management) */\r\n    private maxFrames: number;\r\n\r\n    /**\r\n     * Create InputHistory with optional max frame limit.\r\n     * @param maxFrames Maximum frames to keep (default 120)\r\n     */\r\n    constructor(maxFrames: number = 120) {\r\n        this.maxFrames = maxFrames;\r\n    }\r\n\r\n    /**\r\n     * Store input for a frame from a client.\r\n     * Used for local predictions before server confirmation.\r\n     *\r\n     * @param frame Frame number\r\n     * @param clientId Client ID (numeric)\r\n     * @param input Input data\r\n     */\r\n    setInput(frame: number, clientId: number, input: Record<string, any>): void {\r\n        let frameInput = this.history.get(frame);\r\n\r\n        if (!frameInput) {\r\n            frameInput = new FrameInputImpl(frame);\r\n            this.history.set(frame, frameInput);\r\n        }\r\n\r\n        frameInput.inputs.set(clientId, input);\r\n    }\r\n\r\n    /**\r\n     * Mark a frame as server-confirmed with authoritative inputs.\r\n     * This replaces any local predictions with server-provided data.\r\n     *\r\n     * @param frame Frame number\r\n     * @param inputs Map of clientId -> input data from server\r\n     */\r\n    confirmFrame(frame: number, inputs: Map<number, Record<string, any>>): void {\r\n        // Create new frame or replace existing\r\n        const frameInput = new FrameInputImpl(frame);\r\n        frameInput.confirmed = true;\r\n\r\n        // Copy all server inputs\r\n        for (const [clientId, data] of inputs) {\r\n            frameInput.inputs.set(clientId, data);\r\n        }\r\n\r\n        this.history.set(frame, frameInput);\r\n    }\r\n\r\n    /**\r\n     * Get input data for a specific frame.\r\n     *\r\n     * @param frame Frame number\r\n     * @returns FrameInput or undefined if not found\r\n     */\r\n    getFrame(frame: number): FrameInput | undefined {\r\n        return this.history.get(frame);\r\n    }\r\n\r\n    /**\r\n     * Get ordered frames for resimulation.\r\n     * Returns frames in ascending order, skipping any missing frames.\r\n     *\r\n     * CRITICAL: Order must be deterministic for rollback to work.\r\n     *\r\n     * @param fromFrame Start frame (inclusive)\r\n     * @param toFrame End frame (inclusive)\r\n     * @returns Array of FrameInput in ascending frame order\r\n     */\r\n    getRange(fromFrame: number, toFrame: number): FrameInput[] {\r\n        if (fromFrame > toFrame) {\r\n            return [];\r\n        }\r\n\r\n        const result: FrameInputImpl[] = [];\r\n\r\n        // Collect all frames in range\r\n        for (const [frame, frameInput] of this.history) {\r\n            if (frame >= fromFrame && frame <= toFrame) {\r\n                result.push(frameInput);\r\n            }\r\n        }\r\n\r\n        // Sort by frame number for deterministic order\r\n        result.sort((a, b) => a.frame - b.frame);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Remove frames before the specified frame number.\r\n     * Called to limit memory usage.\r\n     *\r\n     * @param beforeFrame Remove all frames with frame < beforeFrame\r\n     */\r\n    prune(beforeFrame: number): void {\r\n        // Collect frames to remove (avoid modifying during iteration)\r\n        const toRemove: number[] = [];\r\n\r\n        for (const frame of this.history.keys()) {\r\n            if (frame < beforeFrame) {\r\n                toRemove.push(frame);\r\n            }\r\n        }\r\n\r\n        // Remove collected frames\r\n        for (const frame of toRemove) {\r\n            this.history.delete(frame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize for snapshots (late joiner sync).\r\n     * CRITICAL: Must produce identical output across all clients.\r\n     *\r\n     * @returns Serializable state object\r\n     */\r\n    getState(): InputHistoryState {\r\n        const frames: InputHistoryState['frames'] = [];\r\n\r\n        // Sort frames by frame number for deterministic serialization\r\n        const sortedFrames = Array.from(this.history.entries())\r\n            .sort((a, b) => a[0] - b[0]);\r\n\r\n        for (const [, frameInput] of sortedFrames) {\r\n            // Sort inputs by clientId for deterministic serialization\r\n            const sortedInputs = frameInput.getSortedInputs().map(([clientId, data]) => ({\r\n                clientId,\r\n                data\r\n            }));\r\n\r\n            frames.push({\r\n                frame: frameInput.frame,\r\n                inputs: sortedInputs,\r\n                confirmed: frameInput.confirmed\r\n            });\r\n        }\r\n\r\n        return { frames };\r\n    }\r\n\r\n    /**\r\n     * Restore from serialized state (for late joiner sync).\r\n     * Clears existing data before restoring.\r\n     *\r\n     * @param state Previously serialized state\r\n     */\r\n    setState(state: InputHistoryState): void {\r\n        // Clear existing data\r\n        this.history.clear();\r\n\r\n        // Restore frames\r\n        for (const frameData of state.frames) {\r\n            const frameInput = new FrameInputImpl(frameData.frame);\r\n            frameInput.confirmed = frameData.confirmed;\r\n\r\n            for (const { clientId, data } of frameData.inputs) {\r\n                frameInput.inputs.set(clientId, data);\r\n            }\r\n\r\n            this.history.set(frameData.frame, frameInput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the number of frames currently stored.\r\n     * Useful for debugging and monitoring memory usage.\r\n     */\r\n    get size(): number {\r\n        return this.history.size;\r\n    }\r\n\r\n    /**\r\n     * Clear all stored history.\r\n     */\r\n    clear(): void {\r\n        this.history.clear();\r\n    }\r\n}\r\n", "/**\r\n * ECS World\r\n *\r\n * Main entry point for the ECS system. Manages:\r\n * - Entity definitions and spawning\r\n * - Component management\r\n * - Query engine\r\n * - System scheduler\r\n * - String interning\r\n */\r\n\r\nimport { EntityIdAllocator, EntityIdAllocatorState } from './entity-id';\r\nimport { SparseSnapshot, SparseSnapshotCodec } from './snapshot';\r\nimport {\r\n    ComponentType,\r\n    defineComponent as defineComponentInternal,\r\n    hasComponent,\r\n    addComponentToEntity,\r\n    initializeComponentDefaults,\r\n    removeComponentFromEntity,\r\n    clearComponentRegistry,\r\n    getAllComponents\r\n} from './component';\r\nimport { QueryEngine, QueryIterator } from './query';\r\nimport { SystemScheduler, SystemFn, SystemOptions } from './system';\r\nimport { Entity, EntityPool, EntityDefinition, RenderState } from './entity';\r\nimport { INDEX_MASK } from './constants';\r\nimport { toFixed, saveRandomState, loadRandomState } from '../math';\r\nimport { StringRegistry } from './string-registry';\r\nimport { InputHistory } from './input-history';\r\n\r\n/**\r\n * Entity definition builder.\r\n */\r\nexport class EntityBuilder {\r\n    private components: Array<{\r\n        type: ComponentType;\r\n        defaults?: Record<string, any>;\r\n    }> = [];\r\n\r\n    private registered: boolean = false;\r\n    private _syncFields?: string[];\r\n    private _onRestore?: (entity: Entity, game: any) => void;\r\n\r\n    constructor(\r\n        private world: World,\r\n        private name: string\r\n    ) {}\r\n\r\n    /**\r\n     * Add a component to this entity definition.\r\n     */\r\n    with<T extends Record<string, any>>(\r\n        component: ComponentType<T>,\r\n        defaults?: Partial<T>\r\n    ): EntityBuilder {\r\n        this.components.push({\r\n            type: component,\r\n            defaults: defaults as Record<string, any>\r\n        });\r\n\r\n        // Register immediately (idempotent - just overwrites with latest)\r\n        this.register();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set sync fields for this entity (internal - use GameEntityBuilder.syncOnly()).\r\n     */\r\n    _setSyncFields(fields: string[]): void {\r\n        this._syncFields = fields;\r\n    }\r\n\r\n    /**\r\n     * Set restore callback for this entity (internal - use GameEntityBuilder.onRestore()).\r\n     */\r\n    _setOnRestore(callback: (entity: Entity, game: any) => void): void {\r\n        this._onRestore = callback;\r\n    }\r\n\r\n    /**\r\n     * Finalize entity definition.\r\n     */\r\n    private register(): void {\r\n        this.world._registerEntityDef({\r\n            name: this.name,\r\n            components: this.components,\r\n            syncFields: this._syncFields,\r\n            onRestore: this._onRestore\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force immediate registration (for sync usage).\r\n     */\r\n    _ensureRegistered(): void {\r\n        if (!this.registered) {\r\n            this.registered = true;\r\n        }\r\n        this.register();\r\n    }\r\n\r\n    /**\r\n     * Get the entity definition (for internal use).\r\n     */\r\n    _getDefinition(): EntityDefinition {\r\n        return {\r\n            name: this.name,\r\n            components: this.components,\r\n            syncFields: this._syncFields,\r\n            onRestore: this._onRestore\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * ECS World - main container for all ECS state.\r\n */\r\nexport class World {\r\n    /** Entity ID allocator */\r\n    readonly idAllocator: EntityIdAllocator;\r\n\r\n    /** Query engine */\r\n    readonly queryEngine: QueryEngine;\r\n\r\n    /** System scheduler */\r\n    readonly scheduler: SystemScheduler;\r\n\r\n    /** Entity pool */\r\n    readonly entityPool: EntityPool;\r\n\r\n    /** String registry */\r\n    readonly strings: StringRegistry;\r\n\r\n    /** Entity definitions */\r\n    private entityDefs: Map<string, EntityDefinition> = new Map();\r\n\r\n    /** Active entity eids */\r\n    private activeEntities: Set<number> = new Set();\r\n\r\n    /** Entity type by eid */\r\n    private entityTypes: Map<number, string> = new Map();\r\n\r\n    /** Entity components by eid */\r\n    private entityComponents: Map<number, ComponentType[]> = new Map();\r\n\r\n    /** Client ID by eid */\r\n    private entityClientIds: Map<number, number> = new Map();\r\n\r\n    /** Input registry: clientId \u2192 input data */\r\n    private inputRegistry: Map<number, any> = new Map();\r\n\r\n    /** Whether running on client */\r\n    private _isClient: boolean = true;\r\n\r\n    constructor() {\r\n        this.idAllocator = new EntityIdAllocator();\r\n        this.entityPool = new EntityPool();\r\n        this.strings = new StringRegistry();\r\n\r\n        // Create query engine with callbacks\r\n        this.queryEngine = new QueryEngine(\r\n            (eid) => this.getEntity(eid),\r\n            (eid) => this.isDestroyed(eid)\r\n        );\r\n\r\n        this.scheduler = new SystemScheduler();\r\n\r\n        // Register interpolation state saving in prePhysics phase\r\n        this.addSystem(() => this.saveInterpolationState(), { phase: 'prePhysics', order: -1000 });\r\n    }\r\n\r\n    /**\r\n     * Set whether running on client.\r\n     */\r\n    setIsClient(isClient: boolean): void {\r\n        this._isClient = isClient;\r\n        this.scheduler.setIsClient(isClient);\r\n    }\r\n\r\n    /**\r\n     * Check if running on client.\r\n     */\r\n    get isClient(): boolean {\r\n        return this._isClient;\r\n    }\r\n\r\n    // ==========================================\r\n    // Component API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Define a new component type.\r\n     */\r\n    defineComponent<T extends Record<string, any>>(\r\n        name: string,\r\n        defaults: T\r\n    ): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\r\n        return defineComponentInternal(name, defaults);\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Definition API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Define a new entity type.\r\n     */\r\n    defineEntity(name: string): EntityBuilder {\r\n        const builder = new EntityBuilder(this, name);\r\n        // Auto-register when builder methods are done\r\n        // We need to defer this, so we'll register on first spawn or explicitly\r\n        return builder;\r\n    }\r\n\r\n    /**\r\n     * Register an entity definition (internal).\r\n     */\r\n    _registerEntityDef(def: EntityDefinition): void {\r\n        this.entityDefs.set(def.name, def);\r\n    }\r\n\r\n    /**\r\n     * Get entity definition by type name.\r\n     */\r\n    getEntityDef(typeName: string): EntityDefinition | undefined {\r\n        return this.entityDefs.get(typeName);\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Spawning/Destruction\r\n    // ==========================================\r\n\r\n    /**\r\n     * Spawn a new entity.\r\n     */\r\n    spawn(\r\n        typeOrBuilder: string | EntityBuilder,\r\n        props: Record<string, any> = {}\r\n    ): Entity {\r\n        // Handle EntityBuilder\r\n        let typeName: string;\r\n        if (typeof typeOrBuilder === 'string') {\r\n            typeName = typeOrBuilder;\r\n        } else {\r\n            const def = typeOrBuilder._getDefinition();\r\n            this._registerEntityDef(def);\r\n            typeName = def.name;\r\n        }\r\n\r\n        // Get entity definition\r\n        const def = this.entityDefs.get(typeName);\r\n        if (!def) {\r\n            throw new Error(`Unknown entity type: '${typeName}'`);\r\n        }\r\n\r\n        // Allocate entity ID\r\n        const eid = this.idAllocator.allocate();\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Get entity wrapper\r\n        const entity = this.entityPool.acquire(eid);\r\n\r\n        // Track entity\r\n        this.activeEntities.add(eid);\r\n        this.entityTypes.set(eid, typeName);\r\n\r\n        // Initialize components\r\n        const componentTypes: ComponentType[] = [];\r\n        for (const compDef of def.components) {\r\n            const component = compDef.type;\r\n            componentTypes.push(component);\r\n\r\n            // Add to storage\r\n            addComponentToEntity(component.storage, index);\r\n            initializeComponentDefaults(component.storage, index);\r\n\r\n            // Apply definition defaults\r\n            if (compDef.defaults) {\r\n                for (const [key, value] of Object.entries(compDef.defaults)) {\r\n                    const arr = component.storage.fields[key];\r\n                    if (arr) {\r\n                        const fieldDef = component.storage.schema[key];\r\n                        if (fieldDef.type === 'i32') {\r\n                            arr[index] = toFixed(value as number);\r\n                        } else if (fieldDef.type === 'bool') {\r\n                            arr[index] = value ? 1 : 0;\r\n                        } else {\r\n                            arr[index] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply spawn props (route to components)\r\n        let clientId: number | undefined;\r\n        for (const [key, value] of Object.entries(props)) {\r\n            if (key === 'clientId') {\r\n                clientId = value as number;\r\n                this.entityClientIds.set(eid, clientId);\r\n            }\r\n\r\n            // Route to first component that has this field\r\n            for (const component of componentTypes) {\r\n                if (key in component.storage.schema) {\r\n                    const arr = component.storage.fields[key];\r\n                    const fieldDef = component.storage.schema[key];\r\n                    if (fieldDef.type === 'i32') {\r\n                        arr[index] = toFixed(value as number);\r\n                    } else if (fieldDef.type === 'bool') {\r\n                        arr[index] = value ? 1 : 0;\r\n                    } else {\r\n                        arr[index] = value;\r\n                    }\r\n                    break; // Route to first matching component\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store components\r\n        this.entityComponents.set(eid, componentTypes);\r\n\r\n        // Initialize entity wrapper\r\n        entity._init(eid, typeName, componentTypes, this);\r\n\r\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\r\n        // Use raw props values (before fixed-point conversion) for render coordinates\r\n        if (props.x !== undefined || props.y !== undefined) {\r\n            const spawnX = props.x ?? 0;\r\n            const spawnY = props.y ?? 0;\r\n            entity.render.prevX = spawnX;\r\n            entity.render.prevY = spawnY;\r\n            entity.render.interpX = spawnX;\r\n            entity.render.interpY = spawnY;\r\n        }\r\n\r\n        // Register in query engine\r\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Spawn an entity with a specific eid (for snapshot restore).\r\n     * This is used when restoring entities to preserve their original IDs.\r\n     */\r\n    spawnWithId(typeOrBuilder: string | EntityBuilder, targetEid: number, props: Record<string, any> = {}): Entity {\r\n        let typeName: string;\r\n        if (typeof typeOrBuilder === 'string') {\r\n            typeName = typeOrBuilder;\r\n        } else {\r\n            const def = typeOrBuilder._getDefinition();\r\n            this._registerEntityDef(def);\r\n            typeName = def.name;\r\n        }\r\n\r\n        // Get entity definition\r\n        const def = this.entityDefs.get(typeName);\r\n        if (!def) {\r\n            throw new Error(`Unknown entity type: '${typeName}'`);\r\n        }\r\n\r\n        // Allocate specific entity ID\r\n        const eid = this.idAllocator.allocateSpecific(targetEid);\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Get entity wrapper\r\n        const entity = this.entityPool.acquire(eid);\r\n\r\n        // Track entity\r\n        this.activeEntities.add(eid);\r\n        this.entityTypes.set(eid, typeName);\r\n\r\n        // Initialize components\r\n        const componentTypes: ComponentType[] = [];\r\n        for (const compDef of def.components) {\r\n            const component = compDef.type;\r\n            componentTypes.push(component);\r\n\r\n            // Add to storage\r\n            addComponentToEntity(component.storage, index);\r\n            initializeComponentDefaults(component.storage, index);\r\n\r\n            // Apply definition defaults\r\n            if (compDef.defaults) {\r\n                for (const [key, value] of Object.entries(compDef.defaults)) {\r\n                    const arr = component.storage.fields[key];\r\n                    if (arr) {\r\n                        const fieldDef = component.storage.schema[key];\r\n                        if (fieldDef.type === 'i32') {\r\n                            arr[index] = toFixed(value as number);\r\n                        } else if (fieldDef.type === 'bool') {\r\n                            arr[index] = value ? 1 : 0;\r\n                        } else {\r\n                            arr[index] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply spawn props (route to components)\r\n        let clientId: number | undefined;\r\n        for (const [key, value] of Object.entries(props)) {\r\n            if (key === 'clientId') {\r\n                clientId = value as number;\r\n                this.entityClientIds.set(eid, clientId);\r\n            }\r\n\r\n            // Route to first component that has this field\r\n            for (const compDef of def.components) {\r\n                const arr = compDef.type.storage.fields[key];\r\n                if (arr) {\r\n                    const fieldDef = compDef.type.storage.schema[key];\r\n                    if (fieldDef.type === 'i32') {\r\n                        arr[index] = toFixed(value as number);\r\n                    } else if (fieldDef.type === 'bool') {\r\n                        arr[index] = value ? 1 : 0;\r\n                    } else {\r\n                        arr[index] = value;\r\n                    }\r\n                    break; // Route to first matching component\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store components\r\n        this.entityComponents.set(eid, componentTypes);\r\n\r\n        // Initialize entity wrapper\r\n        entity._init(eid, typeName, componentTypes, this);\r\n\r\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\r\n        // Use raw props values (before fixed-point conversion) for render coordinates\r\n        if (props.x !== undefined || props.y !== undefined) {\r\n            const spawnX = props.x ?? 0;\r\n            const spawnY = props.y ?? 0;\r\n            entity.render.prevX = spawnX;\r\n            entity.render.prevY = spawnY;\r\n            entity.render.interpX = spawnX;\r\n            entity.render.interpY = spawnY;\r\n        }\r\n\r\n        // Register in query engine\r\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Destroy an entity.\r\n     */\r\n    destroyEntity(entity: Entity): void {\r\n        const eid = entity.eid;\r\n\r\n        if (!this.activeEntities.has(eid)) {\r\n            return; // Already destroyed\r\n        }\r\n\r\n        const typeName = this.entityTypes.get(eid) || '';\r\n        const components = this.entityComponents.get(eid) || [];\r\n        const clientId = this.entityClientIds.get(eid);\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Remove from component storage\r\n        for (const component of components) {\r\n            removeComponentFromEntity(component.storage, index);\r\n        }\r\n\r\n        // Remove from query engine\r\n        this.queryEngine.removeEntity(eid, typeName, components, clientId);\r\n\r\n        // Clean up tracking\r\n        this.activeEntities.delete(eid);\r\n        this.entityTypes.delete(eid);\r\n        this.entityComponents.delete(eid);\r\n        this.entityClientIds.delete(eid);\r\n\r\n        // Return entity wrapper to pool\r\n        this.entityPool.release(eid);\r\n\r\n        // Free entity ID\r\n        this.idAllocator.free(eid);\r\n    }\r\n\r\n    /**\r\n     * Get entity by eid.\r\n     */\r\n    getEntity(eid: number): Entity | null {\r\n        if (!this.activeEntities.has(eid)) {\r\n            return null;\r\n        }\r\n\r\n        const entity = this.entityPool.get(eid);\r\n        if (entity && !entity.destroyed) {\r\n            return entity;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if entity is destroyed.\r\n     */\r\n    isDestroyed(eid: number): boolean {\r\n        return !this.activeEntities.has(eid);\r\n    }\r\n\r\n    /**\r\n     * Get entity by clientId (O(1) lookup).\r\n     */\r\n    getEntityByClientId(clientId: number): Entity | null {\r\n        const eid = this.queryEngine.getByClientId(clientId);\r\n        if (eid === undefined) return null;\r\n        return this.getEntity(eid);\r\n    }\r\n\r\n    /**\r\n     * Set clientId for an entity (for snapshot restore).\r\n     * Updates both entityClientIds map and queryEngine index.\r\n     */\r\n    setEntityClientId(eid: number, clientId: number): void {\r\n        this.entityClientIds.set(eid, clientId);\r\n        this.queryEngine.setClientId(eid, clientId);\r\n    }\r\n\r\n    // ==========================================\r\n    // Query API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Query entities by type or component.\r\n     */\r\n    query(\r\n        typeOrComponent: string | ComponentType,\r\n        ...moreComponents: ComponentType[]\r\n    ): QueryIterator<Entity> {\r\n        return this.queryEngine.query(typeOrComponent, ...moreComponents);\r\n    }\r\n\r\n    /**\r\n     * Get all active entities.\r\n     */\r\n    getAllEntities(): Entity[] {\r\n        const result: Entity[] = [];\r\n        // Sort eids for determinism\r\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\r\n        for (const eid of sortedEids) {\r\n            const entity = this.entityPool.get(eid);\r\n            if (entity) {\r\n                result.push(entity);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get all active entity IDs.\r\n     */\r\n    getAllEntityIds(): number[] {\r\n        return Array.from(this.activeEntities).sort((a, b) => a - b);\r\n    }\r\n\r\n    // ==========================================\r\n    // System API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Add a system.\r\n     */\r\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\r\n        return this.scheduler.add(fn, options);\r\n    }\r\n\r\n    /**\r\n     * Run all systems.\r\n     */\r\n    runSystems(): void {\r\n        this.scheduler.runAll();\r\n    }\r\n\r\n    // ==========================================\r\n    // String Interning API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Intern a string, get back an integer ID.\r\n     */\r\n    internString(namespace: string, str: string): number {\r\n        return this.strings.intern(namespace, str);\r\n    }\r\n\r\n    /**\r\n     * Look up string by ID.\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.strings.getString(namespace, id);\r\n    }\r\n\r\n    // ==========================================\r\n    // Input Registry\r\n    // ==========================================\r\n\r\n    /**\r\n     * Set input data for a client.\r\n     */\r\n    setInput(clientId: number, data: any): void {\r\n        this.inputRegistry.set(clientId, data);\r\n        // Also set on entity if it exists\r\n        const entity = this.getEntityByClientId(clientId);\r\n        if (entity) {\r\n            entity._setInputData(data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get input data for a client.\r\n     */\r\n    getInput(clientId: number): any {\r\n        return this.inputRegistry.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Clear all input data (call at end of tick).\r\n     */\r\n    clearInputs(): void {\r\n        this.inputRegistry.clear();\r\n    }\r\n\r\n    /**\r\n     * Get input state for snapshot.\r\n     * Returns a map of clientId -> input data.\r\n     */\r\n    getInputState(): Record<number, any> {\r\n        const state: Record<number, any> = {};\r\n        for (const [clientId, data] of this.inputRegistry) {\r\n            state[clientId] = data;\r\n        }\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Set input state from snapshot.\r\n     * Restores the input registry and entity input caches.\r\n     */\r\n    setInputState(state: Record<number, any>): void {\r\n        this.inputRegistry.clear();\r\n        for (const [clientIdStr, data] of Object.entries(state)) {\r\n            const clientId = parseInt(clientIdStr, 10);\r\n            this.inputRegistry.set(clientId, data);\r\n            // Also set on entity if it exists\r\n            const entity = this.getEntityByClientId(clientId);\r\n            if (entity) {\r\n                entity._setInputData(data);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // ==========================================\r\n    // State Management\r\n    // ==========================================\r\n\r\n    /**\r\n     * Get full world state for snapshotting.\r\n     */\r\n    getState(): WorldState {\r\n        const entities: EntityState[] = [];\r\n\r\n        for (const eid of this.activeEntities) {\r\n            const typeName = this.entityTypes.get(eid)!;\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            const componentData: Record<string, Record<string, number>> = {};\r\n\r\n            for (const component of components) {\r\n                const data: Record<string, number> = {};\r\n                for (const [fieldName, arr] of Object.entries(component.storage.fields)) {\r\n                    data[fieldName] = arr[index];\r\n                }\r\n                componentData[component.name] = data;\r\n            }\r\n\r\n            entities.push({\r\n                eid,\r\n                type: typeName,\r\n                components: componentData,\r\n                clientId: this.entityClientIds.get(eid)\r\n            });\r\n        }\r\n\r\n        return {\r\n            entities,\r\n            allocator: this.idAllocator.getState(),\r\n            strings: this.strings.getState()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Restore world state from snapshot.\r\n     */\r\n    setState(state: WorldState): void {\r\n        // Clear current state\r\n        this.clear();\r\n\r\n        // Restore allocator\r\n        this.idAllocator.setState(state.allocator);\r\n\r\n        // Restore strings\r\n        this.strings.setState(state.strings);\r\n\r\n        // Restore entities\r\n        for (const entityState of state.entities) {\r\n            const def = this.entityDefs.get(entityState.type);\r\n            if (!def) {\r\n                console.warn(`Unknown entity type in snapshot: ${entityState.type}`);\r\n                continue;\r\n            }\r\n\r\n            const eid = entityState.eid;\r\n            const index = eid & INDEX_MASK;\r\n\r\n            // Get entity wrapper\r\n            const entity = this.entityPool.acquire(eid);\r\n\r\n            // Track entity\r\n            this.activeEntities.add(eid);\r\n            this.entityTypes.set(eid, entityState.type);\r\n\r\n            if (entityState.clientId !== undefined) {\r\n                this.entityClientIds.set(eid, entityState.clientId);\r\n            }\r\n\r\n            // Restore components\r\n            const componentTypes: ComponentType[] = [];\r\n            for (const compDef of def.components) {\r\n                const component = compDef.type;\r\n                componentTypes.push(component);\r\n\r\n                addComponentToEntity(component.storage, index);\r\n\r\n                // Restore component data\r\n                const savedData = entityState.components[component.name];\r\n                if (savedData) {\r\n                    for (const [fieldName, value] of Object.entries(savedData)) {\r\n                        const arr = component.storage.fields[fieldName];\r\n                        if (arr) {\r\n                            arr[index] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.entityComponents.set(eid, componentTypes);\r\n\r\n            // Initialize entity wrapper\r\n            entity._init(eid, entityState.type, componentTypes, this);\r\n\r\n            // Register in query engine\r\n            this.queryEngine.addEntity(eid, entityState.type, componentTypes, entityState.clientId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all world state.\r\n     */\r\n    clear(): void {\r\n        // Release all entities\r\n        for (const eid of this.activeEntities) {\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            for (const component of components) {\r\n                removeComponentFromEntity(component.storage, index);\r\n            }\r\n\r\n            this.entityPool.release(eid);\r\n        }\r\n\r\n        // Clear tracking\r\n        this.activeEntities.clear();\r\n        this.entityTypes.clear();\r\n        this.entityComponents.clear();\r\n        this.entityClientIds.clear();\r\n\r\n        // Clear indices\r\n        this.queryEngine.clear();\r\n\r\n        // Reset allocator\r\n        this.idAllocator.reset();\r\n\r\n        // Clear strings\r\n        this.strings.clear();\r\n    }\r\n\r\n    /**\r\n     * Reset world (keeps definitions, clears entities).\r\n     */\r\n    reset(): void {\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * Get entity count.\r\n     */\r\n    get entityCount(): number {\r\n        return this.activeEntities.size;\r\n    }\r\n\r\n    // ==========================================\r\n    // Sparse Snapshot API (Efficient)\r\n    // ==========================================\r\n\r\n    /** Snapshot codec */\r\n    private snapshotCodec: SparseSnapshotCodec = new SparseSnapshotCodec();\r\n\r\n    /** Current frame number */\r\n    frame: number = 0;\r\n\r\n    /** Current sequence number */\r\n    seq: number = 0;\r\n\r\n    /** RNG state (for determinism) - deprecated, now uses global random state */\r\n    rngState?: { s0: number; s1: number };\r\n\r\n    /**\r\n     * Get sparse snapshot (efficient format).\r\n     */\r\n    getSparseSnapshot(): SparseSnapshot {\r\n        return this.snapshotCodec.encode(\r\n            Array.from(this.activeEntities),\r\n            (eid) => this.entityTypes.get(eid) || '',\r\n            (eid) => this.entityClientIds.get(eid),\r\n            (eid) => this.entityComponents.get(eid) || [],\r\n            this.idAllocator.getState(),\r\n            this.strings.getState(),\r\n            this.frame,\r\n            this.seq,\r\n            saveRandomState() // CRITICAL: Save actual RNG state for deterministic rollback\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load sparse snapshot (efficient format).\r\n     */\r\n    loadSparseSnapshot(snapshot: SparseSnapshot): void {\r\n        this.snapshotCodec.decode(\r\n            snapshot,\r\n            () => this.clearForSnapshot(),\r\n            (state) => this.idAllocator.setState(state),\r\n            (state) => this.strings.setState(state),\r\n            (eid, type, clientId) => this.createEntityFromSnapshot(eid, type, clientId),\r\n            (rng) => {\r\n                // CRITICAL: Actually restore the global RNG state for deterministic rollback\r\n                if (rng) {\r\n                    loadRandomState(rng);\r\n                }\r\n            }\r\n        );\r\n\r\n        this.frame = snapshot.frame;\r\n        this.seq = snapshot.seq;\r\n\r\n        // Sync render state with restored transform positions\r\n        this.syncRenderStateFromTransforms();\r\n    }\r\n\r\n    /**\r\n     * Sync render state with current transform positions.\r\n     * Called after snapshot restore to prevent interpolation artifacts.\r\n     */\r\n    private syncRenderStateFromTransforms(): void {\r\n        for (const eid of this.activeEntities) {\r\n            const entity = this.getEntity(eid);\r\n            if (!entity) continue;\r\n\r\n            // Find Transform2D component and read x,y values\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            for (const component of components) {\r\n                if (component.name === 'Transform2D') {\r\n                    const xArr = component.storage.fields['x'];\r\n                    const yArr = component.storage.fields['y'];\r\n                    if (xArr && yArr) {\r\n                        // Convert from fixed-point to float for render\r\n                        const x = xArr[index] / 65536;\r\n                        const y = yArr[index] / 65536;\r\n                        entity.render.prevX = x;\r\n                        entity.render.prevY = y;\r\n                        entity.render.interpX = x;\r\n                        entity.render.interpY = y;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear world for snapshot restore (doesn't reset allocator).\r\n     */\r\n    private clearForSnapshot(): void {\r\n        // Release all entities\r\n        for (const eid of this.activeEntities) {\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            for (const component of components) {\r\n                removeComponentFromEntity(component.storage, index);\r\n            }\r\n\r\n            this.entityPool.release(eid);\r\n        }\r\n\r\n        // Clear tracking\r\n        this.activeEntities.clear();\r\n        this.entityTypes.clear();\r\n        this.entityComponents.clear();\r\n        this.entityClientIds.clear();\r\n\r\n        // Clear query indices\r\n        this.queryEngine.clear();\r\n    }\r\n\r\n    /**\r\n     * Create entity from snapshot data (without allocating new ID).\r\n     */\r\n    private createEntityFromSnapshot(eid: number, type: string, clientId?: number): void {\r\n        const def = this.entityDefs.get(type);\r\n        if (!def) {\r\n            console.warn(`Unknown entity type in snapshot: ${type}`);\r\n            return;\r\n        }\r\n\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Get entity wrapper\r\n        const entity = this.entityPool.acquire(eid);\r\n\r\n        // Track entity\r\n        this.activeEntities.add(eid);\r\n        this.entityTypes.set(eid, type);\r\n\r\n        if (clientId !== undefined) {\r\n            this.entityClientIds.set(eid, clientId);\r\n        }\r\n\r\n        // Setup components (data will be restored by codec)\r\n        const componentTypes: ComponentType[] = [];\r\n        for (const compDef of def.components) {\r\n            const component = compDef.type;\r\n            componentTypes.push(component);\r\n            addComponentToEntity(component.storage, index);\r\n        }\r\n\r\n        this.entityComponents.set(eid, componentTypes);\r\n\r\n        // Initialize entity wrapper\r\n        entity._init(eid, type, componentTypes, this);\r\n\r\n        // Register in query engine\r\n        this.queryEngine.addEntity(eid, type, componentTypes, clientId);\r\n    }\r\n\r\n    /**\r\n     * Serialize snapshot to binary for network transfer.\r\n     */\r\n    snapshotToBinary(snapshot: SparseSnapshot): ArrayBuffer {\r\n        return this.snapshotCodec.toBinary(snapshot);\r\n    }\r\n\r\n    /**\r\n     * Deserialize snapshot from binary.\r\n     */\r\n    snapshotFromBinary(buffer: ArrayBuffer): SparseSnapshot {\r\n        return this.snapshotCodec.fromBinary(buffer);\r\n    }\r\n\r\n    /**\r\n     * Get snapshot size estimate.\r\n     */\r\n    getSnapshotSize(snapshot: SparseSnapshot): number {\r\n        return this.snapshotCodec.getSize(snapshot);\r\n    }\r\n\r\n    // ==========================================\r\n    // Network Integration (Phase 3)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Network input format.\r\n     */\r\n    private inputBuffer: Map<number, Record<string, any>> = new Map();\r\n\r\n    /**\r\n     * Run a single game tick with network inputs.\r\n     *\r\n     * Executes all system phases in order:\r\n     * 1. INPUT - Apply network inputs to entities\r\n     * 2. UPDATE - Game logic systems\r\n     * 3. PREPHYSICS - Save state for interpolation\r\n     * 4. PHYSICS - Physics simulation (external hook)\r\n     * 5. POSTPHYSICS - Post-physics cleanup\r\n     * 6. RENDER - Rendering (client only)\r\n     */\r\n    /** True while running deterministic simulation phases */\r\n    _isSimulating: boolean = false;\r\n\r\n    tick(frame: number, inputs: NetworkInput[] = []): void {\r\n        this.frame = frame;\r\n\r\n        // Apply network inputs (O(1) per input via clientIdIndex)\r\n        this.applyNetworkInputs(inputs);\r\n\r\n        // Run deterministic simulation phases\r\n        this._isSimulating = true;\r\n        try {\r\n            this.scheduler.runPhase('input');\r\n            this.scheduler.runPhase('update');\r\n            this.scheduler.runPhase('prePhysics');\r\n            this.scheduler.runPhase('physics');\r\n            this.scheduler.runPhase('postPhysics');\r\n        } finally {\r\n            this._isSimulating = false;\r\n        }\r\n\r\n        // Render phase only runs on client (not deterministic)\r\n        if (this._isClient) {\r\n            this.scheduler.runPhase('render');\r\n        }\r\n\r\n        // Clear input buffer after tick\r\n        this.inputBuffer.clear();\r\n    }\r\n\r\n    /**\r\n     * Apply network inputs to entities via O(1) clientId lookup.\r\n     */\r\n    private applyNetworkInputs(inputs: NetworkInput[]): void {\r\n        for (const input of inputs) {\r\n            // O(1) lookup via clientIdIndex\r\n            const entity = this.getEntityByClientId(input.clientId);\r\n\r\n            if (entity) {\r\n                // Store input data for systems to read\r\n                this.inputBuffer.set(input.clientId, input.data);\r\n\r\n                // Apply input to entity's render state for interpolation reference\r\n                const data = input.data;\r\n                if (data) {\r\n                    // Store in entity's input cache for system access\r\n                    entity._setInputData(data);\r\n                }\r\n            }\r\n            // If no entity for this clientId, silently ignore (disconnected player)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get input data for a clientId.\r\n     */\r\n    getInputForClient(clientId: number): Record<string, any> | undefined {\r\n        return this.inputBuffer.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Check if we have input for a clientId this tick.\r\n     */\r\n    hasInputForClient(clientId: number): boolean {\r\n        return this.inputBuffer.has(clientId);\r\n    }\r\n\r\n    /**\r\n     * Run only physics phase (for external physics integration).\r\n     */\r\n    runPhysics(): void {\r\n        this.scheduler.runPhase('physics');\r\n    }\r\n\r\n    /**\r\n     * Set physics step callback (called during PHYSICS phase).\r\n     */\r\n    setPhysicsStep(fn: () => void): () => void {\r\n        return this.addSystem(fn, { phase: 'physics', order: 0 });\r\n    }\r\n\r\n    /**\r\n     * Save previous positions for interpolation (called in prePhysics).\r\n     */\r\n    saveInterpolationState(): void {\r\n        for (const eid of this.activeEntities) {\r\n            const entity = this.getEntity(eid);\r\n            if (entity) {\r\n                entity._savePreviousState();\r\n            }\r\n        }\r\n    }\r\n\r\n    // ==========================================\r\n    // Client-Side Prediction (Phase 4)\r\n    // ==========================================\r\n\r\n    /** Local client ID for prediction */\r\n    localClientId: number | null = null;\r\n\r\n    /** Pending predictions awaiting server confirmation */\r\n    private predictions: PredictionEntry[] = [];\r\n\r\n    /** Rollback buffer for state restoration */\r\n    private rollbackBuffer: Map<number, SparseSnapshot> = new Map();\r\n\r\n    /** Maximum frames to keep in rollback buffer */\r\n    rollbackBufferSize: number = 60;\r\n\r\n    /** Callback for when rollback occurs */\r\n    onRollback?: (toFrame: number) => void;\r\n\r\n    /** Input history for rollback resimulation */\r\n    private inputHistory: InputHistory = new InputHistory(120);\r\n\r\n    /**\r\n     * Handle local player input (client-side prediction).\r\n     * Applies input immediately for responsiveness.\r\n     */\r\n    handleLocalInput(input: Record<string, any>): void {\r\n        if (this.localClientId === null) {\r\n            console.warn('Cannot handle local input: localClientId not set');\r\n            return;\r\n        }\r\n\r\n        // Apply input immediately (prediction)\r\n        const entity = this.getEntityByClientId(this.localClientId);\r\n        if (entity) {\r\n            entity._setInputData(input);\r\n        }\r\n\r\n        // Store input in history for potential resimulation\r\n        this.inputHistory.setInput(this.frame, this.localClientId, input);\r\n\r\n        // Store prediction for verification\r\n        this.predictions.push({\r\n            frame: this.frame,\r\n            input,\r\n            hash: this.getStateHash()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Process server-confirmed inputs.\r\n     * Detects mispredictions and triggers rollback if needed.\r\n     */\r\n    onServerTick(serverFrame: number, inputs: NetworkInput[]): boolean {\r\n        // Save current state before processing\r\n        this.saveSnapshot(this.frame);\r\n\r\n        // Convert NetworkInput[] to Map for input history\r\n        const inputMap = new Map<number, Record<string, any>>();\r\n        for (const input of inputs) {\r\n            inputMap.set(input.clientId, input.data);\r\n        }\r\n\r\n        // Store confirmed inputs in history for potential resimulation\r\n        this.inputHistory.confirmFrame(serverFrame, inputMap);\r\n\r\n        // Prune old input history to manage memory\r\n        const minFrame = serverFrame - 120;\r\n        if (minFrame > 0) {\r\n            this.inputHistory.prune(minFrame);\r\n        }\r\n\r\n        // Check if we predicted this frame\r\n        const predictionIdx = this.predictions.findIndex(p => p.frame === serverFrame);\r\n\r\n        if (predictionIdx !== -1) {\r\n            // We predicted this frame - verify our prediction was correct\r\n            const prediction = this.predictions[predictionIdx];\r\n\r\n            // Rollback to frame before this tick\r\n            const snapshot = this.rollbackBuffer.get(serverFrame);\r\n            if (snapshot) {\r\n                this.loadSparseSnapshot(snapshot);\r\n            }\r\n\r\n            // Apply server inputs\r\n            this.tick(serverFrame, inputs);\r\n\r\n            // Check if state matches our prediction\r\n            const serverHash = this.getStateHash();\r\n            const mispredicted = serverHash !== prediction.hash;\r\n\r\n            if (mispredicted) {\r\n                // Notify about rollback\r\n                this.onRollback?.(serverFrame);\r\n\r\n                // Resimulate from this frame forward\r\n                this.resimulateFrom(serverFrame);\r\n            }\r\n\r\n            // Remove verified predictions up to this frame\r\n            this.predictions = this.predictions.filter(p => p.frame > serverFrame);\r\n\r\n            return mispredicted;\r\n        } else {\r\n            // We didn't predict this frame, just apply normally\r\n            this.tick(serverFrame, inputs);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save snapshot for potential rollback.\r\n     */\r\n    saveSnapshot(frame: number): void {\r\n        const snapshot = this.getSparseSnapshot();\r\n        this.rollbackBuffer.set(frame, snapshot);\r\n\r\n        // Prune old snapshots\r\n        const minFrame = frame - this.rollbackBufferSize + 1;\r\n        for (const f of this.rollbackBuffer.keys()) {\r\n            if (f < minFrame) {\r\n                this.rollbackBuffer.delete(f);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore state from snapshot at frame.\r\n     */\r\n    restoreSnapshot(frame: number): boolean {\r\n        const snapshot = this.rollbackBuffer.get(frame);\r\n        if (!snapshot) {\r\n            return false;\r\n        }\r\n\r\n        this.loadSparseSnapshot(snapshot);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check if snapshot exists for frame.\r\n     */\r\n    hasSnapshot(frame: number): boolean {\r\n        return this.rollbackBuffer.has(frame);\r\n    }\r\n\r\n    /**\r\n     * Get oldest frame in rollback buffer.\r\n     */\r\n    getOldestSnapshotFrame(): number | undefined {\r\n        let oldest: number | undefined;\r\n        for (const frame of this.rollbackBuffer.keys()) {\r\n            if (oldest === undefined || frame < oldest) {\r\n                oldest = frame;\r\n            }\r\n        }\r\n        return oldest;\r\n    }\r\n\r\n    /**\r\n     * Resimulate from a frame forward to current frame.\r\n     * Uses stored inputs from input history.\r\n     *\r\n     * NOTE: This retrieves data from InputHistory but full tick logic\r\n     * will be implemented in Phase 2 of the rollback implementation plan.\r\n     */\r\n    private resimulateFrom(fromFrame: number): void {\r\n        const currentFrame = this.frame;\r\n\r\n        // Get all frames we need to resimulate (fromFrame+1 to current)\r\n        // We already applied fromFrame, so start at next frame\r\n        const framesToResim = this.inputHistory.getRange(fromFrame + 1, currentFrame);\r\n\r\n        // TODO Phase 2: Actually resimulate each frame\r\n        // For now, just log that we have the data available\r\n        if (framesToResim.length > 0) {\r\n            // Frames are available for resimulation\r\n            // Full implementation will call this.tick() for each frame\r\n            for (const frameInput of framesToResim) {\r\n                // Convert FrameInput to NetworkInput[] format\r\n                const inputs: NetworkInput[] = [];\r\n                for (const [clientId, data] of frameInput.getSortedInputs()) {\r\n                    inputs.push({ clientId, data });\r\n                }\r\n\r\n                // Tick the world with these inputs\r\n                this.tick(frameInput.frame, inputs);\r\n            }\r\n        }\r\n\r\n        // Restore frame counter (tick may have incremented it)\r\n        this.frame = currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Get deterministic hash of world state.\r\n     * Used for comparing state between clients.\r\n     * Excludes components with sync: false (client-only state).\r\n     */\r\n    getStateHash(): string {\r\n        // Get all entity data in deterministic order\r\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\r\n\r\n        let hash = 0;\r\n\r\n        for (const eid of sortedEids) {\r\n            const index = eid & INDEX_MASK;\r\n            const components = this.entityComponents.get(eid) || [];\r\n\r\n            // Hash eid\r\n            hash = (hash * 31 + eid) | 0;\r\n\r\n            // Hash each component's fields in deterministic order\r\n            for (const component of components) {\r\n                // Skip components that are not synced (client-only state)\r\n                if (!component.sync) continue;\r\n\r\n                const fieldNames = [...component.fieldNames].sort();\r\n                for (const fieldName of fieldNames) {\r\n                    const arr = component.storage.fields[fieldName];\r\n                    const value = arr[index];\r\n                    hash = (hash * 31 + value) | 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Convert to hex string\r\n        return (hash >>> 0).toString(16).padStart(8, '0');\r\n    }\r\n\r\n    /**\r\n     * Clear rollback buffer.\r\n     */\r\n    clearRollbackBuffer(): void {\r\n        this.rollbackBuffer.clear();\r\n        this.predictions = [];\r\n    }\r\n\r\n    /**\r\n     * Get pending prediction count.\r\n     */\r\n    getPendingPredictionCount(): number {\r\n        return this.predictions.length;\r\n    }\r\n\r\n    /**\r\n     * Check if we have pending predictions.\r\n     */\r\n    hasPendingPredictions(): boolean {\r\n        return this.predictions.length > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Network input format.\r\n */\r\nexport interface NetworkInput {\r\n    clientId: number;\r\n    data: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Prediction entry for tracking local predictions.\r\n */\r\nexport interface PredictionEntry {\r\n    frame: number;\r\n    input: Record<string, any>;\r\n    hash: string;\r\n}\r\n\r\n/**\r\n * World state for snapshotting.\r\n */\r\nexport interface WorldState {\r\n    entities: EntityState[];\r\n    allocator: EntityIdAllocatorState;\r\n    strings: {\r\n        tables: Record<string, Record<string, number>>;\r\n        nextIds: Record<string, number>;\r\n    };\r\n}\r\n\r\n/**\r\n * Entity state for snapshotting.\r\n */\r\nexport interface EntityState {\r\n    eid: number;\r\n    type: string;\r\n    components: Record<string, Record<string, number>>;\r\n    clientId?: number;\r\n}\r\n", "/**\r\n * Codec Module\r\n *\r\n * Binary encoding/decoding for network communication.\r\n */\r\n\r\nexport { encode, decode } from './binary';\r\n", "/**\r\n * Binary Codec\r\n *\r\n * Compact binary encoding for arbitrary JSON-like data.\r\n * Used for inputs, snapshots, and all engine-network communication.\r\n */\r\n\r\n// Type markers\r\nconst TYPE_NULL = 0x00;\r\nconst TYPE_FALSE = 0x01;\r\nconst TYPE_TRUE = 0x02;\r\nconst TYPE_INT8 = 0x03;\r\nconst TYPE_INT16 = 0x04;\r\nconst TYPE_INT32 = 0x05;\r\nconst TYPE_FLOAT64 = 0x06;\r\nconst TYPE_STRING = 0x07;\r\nconst TYPE_ARRAY = 0x08;\r\nconst TYPE_OBJECT = 0x09;\r\nconst TYPE_UINT8 = 0x0A;\r\nconst TYPE_UINT16 = 0x0B;\r\nconst TYPE_UINT32 = 0x0C;\r\n\r\n/**\r\n * Binary encoder - accumulates bytes\r\n */\r\nclass BinaryEncoder {\r\n    private buffer: number[] = [];\r\n\r\n    writeByte(b: number): void {\r\n        this.buffer.push(b & 0xFF);\r\n    }\r\n\r\n    writeUint16(n: number): void {\r\n        this.buffer.push((n >> 8) & 0xFF);\r\n        this.buffer.push(n & 0xFF);\r\n    }\r\n\r\n    writeUint32(n: number): void {\r\n        this.buffer.push((n >> 24) & 0xFF);\r\n        this.buffer.push((n >> 16) & 0xFF);\r\n        this.buffer.push((n >> 8) & 0xFF);\r\n        this.buffer.push(n & 0xFF);\r\n    }\r\n\r\n    writeInt32(n: number): void {\r\n        this.writeUint32(n >>> 0);\r\n    }\r\n\r\n    writeFloat64(n: number): void {\r\n        const view = new DataView(new ArrayBuffer(8));\r\n        view.setFloat64(0, n, false); // big-endian\r\n        for (let i = 0; i < 8; i++) {\r\n            this.buffer.push(view.getUint8(i));\r\n        }\r\n    }\r\n\r\n    writeString(s: string): void {\r\n        const encoded = new TextEncoder().encode(s);\r\n        this.writeUint16(encoded.length);\r\n        for (let i = 0; i < encoded.length; i++) {\r\n            this.buffer.push(encoded[i]);\r\n        }\r\n    }\r\n\r\n    writeValue(value: any): void {\r\n        if (value === null || value === undefined) {\r\n            this.writeByte(TYPE_NULL);\r\n        } else if (value === false) {\r\n            this.writeByte(TYPE_FALSE);\r\n        } else if (value === true) {\r\n            this.writeByte(TYPE_TRUE);\r\n        } else if (typeof value === 'number') {\r\n            if (Number.isInteger(value)) {\r\n                if (value >= 0 && value <= 255) {\r\n                    this.writeByte(TYPE_UINT8);\r\n                    this.writeByte(value);\r\n                } else if (value >= 0 && value <= 65535) {\r\n                    this.writeByte(TYPE_UINT16);\r\n                    this.writeUint16(value);\r\n                } else if (value >= -2147483648 && value <= 2147483647) {\r\n                    this.writeByte(TYPE_INT32);\r\n                    this.writeInt32(value);\r\n                } else {\r\n                    this.writeByte(TYPE_FLOAT64);\r\n                    this.writeFloat64(value);\r\n                }\r\n            } else {\r\n                this.writeByte(TYPE_FLOAT64);\r\n                this.writeFloat64(value);\r\n            }\r\n        } else if (typeof value === 'string') {\r\n            this.writeByte(TYPE_STRING);\r\n            this.writeString(value);\r\n        } else if (Array.isArray(value)) {\r\n            this.writeByte(TYPE_ARRAY);\r\n            this.writeUint16(value.length);\r\n            for (const item of value) {\r\n                this.writeValue(item);\r\n            }\r\n        } else if (typeof value === 'object') {\r\n            this.writeByte(TYPE_OBJECT);\r\n            const keys = Object.keys(value);\r\n            this.writeUint16(keys.length);\r\n            for (const key of keys) {\r\n                this.writeString(key);\r\n                this.writeValue(value[key]);\r\n            }\r\n        } else {\r\n            // Unknown type - encode as null\r\n            this.writeByte(TYPE_NULL);\r\n        }\r\n    }\r\n\r\n    toUint8Array(): Uint8Array {\r\n        return new Uint8Array(this.buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * Binary decoder - reads bytes\r\n */\r\nclass BinaryDecoder {\r\n    private data: Uint8Array;\r\n    private pos: number = 0;\r\n\r\n    constructor(data: Uint8Array) {\r\n        this.data = data;\r\n    }\r\n\r\n    readByte(): number {\r\n        return this.data[this.pos++];\r\n    }\r\n\r\n    readUint16(): number {\r\n        const b1 = this.data[this.pos++];\r\n        const b2 = this.data[this.pos++];\r\n        return (b1 << 8) | b2;\r\n    }\r\n\r\n    readUint32(): number {\r\n        const b1 = this.data[this.pos++];\r\n        const b2 = this.data[this.pos++];\r\n        const b3 = this.data[this.pos++];\r\n        const b4 = this.data[this.pos++];\r\n        return ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) >>> 0;\r\n    }\r\n\r\n    readInt32(): number {\r\n        const u = this.readUint32();\r\n        return u > 0x7FFFFFFF ? u - 0x100000000 : u;\r\n    }\r\n\r\n    readFloat64(): number {\r\n        const view = new DataView(new ArrayBuffer(8));\r\n        for (let i = 0; i < 8; i++) {\r\n            view.setUint8(i, this.data[this.pos++]);\r\n        }\r\n        return view.getFloat64(0, false);\r\n    }\r\n\r\n    readString(): string {\r\n        const len = this.readUint16();\r\n        const bytes = this.data.slice(this.pos, this.pos + len);\r\n        this.pos += len;\r\n        return new TextDecoder().decode(bytes);\r\n    }\r\n\r\n    readValue(): any {\r\n        const type = this.readByte();\r\n\r\n        switch (type) {\r\n            case TYPE_NULL:\r\n                return null;\r\n            case TYPE_FALSE:\r\n                return false;\r\n            case TYPE_TRUE:\r\n                return true;\r\n            case TYPE_UINT8:\r\n                return this.readByte();\r\n            case TYPE_UINT16:\r\n                return this.readUint16();\r\n            case TYPE_INT32:\r\n                return this.readInt32();\r\n            case TYPE_UINT32:\r\n                return this.readUint32();\r\n            case TYPE_FLOAT64:\r\n                return this.readFloat64();\r\n            case TYPE_STRING:\r\n                return this.readString();\r\n            case TYPE_ARRAY: {\r\n                const len = this.readUint16();\r\n                const arr = [];\r\n                for (let i = 0; i < len; i++) {\r\n                    arr.push(this.readValue());\r\n                }\r\n                return arr;\r\n            }\r\n            case TYPE_OBJECT: {\r\n                const len = this.readUint16();\r\n                const obj: Record<string, any> = {};\r\n                for (let i = 0; i < len; i++) {\r\n                    const key = this.readString();\r\n                    obj[key] = this.readValue();\r\n                }\r\n                return obj;\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Encode any JSON-compatible value to binary.\r\n */\r\nexport function encode(value: any): Uint8Array {\r\n    const encoder = new BinaryEncoder();\r\n    encoder.writeValue(value);\r\n    return encoder.toUint8Array();\r\n}\r\n\r\n/**\r\n * Decode binary data to a value.\r\n */\r\nexport function decode(data: Uint8Array): any {\r\n    const decoder = new BinaryDecoder(data);\r\n    return decoder.readValue();\r\n}\r\n", "/**\r\n * Game - High-level wrapper for ECS World with Network Integration\r\n *\r\n * Provides the game API that examples use:\r\n * - game.defineEntity(name) \u2192 EntityBuilder\r\n * - game.spawn(type, props) \u2192 Entity\r\n * - game.query(type) \u2192 Iterator\r\n * - game.addSystem(fn, options)\r\n * - game.physics \u2192 Physics2D integration\r\n * - game.connect() \u2192 Network connection with rollback sync\r\n */\r\n\r\nimport { World, EntityBuilder, NetworkInput } from './core/world';\r\nimport { Entity } from './core/entity';\r\nimport { ComponentType } from './core/component';\r\nimport { SystemFn, SystemOptions } from './core/system';\r\nimport { Transform2D, Body2D, Player } from './components';\r\nimport { SparseSnapshot } from './core/snapshot';\r\nimport { QueryIterator } from './core/query';\r\nimport { encode, decode } from './codec';\r\nimport { loadRandomState, saveRandomState } from './math/random';\r\nimport { INDEX_MASK } from './core/constants';\r\n\r\n// ==========================================\r\n// Types\r\n// ==========================================\r\n\r\n/** Physics system interface */\r\ninterface Physics2DLike {\r\n    physicsWorld: any;\r\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this;\r\n    setGravity(x: number, y: number): this;\r\n    getBody(entity: Entity): any;\r\n    clear(): void;\r\n    wakeAllBodies(): void;\r\n}\r\n\r\n/** Network connection interface (from modu-network SDK) */\r\ninterface Connection {\r\n    send(data: any): void;\r\n    sendSnapshot(snapshot: any, hash: string, seq?: number, frame?: number): void;\r\n    leaveRoom(): void;\r\n    clientId: string | null;\r\n    totalBytesIn: number;\r\n    totalBytesOut: number;\r\n    bandwidthIn: number;\r\n    bandwidthOut: number;\r\n}\r\n\r\n/** Network SDK interface */\r\ninterface NetworkSDK {\r\n    connect(roomId: string, options: any): Promise<Connection>;\r\n}\r\n\r\n/** Network input from server */\r\ninterface ServerInput {\r\n    seq: number;\r\n    clientId: string;\r\n    data: any;\r\n    frame?: number;\r\n}\r\n\r\n/** Game callbacks for lifecycle events */\r\nexport interface GameCallbacks {\r\n    /** Called when room is first created (first client joins) */\r\n    onRoomCreate?(): void;\r\n    /** Called when a client connects */\r\n    onConnect?(clientId: string): void;\r\n    /** Called when a client disconnects */\r\n    onDisconnect?(clientId: string): void;\r\n    /** Called after snapshot restore with all restored entities */\r\n    onSnapshot?(entities: Entity[]): void;\r\n    /** Called each game tick */\r\n    onTick?(frame: number): void;\r\n    /** Called each render frame */\r\n    render?(): void;\r\n}\r\n\r\n/** Connection options */\r\nexport interface ConnectOptions {\r\n    /** Direct node URL (bypasses central service) */\r\n    nodeUrl?: string;\r\n    /** Central service URL */\r\n    centralServiceUrl?: string;\r\n    /** JWT token for authentication */\r\n    joinToken?: string;\r\n}\r\n\r\n// Debug flag - set to false for production\r\nconst DEBUG_NETWORK = false;\r\n\r\n// ==========================================\r\n// Prefab Class\r\n// ==========================================\r\n\r\n/**\r\n * Prefab - spawnable entity definition\r\n */\r\nexport class Prefab {\r\n    constructor(\r\n        private game: Game,\r\n        private typeName: string,\r\n        private builder: EntityBuilder\r\n    ) {}\r\n\r\n    /**\r\n     * Spawn a new entity from this prefab.\r\n     */\r\n    spawn(props: Record<string, any> = {}): Entity {\r\n        return this.game.spawn(this.typeName, props);\r\n    }\r\n}\r\n\r\n// ==========================================\r\n// Game Class\r\n// ==========================================\r\n\r\n/**\r\n * Game class - main entry point for games using the ECS.\r\n */\r\nexport class Game {\r\n    /** ECS World instance */\r\n    readonly world: World;\r\n\r\n    /** Physics system (optional) */\r\n    physics: Physics2DLike | null = null;\r\n\r\n    // ==========================================\r\n    // Network State\r\n    // ==========================================\r\n\r\n    /** WebSocket connection */\r\n    private connection: Connection | null = null;\r\n\r\n    /** Game callbacks */\r\n    private callbacks: GameCallbacks = {};\r\n\r\n    /** Connected room ID */\r\n    private connectedRoomId: string | null = null;\r\n\r\n    /** Local client ID (string form) */\r\n    private localClientIdStr: string | null = null;\r\n\r\n    /** All connected client IDs (in join order for determinism) */\r\n    private connectedClients: string[] = [];\r\n\r\n    /** Authority client (first joiner, sends snapshots) */\r\n    private authorityClientId: string | null = null;\r\n\r\n    /** Current server frame */\r\n    private currentFrame: number = 0;\r\n\r\n    /** Last processed frame (for skipping old frames after catchup) */\r\n    private lastProcessedFrame: number = 0;\r\n\r\n    /** Last processed input sequence */\r\n    private lastInputSeq: number = 0;\r\n\r\n    /** Server tick rate */\r\n    private serverFps: number = 20;\r\n\r\n    /** RequestAnimationFrame handle */\r\n    private gameLoop: number | null = null;\r\n\r\n    /** Deferred snapshot flag (send after tick completes) */\r\n    private pendingSnapshotUpload: boolean = false;\r\n\r\n    /** Last snapshot info for debug UI */\r\n    private lastSnapshotHash: string | null = null;\r\n    private lastSnapshotFrame: number = 0;\r\n    private lastSnapshotSize: number = 0;\r\n    private lastSnapshotEntityCount: number = 0;\r\n\r\n    /** Drift tracking stats for debug UI */\r\n    private driftStats = {\r\n        determinismPercent: 100,\r\n        totalChecks: 0,\r\n        matchingFieldCount: 0,\r\n        totalFieldCount: 0\r\n    };\r\n\r\n    /** Divergence tracking */\r\n    private lastSyncPercent: number = 100;\r\n    private firstDivergenceFrame: number | null = null;\r\n    private divergenceHistory: Array<{ frame: number; field: string; local: any; server: any; delta?: number }> = [];\r\n    private recentInputs: Array<{ frame: number; seq: number; clientId: string; data: any }> = [];\r\n    private lastServerSnapshot: { raw: Uint8Array | null; decoded: any; frame: number } = { raw: null, decoded: null, frame: 0 };\r\n    private lastGoodSnapshot: { snapshot: any; frame: number; hash: string } | null = null;\r\n    private divergenceCaptured: boolean = false;\r\n    private divergenceCapture: {\r\n        lastGoodSnapshot: any;\r\n        lastGoodFrame: number;\r\n        inputs: Array<{ frame: number; seq: number; clientId: string; data: any }>;\r\n        localSnapshot: any;\r\n        serverSnapshot: any;\r\n        diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }>;\r\n        divergenceFrame: number;\r\n        clientId: string | null;\r\n        isAuthority: boolean;\r\n    } | null = null;\r\n\r\n    /** Tick timing for render interpolation */\r\n    private lastTickTime: number = 0;\r\n    private tickIntervalMs: number = 50; // 20fps default\r\n\r\n    // ==========================================\r\n    // String Interning\r\n    // ==========================================\r\n\r\n    /** String to ID mapping for clientIds */\r\n    private clientIdToNum: Map<string, number> = new Map();\r\n    private numToClientId: Map<number, string> = new Map();\r\n    private nextClientNum: number = 1;\r\n\r\n    /** Prefab registry */\r\n    private prefabs: Map<string, Prefab> = new Map();\r\n\r\n    /** Collision handlers (type:type -> handler) */\r\n    private collisionHandlers: Map<string, (a: Entity, b: Entity) => void> = new Map();\r\n\r\n    /** Clients that already have entities from snapshot (skip onConnect for them during catchup) */\r\n    private clientsWithEntitiesFromSnapshot: Set<string> = new Set();\r\n\r\n    /** Attached renderer */\r\n    private renderer: any = null;\r\n\r\n    /** Installed plugins */\r\n    private plugins: Map<string, any> = new Map();\r\n\r\n    constructor() {\r\n        this.world = new World();\r\n    }\r\n\r\n    // ==========================================\r\n    // Plugin API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Add a plugin to the game.\r\n     *\r\n     * Plugins can be classes or factory functions that integrate with the game.\r\n     * Common plugins include Physics2DSystem and AutoRenderer.\r\n     *\r\n     * @example\r\n     * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\r\n     * game.addPlugin(AutoRenderer, canvas);\r\n     *\r\n     * @param Plugin - Plugin class or factory\r\n     * @param args - Arguments to pass to the plugin constructor\r\n     * @returns The created plugin instance\r\n     */\r\n    addPlugin<T>(\r\n        Plugin: new (game: Game, ...args: any[]) => T,\r\n        ...args: any[]\r\n    ): T {\r\n        const plugin = new Plugin(this, ...args);\r\n        const name = Plugin.name || 'anonymous';\r\n        this.plugins.set(name, plugin);\r\n        return plugin;\r\n    }\r\n\r\n    /**\r\n     * Get a previously added plugin by class.\r\n     */\r\n    getPlugin<T>(Plugin: new (...args: any[]) => T): T | undefined {\r\n        return this.plugins.get(Plugin.name) as T | undefined;\r\n    }\r\n\r\n    /**\r\n     * Current frame number.\r\n     */\r\n    get frame(): number {\r\n        return this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Deterministic time in milliseconds.\r\n     * Use this instead of Date.now() for game logic.\r\n     *\r\n     * @example\r\n     * const RESPAWN_TIME = 3000; // 3 seconds\r\n     * deadPlayers.set(clientId, game.time + RESPAWN_TIME);\r\n     * if (game.time >= respawnTime) spawnPlayer(clientId);\r\n     */\r\n    get time(): number {\r\n        return this.currentFrame * this.tickIntervalMs;\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Definition API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Define a new entity type.\r\n     *\r\n     * @example\r\n     * const Cell = game.defineEntity('cell')\r\n     *     .with(Transform2D)\r\n     *     .with(Body2D, { shapeType: 1, radius: 20 })\r\n     *     .with(Player);\r\n     */\r\n    defineEntity(name: string): GameEntityBuilder {\r\n        return new GameEntityBuilder(this, name);\r\n    }\r\n\r\n    /**\r\n     * Register a prefab (internal).\r\n     */\r\n    _registerPrefab(name: string, builder: EntityBuilder): Prefab {\r\n        const prefab = new Prefab(this, name, builder);\r\n        this.prefabs.set(name, prefab);\r\n        return prefab;\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Spawning\r\n    // ==========================================\r\n\r\n    /**\r\n     * Spawn an entity.\r\n     *\r\n     * @param type Entity type name\r\n     * @param props Property overrides\r\n     */\r\n    spawn(type: string, props: Record<string, any> = {}): Entity {\r\n        // Convert string clientId to number\r\n        let numericProps = { ...props };\r\n        if (props.clientId && typeof props.clientId === 'string') {\r\n            numericProps.clientId = this.internClientId(props.clientId);\r\n        }\r\n\r\n        return this.world.spawn(type, numericProps);\r\n    }\r\n\r\n    /**\r\n     * Get a prefab by name.\r\n     */\r\n    getPrefab(name: string): Prefab | undefined {\r\n        return this.prefabs.get(name);\r\n    }\r\n\r\n    // ==========================================\r\n    // Query API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Query entities by type.\r\n     */\r\n    query(type: string): QueryIterator<Entity> {\r\n        return this.world.query(type);\r\n    }\r\n\r\n    /**\r\n     * Get entities by type as array.\r\n     */\r\n    getEntitiesByType(type: string): Entity[] {\r\n        return this.world.query(type).toArray();\r\n    }\r\n\r\n    /**\r\n     * Get all entities.\r\n     */\r\n    getAllEntities(): Entity[] {\r\n        return this.world.getAllEntities();\r\n    }\r\n\r\n    /**\r\n     * Get entity by client ID.\r\n     */\r\n    getEntityByClientId(clientId: string): Entity | null {\r\n        const numId = this.clientIdToNum.get(clientId);\r\n        if (numId === undefined) return null;\r\n        return this.world.getEntityByClientId(numId);\r\n    }\r\n\r\n    /**\r\n     * Get player by client ID (alias for getEntityByClientId).\r\n     */\r\n    getPlayer(clientId: string): Entity | null {\r\n        return this.getEntityByClientId(clientId);\r\n    }\r\n\r\n    /**\r\n     * Get all players (entities with Player component).\r\n     */\r\n    getPlayers(): Entity[] {\r\n        return this.world.query(Player).toArray();\r\n    }\r\n\r\n    // ==========================================\r\n    // System API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Add a system.\r\n     */\r\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\r\n        return this.world.addSystem(fn, options);\r\n    }\r\n\r\n    // ==========================================\r\n    // Collision API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Register a collision handler.\r\n     */\r\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this {\r\n        if (this.physics) {\r\n            this.physics.onCollision(typeA, typeB, handler);\r\n        } else {\r\n            const key = `${typeA}:${typeB}`;\r\n            this.collisionHandlers.set(key, handler);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ==========================================\r\n    // String Interning\r\n    // ==========================================\r\n\r\n    /**\r\n     * Intern a client ID string, get back a number.\r\n     */\r\n    internClientId(clientId: string): number {\r\n        let num = this.clientIdToNum.get(clientId);\r\n        if (num === undefined) {\r\n            num = this.nextClientNum++;\r\n            this.clientIdToNum.set(clientId, num);\r\n            this.numToClientId.set(num, clientId);\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * Get client ID string from number.\r\n     */\r\n    getClientIdString(num: number): string | undefined {\r\n        return this.numToClientId.get(num);\r\n    }\r\n\r\n    /**\r\n     * Intern any string in a namespace.\r\n     */\r\n    internString(namespace: string, str: string): number {\r\n        return this.world.internString(namespace, str);\r\n    }\r\n\r\n    /**\r\n     * Get string by ID from namespace.\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.world.getString(namespace, id);\r\n    }\r\n\r\n    // ==========================================\r\n    // State Management\r\n    // ==========================================\r\n\r\n    /**\r\n     * Get deterministic state hash.\r\n     */\r\n    getStateHash(): string {\r\n        return this.world.getStateHash();\r\n    }\r\n\r\n    /**\r\n     * Reset game state.\r\n     */\r\n    reset(): void {\r\n        this.world.reset();\r\n        this.currentFrame = 0;\r\n    }\r\n\r\n    // ==========================================\r\n    // Network Connection\r\n    // ==========================================\r\n\r\n    /**\r\n     * Connect to a multiplayer room.\r\n     */\r\n    async connect(\r\n        roomId: string,\r\n        callbacks: GameCallbacks,\r\n        options: ConnectOptions = {}\r\n    ): Promise<void> {\r\n        this.callbacks = callbacks;\r\n\r\n        // Allow URL params to override (for testing)\r\n        if (typeof window !== 'undefined') {\r\n            const params = new URLSearchParams(window.location.search);\r\n            if (params.get('room')) roomId = params.get('room')!;\r\n            if (params.get('nodeUrl')) options.nodeUrl = params.get('nodeUrl')!;\r\n        }\r\n\r\n        this.connectedRoomId = roomId;\r\n\r\n        // Get network SDK\r\n        const network: NetworkSDK = (window as any).moduNetwork;\r\n        if (!network) {\r\n            throw new Error('moduNetwork not found. Include modu-network SDK before calling connect().');\r\n        }\r\n\r\n        console.log(`[ecs] Connecting to room \"${roomId}\"...`);\r\n\r\n        try {\r\n            this.connection = await network.connect(roomId, {\r\n                nodeUrl: options.nodeUrl,\r\n                centralServiceUrl: options.centralServiceUrl,\r\n                appId: 'dev',\r\n                joinToken: options.joinToken,\r\n\r\n                onConnect: (\r\n                    snapshot: any,\r\n                    inputs: ServerInput[],\r\n                    frame: number,\r\n                    nodeUrl: string | null,\r\n                    fps: number,\r\n                    clientId: string\r\n                ) => {\r\n                    this.handleConnect(snapshot, inputs, frame, fps, clientId);\r\n                },\r\n\r\n                onTick: (frame: number, inputs: ServerInput[]) => {\r\n                    this.handleTick(frame, inputs);\r\n                },\r\n\r\n                onDisconnect: () => {\r\n                    this.handleDisconnect();\r\n                },\r\n\r\n                onBinarySnapshot: (data: Uint8Array) => {\r\n                    this.handleServerSnapshot(data);\r\n                },\r\n\r\n                onError: (error: string) => {\r\n                    console.error('[ecs] Network error:', error);\r\n                }\r\n            });\r\n\r\n            this.localClientIdStr = this.connection.clientId;\r\n        } catch (err: any) {\r\n            console.warn('[ecs] Connection failed:', err?.message || err);\r\n            this.connection = null;\r\n            this.connectedRoomId = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle initial connection (first join or late join).\r\n     */\r\n    private handleConnect(\r\n        snapshot: any,\r\n        inputs: ServerInput[],\r\n        frame: number,\r\n        fps: number,\r\n        clientId: string\r\n    ): void {\r\n        // Decode binary snapshot if needed\r\n        let snapshotSize = 0;\r\n        if (snapshot instanceof Uint8Array) {\r\n            snapshotSize = snapshot.length;\r\n            if (snapshot.length < 2) {\r\n                snapshot = null;\r\n            } else {\r\n                try {\r\n                    snapshot = decode(snapshot)?.snapshot || null;\r\n                } catch (e) {\r\n                    console.error('[ecs] Failed to decode snapshot:', e);\r\n                    snapshot = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store connection state\r\n        this.localClientIdStr = clientId;\r\n        this.serverFps = fps;\r\n        this.tickIntervalMs = 1000 / fps;\r\n        this.currentFrame = frame;\r\n\r\n        // Store snapshot hash for debug UI\r\n        if (snapshot?.hash !== undefined) {\r\n            this.lastSnapshotHash = typeof snapshot.hash === 'number'\r\n                ? snapshot.hash.toString(16).padStart(8, '0')\r\n                : String(snapshot.hash);\r\n            this.lastSnapshotFrame = snapshot.frame || frame;\r\n            this.lastSnapshotSize = snapshotSize;\r\n            this.lastSnapshotEntityCount = snapshot.entities?.length || 0;\r\n        }\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Connected as ${clientId}, frame ${frame}, fps ${fps}`);\r\n            console.log(`[ecs] Snapshot:`, snapshot ? { frame: snapshot.frame, entityCount: snapshot.entities?.length } : 'none');\r\n            console.log(`[ecs] Inputs: ${inputs.length}`);\r\n        }\r\n\r\n        const hasValidSnapshot = snapshot?.entities && snapshot.entities.length > 0;\r\n\r\n        if (hasValidSnapshot) {\r\n            // === LATE JOINER PATH ===\r\n            if (DEBUG_NETWORK) console.log(`[ecs] Late join: restoring snapshot frame=${snapshot.frame}`);\r\n\r\n            // 1. Restore snapshot\r\n            this.currentFrame = snapshot.frame || frame;\r\n            this.loadNetworkSnapshot(snapshot);\r\n\r\n            // 2. Build authority chain from ALL inputs\r\n            for (const input of inputs) {\r\n                this.processAuthorityChainInput(input);\r\n            }\r\n\r\n            // 3. Call onSnapshot callback\r\n            if (this.callbacks.onSnapshot) {\r\n                this.callbacks.onSnapshot(this.world.getAllEntities());\r\n            }\r\n\r\n            // 4. Filter inputs already in snapshot\r\n            const snapshotSeq = snapshot.seq || 0;\r\n            const pendingInputs = inputs\r\n                .filter(i => i.seq > snapshotSeq)\r\n                .sort((a, b) => a.seq - b.seq);\r\n\r\n            // 5. Run catchup simulation\r\n            const snapshotFrame = this.currentFrame;\r\n            const isPostTick = snapshot.postTick === true;\r\n            const startFrame = isPostTick ? snapshotFrame + 1 : snapshotFrame;\r\n            const ticksToRun = frame - startFrame + 1;\r\n\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Catchup: from ${startFrame} to ${frame} (${ticksToRun} ticks), ${pendingInputs.length} pending inputs`);\r\n            }\r\n\r\n            if (ticksToRun > 0) {\r\n                this.runCatchup(startFrame, frame, pendingInputs);\r\n            }\r\n        } else {\r\n            // === FIRST JOINER PATH ===\r\n            if (DEBUG_NETWORK) console.log('[ecs] First join: creating room');\r\n\r\n            this.currentFrame = frame;\r\n            this.callbacks.onRoomCreate?.();\r\n\r\n            // Process all inputs\r\n            for (const input of inputs) {\r\n                this.processInput(input);\r\n            }\r\n        }\r\n\r\n        // Send initial snapshot if we're authority\r\n        if (this.checkIsAuthority()) {\r\n            this.sendSnapshot('init');\r\n        }\r\n\r\n        // Start game loop\r\n        this.startGameLoop();\r\n        if (DEBUG_NETWORK) console.log('[ecs] Game loop started');\r\n    }\r\n\r\n    /**\r\n     * Handle server tick.\r\n     */\r\n    private handleTick(frame: number, inputs: ServerInput[]): void {\r\n        // Skip frames we've already processed (e.g., during catchup)\r\n        if (frame <= this.lastProcessedFrame) {\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Skipping old frame ${frame} (already at ${this.lastProcessedFrame})`);\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.currentFrame = frame;\r\n        this.lastProcessedFrame = frame;\r\n\r\n        if (DEBUG_NETWORK && inputs.length > 0) {\r\n            const types = inputs.map(i => i.data?.type || 'game').join(',');\r\n            console.log(`[ecs] onTick frame=${frame}: ${inputs.length} inputs (${types})`);\r\n        }\r\n\r\n        // 1. Process all inputs for this frame (sorted by seq for determinism)\r\n        // Multiple inputs can arrive in a single tick - seq determines order\r\n        const sortedInputs = inputs.length > 1\r\n            ? [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0))\r\n            : inputs;\r\n        for (const input of sortedInputs) {\r\n            this.processInput(input);\r\n        }\r\n\r\n        // 2. Run ECS world tick (systems)\r\n        this.world.tick(frame, []);\r\n\r\n        // 3. Call game's onTick callback\r\n        this.callbacks.onTick?.(frame);\r\n\r\n        // 4. Send deferred snapshot if pending\r\n        if (this.pendingSnapshotUpload && this.checkIsAuthority()) {\r\n            this.sendSnapshot('join');\r\n            this.pendingSnapshotUpload = false;\r\n        }\r\n\r\n        // 5. Record tick time for interpolation\r\n        this.lastTickTime = typeof performance !== 'undefined' ? performance.now() : Date.now();\r\n    }\r\n\r\n    /**\r\n     * Process a network input (join/leave/game).\r\n     */\r\n    private processInput(input: ServerInput): void {\r\n        // Decode binary data if needed\r\n        let data = input.data;\r\n        if (data instanceof Uint8Array) {\r\n            try {\r\n                data = decode(data);\r\n            } catch (e) {\r\n                console.warn('[ecs] Failed to decode input:', e);\r\n                return;\r\n            }\r\n        }\r\n\r\n        const clientId = data?.clientId || input.clientId;\r\n        const type = data?.type;\r\n\r\n        // Track input for divergence debugging (keep last 500)\r\n        this.recentInputs.push({\r\n            frame: this.currentFrame,\r\n            seq: input.seq,\r\n            clientId,\r\n            data: JSON.parse(JSON.stringify(data))\r\n        });\r\n        if (this.recentInputs.length > 500) {\r\n            this.recentInputs.shift();\r\n        }\r\n\r\n        // Track input sequence\r\n        if (input.seq > this.lastInputSeq) {\r\n            this.lastInputSeq = input.seq;\r\n        }\r\n\r\n        if (type === 'join') {\r\n            // Track connected clients\r\n            if (!this.connectedClients.includes(clientId)) {\r\n                this.connectedClients.push(clientId);\r\n            }\r\n\r\n            // First joiner becomes authority\r\n            if (this.authorityClientId === null) {\r\n                this.authorityClientId = clientId;\r\n            }\r\n\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Join: ${clientId.slice(0, 8)}, authority=${this.authorityClientId?.slice(0, 8)}`);\r\n            }\r\n\r\n            // Call callback ONLY if this client doesn't already have an entity from snapshot\r\n            // This prevents duplicate entity creation during catchup\r\n            if (this.clientsWithEntitiesFromSnapshot.has(clientId)) {\r\n                if (DEBUG_NETWORK) {\r\n                    console.log(`[ecs] Skipping onConnect for ${clientId.slice(0, 8)} - already has entity from snapshot`);\r\n                }\r\n            } else {\r\n                this.callbacks.onConnect?.(clientId);\r\n            }\r\n\r\n            // Mark snapshot needed\r\n            if (this.checkIsAuthority()) {\r\n                this.pendingSnapshotUpload = true;\r\n            }\r\n        } else if (type === 'leave' || type === 'disconnect') {\r\n            // Remove from connected clients\r\n            const idx = this.connectedClients.indexOf(clientId);\r\n            if (idx !== -1) {\r\n                this.connectedClients.splice(idx, 1);\r\n            }\r\n\r\n            // Transfer authority if needed\r\n            if (clientId === this.authorityClientId) {\r\n                this.authorityClientId = this.connectedClients[0] || null;\r\n            }\r\n\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Leave: ${clientId.slice(0, 8)}, new authority=${this.authorityClientId?.slice(0, 8)}`);\r\n            }\r\n\r\n            // Call callback\r\n            this.callbacks.onDisconnect?.(clientId);\r\n        } else if (data) {\r\n            // Game input - store in world's input registry\r\n            this.routeInputToEntity(clientId, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Route game input to the world's input registry for systems to read.\r\n     */\r\n    private routeInputToEntity(clientId: string, data: any): void {\r\n        const numId = this.internClientId(clientId);\r\n\r\n        // Use O(1) clientId index lookup instead of iterating\r\n        const entity = this.world.getEntityByClientId(numId);\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] routeInput: clientId=${clientId.slice(0, 8)}, numId=${numId}, entity=${entity?.eid || 'null'}, data=${JSON.stringify(data)}`);\r\n        }\r\n        if (entity) {\r\n            // Store input in world's input registry for systems to read\r\n            this.world.setInput(numId, data);\r\n        } else if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] WARNING: No entity for clientId ${clientId.slice(0, 8)} (numId=${numId})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process input for authority chain only (no game logic).\r\n     */\r\n    private processAuthorityChainInput(input: ServerInput): void {\r\n        let data = input.data;\r\n        if (data instanceof Uint8Array) {\r\n            try { data = decode(data); } catch { return; }\r\n        }\r\n\r\n        const clientId = data?.clientId || input.clientId;\r\n        const type = data?.type;\r\n\r\n        if (type === 'join') {\r\n            if (!this.connectedClients.includes(clientId)) {\r\n                this.connectedClients.push(clientId);\r\n            }\r\n            if (this.authorityClientId === null) {\r\n                this.authorityClientId = clientId;\r\n            }\r\n        } else if (type === 'leave' || type === 'disconnect') {\r\n            const idx = this.connectedClients.indexOf(clientId);\r\n            if (idx !== -1) {\r\n                this.connectedClients.splice(idx, 1);\r\n            }\r\n            if (clientId === this.authorityClientId) {\r\n                this.authorityClientId = this.connectedClients[0] || null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run catchup simulation.\r\n     */\r\n    private runCatchup(startFrame: number, endFrame: number, inputs: ServerInput[]): void {\r\n        const ticksToRun = endFrame - startFrame + 1;\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Catchup: ${ticksToRun} ticks from ${startFrame} to ${endFrame}, ${inputs.length} inputs`);\r\n        }\r\n\r\n        // CRITICAL: Sort all inputs by seq to ensure correct order within frames\r\n        // Multiple inputs can occur in a single frame - seq determines order\r\n        const sortedInputs = [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0));\r\n\r\n        // Build map of frame -> inputs for that frame (sorted by seq)\r\n        const inputsByFrame = new Map<number, ServerInput[]>();\r\n        for (const input of sortedInputs) {\r\n            // Inputs without frame are assigned to startFrame (first catchup frame)\r\n            const frame = input.frame ?? startFrame;\r\n            if (!inputsByFrame.has(frame)) {\r\n                inputsByFrame.set(frame, []);\r\n            }\r\n            inputsByFrame.get(frame)!.push(input);\r\n        }\r\n\r\n        // Run each tick\r\n        for (let f = 0; f < ticksToRun; f++) {\r\n            const tickFrame = startFrame + f;\r\n\r\n            // Process inputs for this frame (already sorted by seq)\r\n            const frameInputs = inputsByFrame.get(tickFrame) || [];\r\n            for (const input of frameInputs) {\r\n                this.processInput(input);\r\n            }\r\n\r\n            // Run world tick\r\n            this.world.tick(tickFrame, []);\r\n\r\n            // Call game's onTick\r\n            this.callbacks.onTick?.(tickFrame);\r\n        }\r\n\r\n        this.currentFrame = endFrame;\r\n        this.lastProcessedFrame = endFrame;  // Prevent re-processing old frames\r\n\r\n        // Clear the snapshot entity tracking - catchup is done\r\n        // Future join events should trigger onConnect normally\r\n        this.clientsWithEntitiesFromSnapshot.clear();\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Catchup complete at frame ${this.currentFrame}, hash=${this.getStateHash()}`);\r\n        }\r\n    }\r\n\r\n    // ==========================================\r\n    // Snapshot Methods\r\n    // ==========================================\r\n\r\n    /**\r\n     * Convert ECS snapshot to network wire format.\r\n     */\r\n    private getNetworkSnapshot(): any {\r\n        // Format 5: Type-indexed encoding with optional syncFields\r\n        // - types: [\"snake-head\", \"snake-segment\", ...] - type names array\r\n        // - schema: [[compSchema], [compSchema], ...] - indexed by type index\r\n        // - entities: [[eid, typeIndex, values], ...] - typeIndex instead of string\r\n        // If entity type has syncFields, only those fields are included in schema/values\r\n\r\n        // Build type index and schema\r\n        const types: string[] = [];\r\n        const typeToIndex = new Map<string, number>();\r\n        const schema: [string, string[]][][] = [];\r\n        const typeSyncFields = new Map<string, Set<string>>();  // Cache syncFields per type\r\n        const entities: any[] = [];\r\n\r\n        for (const entity of this.world.getAllEntities()) {\r\n            const index = entity.eid & INDEX_MASK;\r\n            const type = entity.type;\r\n\r\n            // Assign type index if new type\r\n            if (!typeToIndex.has(type)) {\r\n                const typeIdx = types.length;\r\n                types.push(type);\r\n                typeToIndex.set(type, typeIdx);\r\n\r\n                // Get syncFields for this type (if defined)\r\n                const entityDef = this.world.getEntityDef(type);\r\n                const syncFieldsSet = entityDef?.syncFields\r\n                    ? new Set(entityDef.syncFields)\r\n                    : null;\r\n                typeSyncFields.set(type, syncFieldsSet!);\r\n\r\n                // Build schema for this type (only synced fields)\r\n                const typeSchema: [string, string[]][] = [];\r\n                for (const comp of entity.getComponents()) {\r\n                    const fieldsToSync = syncFieldsSet\r\n                        ? comp.fieldNames.filter(f => syncFieldsSet.has(f))\r\n                        : comp.fieldNames;\r\n                    if (fieldsToSync.length > 0) {\r\n                        typeSchema.push([comp.name, fieldsToSync]);\r\n                    }\r\n                }\r\n                schema.push(typeSchema);\r\n            }\r\n\r\n            // Encode values as flat array matching schema order (only synced fields)\r\n            const syncFieldsSet = typeSyncFields.get(type);\r\n            const values: any[] = [];\r\n            for (const comp of entity.getComponents()) {\r\n                for (const fieldName of comp.fieldNames) {\r\n                    // Only include if no syncFields defined OR field is in syncFields\r\n                    if (!syncFieldsSet || syncFieldsSet.has(fieldName)) {\r\n                        values.push(comp.storage.fields[fieldName][index]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            entities.push([\r\n                entity.eid,  // eid as number (no need for hex conversion)\r\n                typeToIndex.get(type)!,  // type INDEX (1 byte) instead of string\r\n                values\r\n            ]);\r\n        }\r\n\r\n        // Compute minimal ID allocator state from entities\r\n        let maxIndex = 0;\r\n        const activeGenerations: Record<number, number> = {};\r\n        for (const e of entities) {\r\n            const eid = e[0];\r\n            const index = eid & INDEX_MASK;\r\n            const gen = eid >>> 20;\r\n            if (index >= maxIndex) maxIndex = index + 1;\r\n            activeGenerations[index] = gen;\r\n        }\r\n\r\n        return {\r\n            frame: this.currentFrame,\r\n            seq: this.lastInputSeq,\r\n            format: 5, // Format 5: type-indexed compact encoding\r\n            types,     // Type names array (sent once)\r\n            schema,    // Component schemas indexed by type index\r\n            entities,  // Array of [eid, typeIndex, values[]]\r\n            idAllocatorState: {\r\n                nextIndex: maxIndex,\r\n                freeList: [],\r\n                generations: activeGenerations\r\n            },\r\n            rng: saveRandomState(),\r\n            strings: this.world.strings.getState(),\r\n            clientIdMap: {\r\n                toNum: Object.fromEntries(this.clientIdToNum),\r\n                nextNum: this.nextClientNum\r\n            },\r\n            inputState: this.world.getInputState()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Load network snapshot into ECS world.\r\n     */\r\n    private loadNetworkSnapshot(snapshot: any): void {\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Loading snapshot: ${snapshot.entities?.length} entities`);\r\n        }\r\n\r\n        // Reset world FIRST (clears everything including ID allocator and strings)\r\n        this.world.reset();\r\n\r\n        // CRITICAL: Clear physics state before recreating entities\r\n        // Without this, old physics bodies with stale state (positions, sleeping, etc.)\r\n        // would be reused when entities are recreated with the same eids\r\n        if (this.physics) {\r\n            this.physics.clear();\r\n        }\r\n\r\n        // Restore RNG state\r\n        if (snapshot.rng) {\r\n            loadRandomState(snapshot.rng);\r\n        }\r\n\r\n        // Restore strings AFTER reset\r\n        if (snapshot.strings) {\r\n            this.world.strings.setState(snapshot.strings);\r\n        }\r\n\r\n        // Restore clientId interning\r\n        if (snapshot.clientIdMap) {\r\n            this.clientIdToNum = new Map(Object.entries(snapshot.clientIdMap.toNum).map(([k, v]) => [k, v as number]));\r\n            this.numToClientId = new Map(Array.from(this.clientIdToNum.entries()).map(([k, v]) => [v, k]));\r\n            this.nextClientNum = snapshot.clientIdMap.nextNum || 1;\r\n        }\r\n\r\n        // Format 5: type-indexed encoding\r\n        const types = snapshot.types;\r\n        const schema = snapshot.schema;\r\n        const entitiesData = snapshot.entities;\r\n\r\n        // Track loaded entities by type for onRestore callbacks\r\n        const loadedEntitiesByType = new Map<string, Entity[]>();\r\n\r\n        for (const entityData of entitiesData) {\r\n            const [eid, typeIndex, values] = entityData;\r\n            const type = types[typeIndex];\r\n            const typeSchema = schema[typeIndex];\r\n\r\n            // Spawn entity with specific eid\r\n            let entity;\r\n            try {\r\n                entity = this.world.spawnWithId(type, eid, {});\r\n            } catch (e) {\r\n                console.warn(`[ecs] Failed to spawn ${type} with eid ${eid}:`, e);\r\n                continue;\r\n            }\r\n\r\n            // Track for onRestore callback\r\n            if (!loadedEntitiesByType.has(type)) {\r\n                loadedEntitiesByType.set(type, []);\r\n            }\r\n            loadedEntitiesByType.get(type)!.push(entity);\r\n\r\n            // Restore values using schema\r\n            const index = eid & INDEX_MASK;\r\n            let valueIdx = 0;\r\n\r\n            for (const [compName, fieldNames] of typeSchema) {\r\n                // Find component on entity\r\n                for (const comp of entity.getComponents()) {\r\n                    if (comp.name === compName) {\r\n                        for (const fieldName of fieldNames) {\r\n                            comp.storage.fields[fieldName][index] = values[valueIdx++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // CRITICAL: Update clientIdIndex for Player entities after component restore\r\n            // The spawnWithId call above didn't have clientId in props, so the index wasn't set\r\n            if (entity.has(Player)) {\r\n                const player = entity.get(Player);\r\n                if (player.clientId !== 0) {\r\n                    this.world.setEntityClientId(entity.eid, player.clientId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Call onRestore callbacks for entity types that have them\r\n        // This allows reconstructing non-synced fields from synced data\r\n        for (const [type, entities] of loadedEntitiesByType) {\r\n            const entityDef = this.world.getEntityDef(type);\r\n            if (entityDef?.onRestore) {\r\n                for (const entity of entities) {\r\n                    entityDef.onRestore(entity, this);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Restore input sequence\r\n        this.lastInputSeq = snapshot.seq || 0;\r\n\r\n        // Restore ID allocator state for proper future allocations\r\n        // Format 3+: minimal format with generations as object { index: gen }\r\n        // Format 2-: full format with generations as array\r\n        if (snapshot.idAllocatorState) {\r\n            const state = snapshot.idAllocatorState;\r\n            if (snapshot.format >= 3 && typeof state.generations === 'object' && !Array.isArray(state.generations)) {\r\n                // Minimal format - reconstruct full state\r\n                this.world.idAllocator.reset();\r\n                this.world.idAllocator.setNextId(state.nextIndex);\r\n                // Set generations for active entities\r\n                for (const [indexStr, gen] of Object.entries(state.generations)) {\r\n                    const index = parseInt(indexStr, 10);\r\n                    (this.world.idAllocator as any).generations[index] = gen;\r\n                }\r\n                // Compute free list: indices from 0 to nextIndex that aren't in active generations\r\n                const freeList: number[] = [];\r\n                for (let i = 0; i < state.nextIndex; i++) {\r\n                    if (!(i.toString() in state.generations)) {\r\n                        freeList.push(i);\r\n                    }\r\n                }\r\n                (this.world.idAllocator as any).freeList = freeList;\r\n            } else {\r\n                // Legacy full format\r\n                this.world.idAllocator.setState(state);\r\n            }\r\n        }\r\n\r\n        // Track which clients already have entities from the snapshot\r\n        // This prevents duplicate entity creation during catchup\r\n        this.clientsWithEntitiesFromSnapshot.clear();\r\n        for (const entity of this.world.query(Player)) {\r\n            const player = entity.get(Player);\r\n            if (player.clientId !== 0) {\r\n                const clientIdStr = this.getClientIdString(player.clientId);\r\n                if (clientIdStr) {\r\n                    this.clientsWithEntitiesFromSnapshot.add(clientIdStr);\r\n                    if (DEBUG_NETWORK) {\r\n                        console.log(`[ecs] Snapshot has entity for client ${clientIdStr.slice(0, 8)}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // CRITICAL: Wake all physics bodies after snapshot restore\r\n        // Without this, late joiners have awake bodies while existing clients may have\r\n        // sleeping bodies, causing physics simulation divergence after catchup\r\n        if (this.physics) {\r\n            this.physics.wakeAllBodies();\r\n        }\r\n\r\n        // CRITICAL: Restore input state so movement systems behave identically\r\n        // Without this, systems that check `game.world.getInput(clientId)` won't find\r\n        // the last input, causing movement to stop on late joiners while authority continues\r\n        if (snapshot.inputState) {\r\n            this.world.setInputState(snapshot.inputState);\r\n        }\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Snapshot loaded: ${this.world.getAllEntities().length} entities, hash=${this.getStateHash()}`);\r\n            // Debug: log first restored entity\r\n            const firstEntity = this.world.getAllEntities()[0];\r\n            if (firstEntity) {\r\n                const components: Record<string, Record<string, any>> = {};\r\n                for (const comp of firstEntity.getComponents()) {\r\n                    const data: Record<string, any> = {};\r\n                    for (const fieldName of comp.fieldNames) {\r\n                        data[fieldName] = (firstEntity.get(comp) as any)[fieldName];\r\n                    }\r\n                    components[comp.name] = data;\r\n                }\r\n                console.log(`[ecs] Restored first entity: type=${firstEntity.type}, components=`, JSON.stringify(components));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send snapshot to network.\r\n     */\r\n    private sendSnapshot(source: string): void {\r\n        if (!this.connection) return;\r\n\r\n        // CRITICAL: Wake all physics bodies when sending snapshot\r\n        // This ensures the authority's bodies are in the same state as the late joiner's\r\n        // bodies will be after they restore and wake. Without this, authority has sleeping\r\n        // bodies while late joiner has awake bodies, causing physics divergence.\r\n        if (this.physics) {\r\n            this.physics.wakeAllBodies();\r\n        }\r\n\r\n        const snapshot = this.getNetworkSnapshot();\r\n        const hash = this.world.getStateHash();\r\n        const binary = encode({ snapshot, hash });\r\n\r\n        // DEBUG: Log snapshot size breakdown\r\n        const entitiesSize = encode(snapshot.entities).length;\r\n        const schemaSize = encode(snapshot.schema).length;\r\n        const entityCount = snapshot.entities.length;\r\n        console.log(`[SNAPSHOT-SIZE] Total: ${binary.length}B | entities: ${entitiesSize}B (${entityCount}) | schema: ${schemaSize}B`);\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Sending snapshot (${source}): ${binary.length} bytes, ${entityCount} entities, hash=${hash}`);\r\n        }\r\n\r\n        this.connection.sendSnapshot(binary, hash, snapshot.seq, snapshot.frame);\r\n\r\n        // Update debug UI tracking - show last SENT snapshot for authority\r\n        this.lastSnapshotHash = hash;\r\n        this.lastSnapshotFrame = snapshot.frame;\r\n        this.lastSnapshotSize = binary.length;\r\n        this.lastSnapshotEntityCount = entityCount;\r\n    }\r\n\r\n    /**\r\n     * Handle server snapshot (for drift detection).\r\n     */\r\n    private handleServerSnapshot(data: Uint8Array): void {\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Received server snapshot: ${data.length} bytes`);\r\n        }\r\n\r\n        // Decode and compare for drift detection\r\n        try {\r\n            const decoded = decode(data);\r\n            const serverSnapshot = decoded?.snapshot;\r\n            const serverHash = decoded?.hash;\r\n\r\n            if (serverSnapshot) {\r\n                this.lastSnapshotHash = serverHash;\r\n                this.lastSnapshotFrame = serverSnapshot.frame;\r\n                this.lastSnapshotSize = data.length;\r\n                this.lastSnapshotEntityCount = serverSnapshot.entities?.length || 0;\r\n\r\n                // Only compare if frames match - otherwise comparison is meaningless\r\n                if (this.currentFrame === serverSnapshot.frame) {\r\n                    // Field-by-field comparison for drift stats\r\n                    this.compareSnapshotFields(serverSnapshot);\r\n\r\n                    // Compare hashes\r\n                    const localHash = this.getStateHash();\r\n                    if (localHash !== serverHash) {\r\n                        console.warn(`[ecs] DRIFT detected at frame ${serverSnapshot.frame}: local=${localHash}, server=${serverHash}`);\r\n                    }\r\n                } else {\r\n                    // Frames don't match - skip comparison (would give false positives)\r\n                    // Reset drift stats since we can't validate\r\n                    this.driftStats = {\r\n                        determinismPercent: 100,\r\n                        totalChecks: 0,\r\n                        matchingFieldCount: 0,\r\n                        totalFieldCount: 0\r\n                    };\r\n                }\r\n            }\r\n        } catch (e) {\r\n            console.warn('[ecs] Failed to decode server snapshot:', e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compare server snapshot fields with local state for drift tracking.\r\n     */\r\n    private compareSnapshotFields(serverSnapshot: any): void {\r\n        const frame = serverSnapshot.frame;\r\n        let matchingFields = 0;\r\n        let totalFields = 0;\r\n        const diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }> = [];\r\n\r\n        // Store server snapshot for debugging\r\n        this.lastServerSnapshot = { raw: null, decoded: serverSnapshot, frame };\r\n\r\n        const types = serverSnapshot.types || [];\r\n        const serverEntities = serverSnapshot.entities || [];\r\n        const schema = serverSnapshot.schema || [];\r\n\r\n        // Build map of server entities by eid (numeric)\r\n        const serverEntityMap = new Map<number, any>();\r\n        for (const e of serverEntities) {\r\n            serverEntityMap.set(e[0], e);\r\n        }\r\n\r\n        // Compare each local entity with server entity\r\n        for (const entity of this.world.getAllEntities()) {\r\n            const eid = entity.eid;\r\n            const serverEntity = serverEntityMap.get(eid);\r\n            const index = eid & INDEX_MASK;\r\n\r\n            if (!serverEntity) {\r\n                for (const comp of entity.getComponents()) {\r\n                    totalFields += comp.fieldNames.length;\r\n                    for (const fieldName of comp.fieldNames) {\r\n                        diffs.push({ entity: entity.type, eid, comp: comp.name, field: fieldName, local: 'EXISTS', server: 'MISSING' });\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const [, typeIndex, serverValues] = serverEntity;\r\n            const typeSchema = schema[typeIndex];\r\n\r\n            if (!typeSchema) continue;\r\n\r\n            let valueIdx = 0;\r\n            for (const [compName, fieldNames] of typeSchema) {\r\n                const localComp = entity.getComponents().find(c => c.name === compName);\r\n\r\n                for (const fieldName of fieldNames) {\r\n                    totalFields++;\r\n                    const serverValue = serverValues[valueIdx++];\r\n\r\n                    if (localComp) {\r\n                        const localValue = localComp.storage.fields[fieldName][index];\r\n                        const fieldDef = localComp.schema[fieldName];\r\n\r\n                        let valuesMatch = false;\r\n                        if (fieldDef?.type === 'bool') {\r\n                            const localBool = localValue !== 0;\r\n                            const serverBool = serverValue !== 0 && serverValue !== false;\r\n                            valuesMatch = localBool === serverBool;\r\n                        } else {\r\n                            valuesMatch = localValue === serverValue;\r\n                        }\r\n\r\n                        if (valuesMatch) {\r\n                            matchingFields++;\r\n                        } else {\r\n                            diffs.push({ entity: entity.type, eid, comp: compName, field: fieldName, local: localValue, server: serverValue });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Count server entities not in local state\r\n        for (const [eid, serverEntity] of serverEntityMap) {\r\n            if (this.world.getEntity(eid) === null) {\r\n                const [, typeIndex, serverValues] = serverEntity;\r\n                const serverType = types[typeIndex] || `type${typeIndex}`;\r\n                totalFields += serverValues.length;\r\n                diffs.push({ entity: serverType, eid, comp: '*', field: '*', local: 'MISSING', server: 'EXISTS' });\r\n            }\r\n        }\r\n\r\n        const newPercent = totalFields > 0 ? (matchingFields / totalFields) * 100 : 100;\r\n        const wasSync = this.lastSyncPercent === 100;\r\n        const isSync = newPercent === 100;\r\n\r\n        // Store good snapshot when 100% sync\r\n        if (isSync) {\r\n            this.lastGoodSnapshot = {\r\n                snapshot: JSON.parse(JSON.stringify(serverSnapshot)),\r\n                frame: frame,\r\n                hash: this.getStateHash()\r\n            };\r\n        }\r\n\r\n        // First divergence - capture debug data and auto-show\r\n        if (wasSync && !isSync && !this.divergenceCaptured) {\r\n            this.firstDivergenceFrame = frame;\r\n            this.divergenceHistory = [];\r\n            this.divergenceCaptured = true;\r\n\r\n            const lastGoodFrame = this.lastGoodSnapshot?.frame ?? 0;\r\n            const inputsInRange = this.recentInputs.filter(i => i.frame > lastGoodFrame && i.frame <= frame);\r\n            const localSnapshot = this.world.getState();\r\n\r\n            this.divergenceCapture = {\r\n                lastGoodSnapshot: this.lastGoodSnapshot?.snapshot ?? null,\r\n                lastGoodFrame: lastGoodFrame,\r\n                inputs: inputsInRange,\r\n                localSnapshot: localSnapshot,\r\n                serverSnapshot: serverSnapshot,\r\n                diffs: diffs,\r\n                divergenceFrame: frame,\r\n                clientId: this.localClientIdStr,\r\n                isAuthority: this.checkIsAuthority()\r\n            };\r\n\r\n            this.showDivergenceDiff(diffs, inputsInRange, frame);\r\n        }\r\n\r\n        this.lastSyncPercent = newPercent;\r\n\r\n        // Update drift stats\r\n        this.driftStats.totalChecks++;\r\n        this.driftStats.matchingFieldCount = matchingFields;\r\n        this.driftStats.totalFieldCount = totalFields;\r\n        this.driftStats.determinismPercent = newPercent;\r\n\r\n        // Sparse ongoing divergence log (every 60 frames)\r\n        if (diffs.length > 0 && newPercent < 100 && this.divergenceCaptured && frame % 60 === 0) {\r\n            console.warn(`[DIVERGENCE] Frame ${frame}: still diverged (${newPercent.toFixed(1)}% sync, first at ${this.firstDivergenceFrame})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show divergence debug data (auto-called on first divergence).\r\n     */\r\n    private showDivergenceDiff(\r\n        diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }>,\r\n        inputs: Array<{ frame: number; seq: number; clientId: string; data: any }>,\r\n        frame: number\r\n    ): void {\r\n        const lines: string[] = [];\r\n        const lastGoodFrame = this.lastGoodSnapshot?.frame ?? 0;\r\n\r\n        lines.push(`=== DIVERGENCE DEBUG DATA ===`);\r\n        lines.push(`Frame: ${frame} | Last good: ${lastGoodFrame} | Client: ${this.localClientIdStr?.slice(0, 8)} | Authority: ${this.checkIsAuthority()}`);\r\n        lines.push(``);\r\n\r\n        lines.push(`DIVERGENT FIELDS (${diffs.length}):`);\r\n        for (const d of diffs) {\r\n            const delta = typeof d.local === 'number' && typeof d.server === 'number'\r\n                ? ` \u0394${d.local - d.server}`\r\n                : '';\r\n            lines.push(`  ${d.entity}#${d.eid.toString(16)}.${d.comp}.${d.field}: local=${d.local} server=${d.server}${delta}`);\r\n        }\r\n        lines.push(``);\r\n\r\n        lines.push(`INPUTS (${inputs.length}):`);\r\n        for (const input of inputs) {\r\n            lines.push(`  f${input.frame} ${input.clientId.slice(0, 8)}: ${JSON.stringify(input.data)}`);\r\n        }\r\n        lines.push(``);\r\n\r\n        if (this.lastGoodSnapshot) {\r\n            const goodEnts = Object.keys(this.lastGoodSnapshot.snapshot.entities || {}).length;\r\n            lines.push(`LAST GOOD SNAPSHOT (f${lastGoodFrame}): ${goodEnts} entities`);\r\n        } else {\r\n            lines.push(`LAST GOOD SNAPSHOT: none (never had 100% sync)`);\r\n        }\r\n\r\n        if (this.lastServerSnapshot.decoded) {\r\n            const serverEnts = Object.keys(this.lastServerSnapshot.decoded.entities || {}).length;\r\n            lines.push(`SERVER SNAPSHOT (f${this.lastServerSnapshot.frame}): ${serverEnts} entities`);\r\n        }\r\n\r\n        lines.push(`=== END DEBUG DATA ===`);\r\n        lines.push(`To get detailed replay data: game.getDivergenceReplay()`);\r\n\r\n        console.error(lines.join('\\n'));\r\n    }\r\n\r\n    /**\r\n     * Download divergence replay data as JSON.\r\n     */\r\n    getDivergenceReplay(): void {\r\n        if (!this.divergenceCapture) {\r\n            console.warn('[REPLAY] No divergence captured yet.');\r\n            return;\r\n        }\r\n\r\n        const json = JSON.stringify(this.divergenceCapture, null, 2);\r\n        const blob = new Blob([json], { type: 'application/json' });\r\n        const url = URL.createObjectURL(blob);\r\n\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = `divergence-${this.divergenceCapture.divergenceFrame}.json`;\r\n        document.body.appendChild(a);\r\n        a.click();\r\n        document.body.removeChild(a);\r\n        URL.revokeObjectURL(url);\r\n\r\n        console.log(`[REPLAY] Downloaded (${(json.length / 1024).toFixed(1)} KB)`);\r\n    }\r\n\r\n    // ==========================================\r\n    // Game Loop\r\n    // ==========================================\r\n\r\n    /**\r\n     * Start the render loop.\r\n     */\r\n    private startGameLoop(): void {\r\n        if (this.gameLoop) return;\r\n\r\n        let lastSnapshotFrame = 0;\r\n        const SNAPSHOT_INTERVAL = 100; // Every 5 seconds at 20fps\r\n\r\n        const loop = () => {\r\n            // Render\r\n            if (this.renderer?.render) {\r\n                this.renderer.render();\r\n            } else if (this.callbacks.render) {\r\n                this.callbacks.render();\r\n            }\r\n\r\n            // Periodic snapshot upload (authority only)\r\n            if (this.checkIsAuthority() && this.currentFrame - lastSnapshotFrame >= SNAPSHOT_INTERVAL) {\r\n                this.sendSnapshot('loop');\r\n                lastSnapshotFrame = this.currentFrame;\r\n            }\r\n\r\n            this.gameLoop = requestAnimationFrame(loop);\r\n        };\r\n\r\n        this.gameLoop = requestAnimationFrame(loop);\r\n    }\r\n\r\n    /**\r\n     * Stop the render loop.\r\n     */\r\n    private stopGameLoop(): void {\r\n        if (this.gameLoop) {\r\n            cancelAnimationFrame(this.gameLoop);\r\n            this.gameLoop = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle disconnect.\r\n     */\r\n    private handleDisconnect(): void {\r\n        if (DEBUG_NETWORK) console.log('[ecs] Disconnected');\r\n        this.stopGameLoop();\r\n    }\r\n\r\n    // ==========================================\r\n    // Utility Methods\r\n    // ==========================================\r\n\r\n    /**\r\n     * Check if this client is the authority.\r\n     * Handles potential length mismatch between SDK and server client IDs.\r\n     */\r\n    checkIsAuthority(): boolean {\r\n        if (this.localClientIdStr === null || this.authorityClientId === null) {\r\n            return false;\r\n        }\r\n        // Server may send shorter client IDs, compare by prefix\r\n        const minLen = Math.min(this.localClientIdStr.length, this.authorityClientId.length);\r\n        return this.localClientIdStr.substring(0, minLen) === this.authorityClientId.substring(0, minLen);\r\n    }\r\n\r\n    /**\r\n     * Check if this client is the authority (public).\r\n     */\r\n    isAuthority(): boolean {\r\n        return this.checkIsAuthority();\r\n    }\r\n\r\n    /**\r\n     * Check if connected.\r\n     */\r\n    isConnected(): boolean {\r\n        return this.connection !== null;\r\n    }\r\n\r\n    /**\r\n     * Get current frame.\r\n     */\r\n    getFrame(): number {\r\n        return this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Get server tick rate.\r\n     */\r\n    getServerFps(): number {\r\n        return this.serverFps;\r\n    }\r\n\r\n    /**\r\n     * Get render interpolation alpha (0-1).\r\n     */\r\n    getRenderAlpha(): number {\r\n        if (this.lastTickTime === 0) return 1;\r\n        const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\r\n        const elapsed = now - this.lastTickTime;\r\n        return Math.min(elapsed / this.tickIntervalMs, 1.0);\r\n    }\r\n\r\n    /**\r\n     * Send input to network.\r\n     */\r\n    sendInput(input: any): void {\r\n        if (!this.connection) return;\r\n        const binary = encode(input);\r\n        this.connection.send(binary);\r\n    }\r\n\r\n    /**\r\n     * Leave current room.\r\n     */\r\n    leaveRoom(): void {\r\n        if (this.connection) {\r\n            this.connection.leaveRoom();\r\n            this.connection = null;\r\n            this.stopGameLoop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get local client ID.\r\n     */\r\n    get localClientId(): string | null {\r\n        return this.localClientIdStr;\r\n    }\r\n\r\n    /**\r\n     * Set local client ID.\r\n     */\r\n    setLocalClientId(clientId: string): void {\r\n        this.localClientIdStr = clientId;\r\n        const numId = this.internClientId(clientId);\r\n        this.world.localClientId = numId;\r\n    }\r\n\r\n    /**\r\n     * Get room ID.\r\n     */\r\n    getRoomId(): string | null {\r\n        return this.connectedRoomId;\r\n    }\r\n\r\n    /**\r\n     * Get last snapshot info.\r\n     */\r\n    getLastSnapshot(): { hash: string | null; frame: number; size: number; entityCount: number } {\r\n        return {\r\n            hash: this.lastSnapshotHash,\r\n            frame: this.lastSnapshotFrame,\r\n            size: this.lastSnapshotSize,\r\n            entityCount: this.lastSnapshotEntityCount\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get connected clients.\r\n     */\r\n    getClients(): string[] {\r\n        return this.connectedClients;\r\n    }\r\n\r\n    /**\r\n     * Get client ID (for debug UI).\r\n     */\r\n    getClientId(): string | null {\r\n        return this.localClientIdStr;\r\n    }\r\n\r\n    /**\r\n     * Get node URL (for debug UI).\r\n     */\r\n    getNodeUrl(): string | null {\r\n        // Could be tracked from connection, for now return null\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get upload rate in bytes/second (for debug UI).\r\n     */\r\n    getUploadRate(): number {\r\n        return this.connection?.bandwidthOut || 0;\r\n    }\r\n\r\n    /**\r\n     * Get download rate in bytes/second (for debug UI).\r\n     */\r\n    getDownloadRate(): number {\r\n        return this.connection?.bandwidthIn || 0;\r\n    }\r\n\r\n    /**\r\n     * Get drift stats (for debug UI).\r\n     * Authority clients show 100% until they receive a comparison snapshot.\r\n     */\r\n    getDriftStats(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number } {\r\n        // If no snapshots have been compared yet, assume 100% sync\r\n        // Authority clients are the source of truth, so they're always \"in sync\"\r\n        if (this.driftStats.totalChecks === 0) {\r\n            const entityCount = this.world.getAllEntities().length;\r\n            // Estimate total fields from local entities if no comparison done yet\r\n            let estimatedFields = 0;\r\n            for (const entity of this.world.getAllEntities()) {\r\n                for (const comp of entity.getComponents()) {\r\n                    estimatedFields += comp.fieldNames.length;\r\n                }\r\n            }\r\n            return {\r\n                determinismPercent: 100,\r\n                totalChecks: 0,\r\n                matchingFieldCount: estimatedFields,\r\n                totalFieldCount: estimatedFields\r\n            };\r\n        }\r\n        return { ...this.driftStats };\r\n    }\r\n\r\n    /**\r\n     * Attach a renderer.\r\n     */\r\n    setRenderer(renderer: any): void {\r\n        this.renderer = renderer;\r\n    }\r\n\r\n    /**\r\n     * Get canvas from attached renderer.\r\n     */\r\n    getCanvas(): HTMLCanvasElement | null {\r\n        return this.renderer?.element ?? null;\r\n    }\r\n}\r\n\r\n// ==========================================\r\n// GameEntityBuilder\r\n// ==========================================\r\n\r\n/**\r\n * Game-specific entity builder with fluent API.\r\n */\r\nexport class GameEntityBuilder {\r\n    private worldBuilder: EntityBuilder;\r\n    private inputCommandsDef: any = null;\r\n\r\n    constructor(\r\n        private game: Game,\r\n        private name: string\r\n    ) {\r\n        this.worldBuilder = game.world.defineEntity(name);\r\n    }\r\n\r\n    /**\r\n     * Add a component to the entity definition.\r\n     */\r\n    with<T extends Record<string, any>>(\r\n        component: ComponentType<T>,\r\n        defaults?: Partial<T>\r\n    ): this {\r\n        this.worldBuilder.with(component, defaults);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Define input commands for this entity type.\r\n     */\r\n    commands(def: any): this {\r\n        this.inputCommandsDef = def;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specify which fields to sync in snapshots (field-level sync).\r\n     * Only the specified fields are included in network snapshots.\r\n     *\r\n     * Use this to reduce bandwidth by only syncing essential fields.\r\n     * Non-synced fields can be reconstructed via onRestore().\r\n     *\r\n     * @example\r\n     * game.defineEntity('snake-segment')\r\n     *     .with(Transform2D)\r\n     *     .with(Sprite)\r\n     *     .with(SnakeSegment)\r\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\r\n     *     .register();\r\n     */\r\n    syncOnly(fields: string[]): this {\r\n        this.worldBuilder._setSyncFields(fields);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Exclude all fields from syncing for this entity type.\r\n     * The entity will not be included in network snapshots at all.\r\n     *\r\n     * Use this for purely client-local entities like cameras, UI, or effects.\r\n     *\r\n     * @example\r\n     * game.defineEntity('local-camera')\r\n     *     .with(Camera2D)\r\n     *     .syncNone()\r\n     *     .register();\r\n     */\r\n    syncNone(): this {\r\n        this.worldBuilder._setSyncFields([]);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use syncOnly() instead for clarity\r\n     */\r\n    sync(fields: string[]): this {\r\n        return this.syncOnly(fields);\r\n    }\r\n\r\n    /**\r\n     * Set a callback to reconstruct non-synced fields after snapshot load.\r\n     * Called for each entity of this type after loading a snapshot.\r\n     *\r\n     * @example\r\n     * game.defineEntity('snake-segment')\r\n     *     .with(Transform2D)\r\n     *     .with(Sprite)\r\n     *     .with(SnakeSegment)\r\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\r\n     *     .onRestore((entity, game) => {\r\n     *         const owner = game.world.getEntityByClientId(entity.get(SnakeSegment).ownerId);\r\n     *         if (owner) {\r\n     *             entity.get(Sprite).color = owner.get(Sprite).color;\r\n     *             entity.get(Sprite).radius = SEGMENT_RADIUS;\r\n     *         }\r\n     *     })\r\n     *     .register();\r\n     */\r\n    onRestore(callback: (entity: Entity, game: Game) => void): this {\r\n        this.worldBuilder._setOnRestore(callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Finalize and register the entity definition.\r\n     */\r\n    register(): Prefab {\r\n        this.worldBuilder._ensureRegistered();\r\n        return this.game._registerPrefab(this.name, this.worldBuilder);\r\n    }\r\n}\r\n\r\n// ==========================================\r\n// Factory Function\r\n// ==========================================\r\n\r\n/**\r\n * Initialize a new game instance.\r\n */\r\nexport function createGame(): Game {\r\n    return new Game();\r\n}\r\n", "/**\n * Simple2DRenderer - Basic 2D canvas renderer for entities with Sprite component\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Sprite, Camera2D, SHAPE_RECT, SHAPE_CIRCLE, SPRITE_IMAGE } from '../components';\n\nexport interface Simple2DRendererOptions {\n    /** Background color (default: '#111') */\n    background?: string;\n    /** Whether to clear canvas each frame (default: true) */\n    autoClear?: boolean;\n}\n\n/**\n * Simple 2D renderer that draws all entities with Sprite component.\n *\n * Can be used as a plugin via game.addPlugin() or standalone.\n *\n * @example\n * // Plugin pattern (recommended)\n * game.addPlugin(Simple2DRenderer, canvas);\n *\n * // Standalone pattern\n * new Simple2DRenderer(game, canvas);\n */\nexport class Simple2DRenderer {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    private game: Game;\n    private options: Required<Simple2DRendererOptions>;\n    private imageCache: Map<string, HTMLImageElement> = new Map();\n    private _cameraEntity: Entity | null = null;\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string, options: Simple2DRendererOptions = {}) {\n        this.game = game;\n\n        // Accept either element or selector\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) throw new Error('Could not get 2d context');\n        this.ctx = ctx;\n\n        this.options = {\n            background: options.background ?? '#111',\n            autoClear: options.autoClear ?? true\n        };\n\n        // Attach to game\n        game.setRenderer(this);\n    }\n\n    /** Canvas width */\n    get width(): number { return this.canvas.width; }\n\n    /** Canvas height */\n    get height(): number { return this.canvas.height; }\n\n    /** The canvas element */\n    get element(): HTMLCanvasElement { return this.canvas; }\n\n    /** The 2D context (for custom drawing) */\n    get context(): CanvasRenderingContext2D { return this.ctx; }\n\n    /**\n     * Set the camera entity to use for rendering.\n     * When set, the renderer will apply camera transform (position, zoom).\n     */\n    set camera(entity: Entity | null) {\n        this._cameraEntity = entity;\n        if (entity) {\n            // Update viewport size in camera component\n            try {\n                const cam = entity.get(Camera2D);\n                cam.viewportWidth = this.canvas.width;\n                cam.viewportHeight = this.canvas.height;\n            } catch {\n                // Entity doesn't have Camera2D\n            }\n        }\n    }\n\n    get camera(): Entity | null {\n        return this._cameraEntity;\n    }\n\n    /**\n     * Render all entities with Sprite component.\n     */\n    render(): void {\n        const { ctx, canvas, options, game } = this;\n\n        // Clear\n        if (options.autoClear) {\n            ctx.fillStyle = options.background;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Get interpolation alpha (0-1 between physics ticks)\n        const alpha = game.getRenderAlpha();\n\n        // Get camera data if available\n        let camX = 0, camY = 0, camZoom = 1;\n        if (this._cameraEntity && !this._cameraEntity.destroyed) {\n            try {\n                const cam = this._cameraEntity.get(Camera2D);\n                camX = cam.x;\n                camY = cam.y;\n                camZoom = cam.zoom;\n\n                // Update viewport size in case canvas was resized\n                cam.viewportWidth = canvas.width;\n                cam.viewportHeight = canvas.height;\n            } catch {\n                // Camera entity doesn't have Camera2D\n            }\n        }\n\n        // Collect entities with Sprite, sorted by layer\n        const entities: Array<{ entity: any; layer: number }> = [];\n\n        for (const entity of game.getAllEntities()) {\n            // Skip destroyed entities\n            if (entity.destroyed) continue;\n\n            try {\n                const sprite = entity.get(Sprite);\n                if (sprite && sprite.visible) {\n                    // Calculate interpolated position for smooth rendering\n                    entity.interpolate(alpha);\n                    entities.push({ entity, layer: sprite.layer });\n                }\n            } catch {\n                // Entity doesn't have Sprite\n            }\n        }\n\n        // Sort by layer (lower first)\n        entities.sort((a, b) => a.layer - b.layer);\n\n        // Apply camera transform\n        ctx.save();\n        ctx.translate(canvas.width / 2, canvas.height / 2);\n        ctx.scale(camZoom, camZoom);\n        ctx.translate(-camX, -camY);\n\n        // Draw each entity\n        for (const { entity } of entities) {\n            this.drawEntity(entity);\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Draw a single entity.\n     */\n    private drawEntity(entity: any): void {\n        const { ctx, game } = this;\n\n        const sprite = entity.get(Sprite);\n\n        // Use interpolated position for smooth rendering between physics ticks\n        const x = entity.render.interpX + sprite.offsetX;\n        const y = entity.render.interpY + sprite.offsetY;\n        const scaleX = sprite.scaleX;\n        const scaleY = sprite.scaleY;\n\n        // Get color string\n        const colorStr = game.getString('color', sprite.color) || '#fff';\n\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.scale(scaleX, scaleY);\n\n        const shape = sprite.shape;\n\n        if (shape === SHAPE_CIRCLE) {\n            const radius = sprite.radius;\n            ctx.fillStyle = colorStr;\n            ctx.beginPath();\n            ctx.arc(0, 0, radius, 0, Math.PI * 2);\n            ctx.fill();\n        } else if (shape === SHAPE_RECT) {\n            const w = sprite.width;\n            const h = sprite.height;\n            ctx.fillStyle = colorStr;\n            ctx.fillRect(-w / 2, -h / 2, w, h);\n        } else if (shape === SPRITE_IMAGE) {\n            const imageId = game.getString('sprite', sprite.spriteId);\n            if (imageId) {\n                const img = this.getImage(imageId);\n                if (img && img.complete) {\n                    const w = sprite.width || img.width;\n                    const h = sprite.height || img.height;\n                    ctx.drawImage(img, -w / 2, -h / 2, w, h);\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Get or load an image.\n     */\n    private getImage(src: string): HTMLImageElement | null {\n        let img = this.imageCache.get(src);\n        if (!img) {\n            img = new Image();\n            img.src = src;\n            this.imageCache.set(src, img);\n        }\n        return img;\n    }\n\n    /**\n     * Preload images for faster rendering.\n     */\n    preload(images: string[]): Promise<void> {\n        return Promise.all(\n            images.map(src => new Promise<void>((resolve) => {\n                const img = this.getImage(src);\n                if (img?.complete) {\n                    resolve();\n                } else if (img) {\n                    img.onload = () => resolve();\n                    img.onerror = () => resolve();\n                }\n            }))\n        ).then(() => {});\n    }\n}\n", "/**\n * InputPlugin - Handles input collection and network sending\n *\n * Provides an action-based input system where:\n * - Game defines actions with default bindings\n * - Players can rebind actions to different keys\n * - Input is automatically sent to server at tick rate\n *\n * @example\n * const input = game.addPlugin(InputPlugin, canvas);\n *\n * input.action('move', { type: 'vector', bindings: ['keys:wasd+arrows'] });\n * input.action('boost', { type: 'button', bindings: ['key:shift'] });\n * input.action('target', { type: 'vector', bindings: ['mouse'] });\n *\n * // Player rebinds\n * input.rebind('boost', ['key:space']);\n *\n * // Save/load\n * localStorage.setItem('keybinds', JSON.stringify(input.getBindings()));\n * input.loadBindings(JSON.parse(localStorage.getItem('keybinds')));\n */\n\nimport { Game } from '../game';\n\n// Forward declaration to avoid circular import\ninterface GameLike {\n    isConnected(): boolean;\n    localClientId: string | null;\n    sendInput(input: any): void;\n    getServerFps(): number;\n}\n\n/** Action types */\nexport type ActionType = 'button' | 'vector';\n\n/** Binding source - string shorthand or custom callback */\nexport type BindingSource = string | (() => any);\n\n/** Action definition */\nexport interface ActionDef {\n    type: ActionType;\n    bindings: BindingSource[];\n}\n\n/** Vector value */\nexport interface Vec2 {\n    x: number;\n    y: number;\n}\n\n/**\n * InputPlugin - Action-based input system\n */\nexport class InputPlugin {\n    private game: GameLike;\n    private canvas: HTMLCanvasElement;\n\n    /** Action definitions */\n    private actions: Map<string, ActionDef> = new Map();\n\n    /** Current bindings (may differ from defaults after rebind) */\n    private bindings: Map<string, BindingSource[]> = new Map();\n\n    /** Raw input state */\n    private mousePos: Vec2 = { x: 0, y: 0 };\n    private keysDown: Set<string> = new Set();\n    private mouseButtons: Set<number> = new Set();\n\n    /** Send interval handle */\n    private sendInterval: number | null = null;\n\n    /** Last sent input (for deduplication) */\n    private lastSentInput: string = '';\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string) {\n        this.game = game;\n\n        // Resolve canvas\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        this.setupListeners();\n        this.startSendLoop();\n    }\n\n    /**\n     * Define an action with default bindings.\n     */\n    action(name: string, def: ActionDef): this {\n        this.actions.set(name, def);\n        // Set default bindings if not already rebound\n        if (!this.bindings.has(name)) {\n            this.bindings.set(name, [...def.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Rebind an action to new bindings.\n     */\n    rebind(name: string, bindings: BindingSource[]): this {\n        if (!this.actions.has(name)) {\n            console.warn(`[InputPlugin] Unknown action: ${name}`);\n            return this;\n        }\n        this.bindings.set(name, bindings);\n        return this;\n    }\n\n    /**\n     * Reset action to default bindings.\n     */\n    resetBinding(name: string): this {\n        const action = this.actions.get(name);\n        if (action) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Reset all bindings to defaults.\n     */\n    resetAllBindings(): this {\n        for (const [name, action] of this.actions) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Get current bindings for serialization.\n     * Only includes string bindings (callbacks can't be serialized).\n     */\n    getBindings(): Record<string, string[]> {\n        const result: Record<string, string[]> = {};\n        for (const [name, sources] of this.bindings) {\n            result[name] = sources.filter(s => typeof s === 'string') as string[];\n        }\n        return result;\n    }\n\n    /**\n     * Load bindings from serialized data.\n     */\n    loadBindings(data: Record<string, string[]>): this {\n        for (const [name, sources] of Object.entries(data)) {\n            if (this.actions.has(name)) {\n                this.bindings.set(name, sources);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Get current value of an action.\n     */\n    get(name: string): boolean | Vec2 | null {\n        const action = this.actions.get(name);\n        const sources = this.bindings.get(name);\n        if (!action || !sources) return null;\n\n        if (action.type === 'button') {\n            return this.resolveButton(sources);\n        } else {\n            return this.resolveVector(sources);\n        }\n    }\n\n    /**\n     * Get all action values as an object.\n     */\n    getAll(): Record<string, any> {\n        const result: Record<string, any> = {};\n        for (const name of this.actions.keys()) {\n            result[name] = this.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Resolve button value from sources (OR logic).\n     */\n    private resolveButton(sources: BindingSource[]): boolean {\n        for (const source of sources) {\n            if (typeof source === 'function') {\n                if (source()) return true;\n            } else if (this.resolveStringButton(source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resolve vector value from sources (additive, clamped).\n     */\n    private resolveVector(sources: BindingSource[]): Vec2 {\n        let x = 0, y = 0;\n\n        for (const source of sources) {\n            let vec: Vec2 | null = null;\n\n            if (typeof source === 'function') {\n                vec = source();\n            } else {\n                vec = this.resolveStringVector(source);\n            }\n\n            if (vec) {\n                x += vec.x;\n                y += vec.y;\n            }\n        }\n\n        // Clamp to -1..1 for direction vectors, but not for mouse position\n        // We detect mouse by checking if values are large\n        if (Math.abs(x) <= 1 && Math.abs(y) <= 1) {\n            const len = Math.sqrt(x * x + y * y);\n            if (len > 1) {\n                x /= len;\n                y /= len;\n            }\n        }\n\n        return { x, y };\n    }\n\n    /**\n     * Resolve a string binding to button value.\n     */\n    private resolveStringButton(source: string): boolean {\n        // key:X - single key\n        if (source.startsWith('key:')) {\n            const key = source.slice(4).toLowerCase();\n            return this.keysDown.has(key);\n        }\n\n        // mouse:left, mouse:right, mouse:middle\n        if (source.startsWith('mouse:')) {\n            const button = source.slice(6);\n            if (button === 'left') return this.mouseButtons.has(0);\n            if (button === 'right') return this.mouseButtons.has(2);\n            if (button === 'middle') return this.mouseButtons.has(1);\n        }\n\n        return false;\n    }\n\n    /**\n     * Resolve a string binding to vector value.\n     */\n    private resolveStringVector(source: string): Vec2 | null {\n        // mouse - current position\n        if (source === 'mouse') {\n            return { ...this.mousePos };\n        }\n\n        // keys:wasd\n        if (source === 'keys:wasd') {\n            return this.getWASD();\n        }\n\n        // keys:arrows\n        if (source === 'keys:arrows') {\n            return this.getArrows();\n        }\n\n        // keys:wasd+arrows\n        if (source === 'keys:wasd+arrows') {\n            const wasd = this.getWASD();\n            const arrows = this.getArrows();\n            return {\n                x: Math.max(-1, Math.min(1, wasd.x + arrows.x)),\n                y: Math.max(-1, Math.min(1, wasd.y + arrows.y))\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Get WASD direction.\n     */\n    private getWASD(): Vec2 {\n        let x = 0, y = 0;\n        if (this.keysDown.has('a')) x -= 1;\n        if (this.keysDown.has('d')) x += 1;\n        if (this.keysDown.has('w')) y -= 1;\n        if (this.keysDown.has('s')) y += 1;\n        return { x, y };\n    }\n\n    /**\n     * Get arrow keys direction.\n     */\n    private getArrows(): Vec2 {\n        let x = 0, y = 0;\n        if (this.keysDown.has('arrowleft')) x -= 1;\n        if (this.keysDown.has('arrowright')) x += 1;\n        if (this.keysDown.has('arrowup')) y -= 1;\n        if (this.keysDown.has('arrowdown')) y += 1;\n        return { x, y };\n    }\n\n    /**\n     * Set up event listeners.\n     */\n    private setupListeners(): void {\n        // Mouse move\n        this.canvas.addEventListener('mousemove', (e) => {\n            const rect = this.canvas.getBoundingClientRect();\n            this.mousePos.x = e.clientX - rect.left;\n            this.mousePos.y = e.clientY - rect.top;\n        });\n\n        // Mouse buttons\n        this.canvas.addEventListener('mousedown', (e) => {\n            this.mouseButtons.add(e.button);\n        });\n\n        this.canvas.addEventListener('mouseup', (e) => {\n            this.mouseButtons.delete(e.button);\n        });\n\n        // Keyboard - use window to catch all keys\n        window.addEventListener('keydown', (e) => {\n            this.keysDown.add(e.key.toLowerCase());\n        });\n\n        window.addEventListener('keyup', (e) => {\n            this.keysDown.delete(e.key.toLowerCase());\n        });\n\n        // Clear keys on blur (prevent stuck keys)\n        window.addEventListener('blur', () => {\n            this.keysDown.clear();\n            this.mouseButtons.clear();\n        });\n    }\n\n    /**\n     * Start the send loop.\n     */\n    private startSendLoop(): void {\n        // Send at server tick rate (default 50ms = 20fps)\n        const sendRate = 1000 / (this.game.getServerFps?.() || 20);\n\n        this.sendInterval = window.setInterval(() => {\n            if (this.game.isConnected() && this.game.localClientId && this.actions.size > 0) {\n                const input = this.getAll();\n                // Only send if input changed (deduplication to save bandwidth)\n                const inputStr = this.inputToString(input);\n                if (inputStr !== this.lastSentInput) {\n                    this.lastSentInput = inputStr;\n                    this.game.sendInput(input);\n                }\n            }\n        }, sendRate);\n    }\n\n    /**\n     * Convert input to string for comparison.\n     * Uses rounding for vectors to avoid sending tiny mouse movements.\n     */\n    private inputToString(input: Record<string, any>): string {\n        const normalized: Record<string, any> = {};\n        for (const [key, value] of Object.entries(input)) {\n            if (value && typeof value === 'object' && 'x' in value && 'y' in value) {\n                // Round vectors to avoid sending tiny movements\n                normalized[key] = { x: Math.round(value.x / 10) * 10, y: Math.round(value.y / 10) * 10 };\n            } else {\n                normalized[key] = value;\n            }\n        }\n        return JSON.stringify(normalized);\n    }\n\n    /**\n     * Stop the send loop.\n     */\n    destroy(): void {\n        if (this.sendInterval !== null) {\n            clearInterval(this.sendInterval);\n            this.sendInterval = null;\n        }\n    }\n}\n", "/**\n * CameraSystem - 2D camera management for ECS\n *\n * Updates Camera2D component based on follow target.\n * Handles zoom smoothing and position interpolation.\n *\n * This system is client-only - Camera2D component has sync: false.\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Camera2D, Transform2D } from '../components';\n\nexport interface CameraSystemOptions {\n    /** Default zoom level (default: 1) */\n    defaultZoom?: number;\n    /** Default smoothing (default: 0.1) */\n    defaultSmoothing?: number;\n    /** Minimum zoom level (default: 0.1) */\n    minZoom?: number;\n    /** Maximum zoom level (default: 10) */\n    maxZoom?: number;\n}\n\n/**\n * CameraSystem - manages Camera2D components.\n *\n * @example\n * // Add as plugin\n * const cameraSystem = game.addPlugin(CameraSystem);\n *\n * // Create a camera entity\n * game.defineEntity('camera').with(Camera2D).register();\n * const camera = game.spawn('camera');\n *\n * // Follow an entity\n * cameraSystem.follow(camera, playerEntity);\n *\n * // Or manually set position\n * const cam = camera.get(Camera2D);\n * cam.x = 100;\n * cam.y = 200;\n * cam.zoom = 1.5;\n */\nexport class CameraSystem {\n    private game: Game;\n    private options: Required<CameraSystemOptions>;\n\n    constructor(game: Game, options: CameraSystemOptions = {}) {\n        this.game = game;\n        this.options = {\n            defaultZoom: options.defaultZoom ?? 1,\n            defaultSmoothing: options.defaultSmoothing ?? 0.1,\n            minZoom: options.minZoom ?? 0.1,\n            maxZoom: options.maxZoom ?? 10\n        };\n\n        // Register update system\n        game.addSystem(this.update.bind(this), { phase: 'render' });\n    }\n\n    /**\n     * Update all cameras.\n     */\n    private update(): void {\n        for (const entity of this.game.query('Camera2D')) {\n            this.updateCamera(entity);\n        }\n    }\n\n    /**\n     * Update a single camera entity.\n     */\n    private updateCamera(cameraEntity: Entity): void {\n        const cam = cameraEntity.get(Camera2D);\n\n        // Follow target entity if set\n        if (cam.followEntity !== 0) {\n            const target = this.game.world.getEntity(cam.followEntity);\n            if (target && !target.destroyed) {\n                try {\n                    const transform = target.get(Transform2D);\n                    // Smooth follow\n                    cam.x += (transform.x - cam.x) * cam.smoothing;\n                    cam.y += (transform.y - cam.y) * cam.smoothing;\n                } catch {\n                    // Target doesn't have Transform2D\n                }\n            }\n        }\n\n        // Smooth zoom transition\n        if (cam.zoom !== cam.targetZoom) {\n            cam.zoom += (cam.targetZoom - cam.zoom) * cam.smoothing;\n            // Clamp zoom\n            cam.zoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, cam.zoom));\n        }\n    }\n\n    /**\n     * Set camera to follow an entity.\n     */\n    follow(cameraEntity: Entity, targetEntity: Entity | null): void {\n        const cam = cameraEntity.get(Camera2D);\n        cam.followEntity = targetEntity ? targetEntity.eid : 0;\n    }\n\n    /**\n     * Center camera on multiple entities (weighted by optional areas).\n     */\n    centerOn(cameraEntity: Entity, entities: Entity[], weights?: number[]): void {\n        if (entities.length === 0) return;\n\n        const cam = cameraEntity.get(Camera2D);\n        let totalWeight = 0;\n        let centerX = 0;\n        let centerY = 0;\n\n        for (let i = 0; i < entities.length; i++) {\n            const entity = entities[i];\n            if (entity.destroyed) continue;\n\n            try {\n                const transform = entity.get(Transform2D);\n                const weight = weights?.[i] ?? 1;\n\n                centerX += transform.x * weight;\n                centerY += transform.y * weight;\n                totalWeight += weight;\n            } catch {\n                // Entity doesn't have Transform2D\n            }\n        }\n\n        if (totalWeight > 0) {\n            cam.x += (centerX / totalWeight - cam.x) * cam.smoothing;\n            cam.y += (centerY / totalWeight - cam.y) * cam.smoothing;\n        }\n    }\n\n    /**\n     * Convert world coordinates to screen coordinates.\n     */\n    worldToScreen(cameraEntity: Entity, worldX: number, worldY: number): { x: number; y: number } {\n        const cam = cameraEntity.get(Camera2D);\n        return {\n            x: (worldX - cam.x) * cam.zoom + cam.viewportWidth / 2,\n            y: (worldY - cam.y) * cam.zoom + cam.viewportHeight / 2\n        };\n    }\n\n    /**\n     * Convert screen coordinates to world coordinates.\n     */\n    screenToWorld(cameraEntity: Entity, screenX: number, screenY: number): { x: number; y: number } {\n        const cam = cameraEntity.get(Camera2D);\n        return {\n            x: (screenX - cam.viewportWidth / 2) / cam.zoom + cam.x,\n            y: (screenY - cam.viewportHeight / 2) / cam.zoom + cam.y\n        };\n    }\n\n    /**\n     * Set zoom with optional target position.\n     */\n    setZoom(cameraEntity: Entity, zoom: number, immediate: boolean = false): void {\n        const cam = cameraEntity.get(Camera2D);\n        const clampedZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, zoom));\n        cam.targetZoom = clampedZoom;\n        if (immediate) {\n            cam.zoom = clampedZoom;\n        }\n    }\n\n    /**\n     * Get visible bounds in world coordinates.\n     */\n    getVisibleBounds(cameraEntity: Entity): { left: number; top: number; right: number; bottom: number } {\n        const cam = cameraEntity.get(Camera2D);\n        const halfWidth = (cam.viewportWidth / 2) / cam.zoom;\n        const halfHeight = (cam.viewportHeight / 2) / cam.zoom;\n\n        return {\n            left: cam.x - halfWidth,\n            top: cam.y - halfHeight,\n            right: cam.x + halfWidth,\n            bottom: cam.y + halfHeight\n        };\n    }\n\n    /**\n     * Check if a world point is visible.\n     */\n    isPointVisible(cameraEntity: Entity, worldX: number, worldY: number, margin: number = 0): boolean {\n        const bounds = this.getVisibleBounds(cameraEntity);\n        return worldX >= bounds.left - margin &&\n               worldX <= bounds.right + margin &&\n               worldY >= bounds.top - margin &&\n               worldY <= bounds.bottom + margin;\n    }\n}\n", "/**\r\n * Determinism Guard\r\n *\r\n * Warns developers when non-deterministic functions are called during simulation.\r\n * Suggests deterministic alternatives like dRandom() and dSqrt().\r\n */\r\n\r\nimport type { Game } from '../game';\r\n\r\ninterface OriginalFunctions {\r\n    mathRandom?: typeof Math.random;\r\n    mathSqrt?: typeof Math.sqrt;\r\n    dateNow?: typeof Date.now;\r\n    performanceNow?: typeof performance.now;\r\n}\r\n\r\nconst originalFunctions: OriginalFunctions = {};\r\nlet installedGame: Game | null = null;\r\nlet warnedFunctions: Set<string> = new Set();\r\n\r\nfunction isSimulating(): boolean {\r\n    return installedGame?.world?._isSimulating ?? false;\r\n}\r\n\r\nfunction warnOnce(key: string, message: string) {\r\n    if (!warnedFunctions.has(key)) {\r\n        warnedFunctions.add(key);\r\n        console.warn(message);\r\n    }\r\n}\r\n\r\n/**\r\n * Enable determinism guard for a game instance.\r\n * Warns when dangerous functions are called during simulation.\r\n *\r\n * @example\r\n * const game = createGame();\r\n * enableDeterminismGuard(game);\r\n */\r\nexport function enableDeterminismGuard(game: Game): void {\r\n    if (installedGame) {\r\n        console.warn('Determinism guard already installed for another game instance');\r\n        return;\r\n    }\r\n\r\n    installedGame = game;\r\n    warnedFunctions.clear();\r\n\r\n    // Intercept Math.random\r\n    originalFunctions.mathRandom = Math.random;\r\n    Math.random = function(): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Math.random',\r\n                '\u26A0\uFE0F Math.random() is non-deterministic!\\n' +\r\n                '   Use dRandom() instead for deterministic random numbers.\\n' +\r\n                '   Example: const r = dRandom();'\r\n            );\r\n        }\r\n        return originalFunctions.mathRandom!();\r\n    };\r\n\r\n    // Intercept Math.sqrt\r\n    originalFunctions.mathSqrt = Math.sqrt;\r\n    Math.sqrt = function(x: number): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Math.sqrt',\r\n                '\u26A0\uFE0F Math.sqrt() is non-deterministic!\\n' +\r\n                '   Use dSqrt() instead for deterministic square root.\\n' +\r\n                '   Example: const dist = dSqrt(dx * dx + dy * dy);'\r\n            );\r\n        }\r\n        return originalFunctions.mathSqrt!(x);\r\n    };\r\n\r\n    // Intercept Date.now\r\n    originalFunctions.dateNow = Date.now;\r\n    Date.now = function(): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Date.now',\r\n                '\u26A0\uFE0F Date.now() is non-deterministic!\\n' +\r\n                '   Use game.time instead for deterministic timing.\\n' +\r\n                '   Example: const respawnAt = game.time + 3000;'\r\n            );\r\n        }\r\n        return originalFunctions.dateNow!();\r\n    };\r\n\r\n    // Intercept performance.now\r\n    if (typeof performance !== 'undefined') {\r\n        originalFunctions.performanceNow = performance.now.bind(performance);\r\n        performance.now = function(): number {\r\n            if (isSimulating()) {\r\n                warnOnce('performance.now',\r\n                    '\u26A0\uFE0F performance.now() is non-deterministic!\\n' +\r\n                    '   Use game.time instead for deterministic timing.'\r\n                );\r\n            }\r\n            return originalFunctions.performanceNow!();\r\n        };\r\n    }\r\n\r\n    console.log('\uD83D\uDEE1\uFE0F Determinism guard enabled');\r\n}\r\n\r\n/**\r\n * Disable determinism guard and restore original functions.\r\n */\r\nexport function disableDeterminismGuard(): void {\r\n    if (originalFunctions.mathRandom) {\r\n        Math.random = originalFunctions.mathRandom;\r\n    }\r\n    if (originalFunctions.mathSqrt) {\r\n        Math.sqrt = originalFunctions.mathSqrt;\r\n    }\r\n    if (originalFunctions.dateNow) {\r\n        Date.now = originalFunctions.dateNow;\r\n    }\r\n    if (originalFunctions.performanceNow && typeof performance !== 'undefined') {\r\n        performance.now = originalFunctions.performanceNow;\r\n    }\r\n\r\n    installedGame = null;\r\n    warnedFunctions.clear();\r\n\r\n    // Clear stored references\r\n    Object.keys(originalFunctions).forEach(key => {\r\n        delete (originalFunctions as any)[key];\r\n    });\r\n}\r\n", "// Auto-generated by build-browser.js\nexport const ENGINE_VERSION = '834769b';\nexport const ENGINE_BUILD_DATE = '2026-01-06T21:38:59.947Z';\n", "/**\r\n * Debug UI - Simple stats overlay for game instances\r\n *\r\n * Usage:\r\n *   Modu.enableDebugUI(game);  // Pass game instance\r\n *   Modu.setDebugHash(() => computeMyHash()); // Optional: show live state hash\r\n *\r\n * Also enables determinism guard to warn about non-deterministic function calls.\r\n */\r\n\r\nimport { enableDeterminismGuard } from './determinism-guard';\r\nimport type { Game } from '../game';\r\nimport { ENGINE_VERSION } from '../version';\r\n\r\n/** Interface for objects that can be displayed in debug UI */\r\nexport interface DebugUITarget {\r\n    getClientId(): string | null;\r\n    getFrame(): number;\r\n    getNodeUrl(): string | null;\r\n    getLastSnapshot(): { hash: string | null; frame: number; size: number; entityCount: number };\r\n    getServerFps(): number;\r\n    getRoomId(): string | null;\r\n    getUploadRate(): number;\r\n    getDownloadRate(): number;\r\n    getClients(): string[];\r\n    getStateHash(): string;\r\n    isAuthority?(): boolean;\r\n    getDriftStats?(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number };\r\n}\r\n\r\nexport interface DebugUIOptions {\r\n    /** Position: 'top-right' (default), 'top-left', 'bottom-right', 'bottom-left' */\r\n    position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\r\n}\r\n\r\nlet debugDiv: HTMLDivElement | null = null;\r\nlet updateInterval: number | null = null;\r\nlet hashCallback: (() => string | number) | null = null;\r\nlet debugTarget: DebugUITarget | null = null;\r\n\r\n// FPS tracking\r\nlet lastFrameTime = 0;\r\nlet frameCount = 0;\r\nlet renderFps = 0;\r\nlet fpsUpdateTime = 0;\r\n\r\n/**\r\n * Set a callback to compute the current state hash for debug display.\r\n * The hash will be shown in the debug UI and should change as bodies move.\r\n */\r\nexport function setDebugHash(callback: () => string | number): void {\r\n    hashCallback = callback;\r\n}\r\n\r\n/**\r\n * Enable debug UI overlay - shows frame, client, node, snapshot info automatically\r\n * @param target - Object implementing DebugUITarget interface\r\n * @param options - UI options\r\n */\r\nexport function enableDebugUI(target?: DebugUITarget, options: DebugUIOptions = {}): HTMLDivElement {\r\n    if (debugDiv) return debugDiv;\r\n\r\n    // Store target reference for updates\r\n    debugTarget = target || null;\r\n\r\n    // Enable determinism guard if target is a Game instance\r\n    if (target && 'world' in target) {\r\n        enableDeterminismGuard(target as unknown as Game);\r\n    }\r\n\r\n    const pos = options.position || 'top-right';\r\n\r\n    debugDiv = document.createElement('div');\r\n    debugDiv.id = 'modu-debug-ui';\r\n    debugDiv.style.cssText = `\r\n        position: fixed;\r\n        ${pos.includes('top') ? 'top: 10px' : 'bottom: 10px'};\r\n        ${pos.includes('right') ? 'right: 10px' : 'left: 10px'};\r\n        background: rgba(0, 0, 0, 0.8);\r\n        color: #0f0;\r\n        font: 12px monospace;\r\n        padding: 8px 12px;\r\n        border-radius: 4px;\r\n        z-index: 10000;\r\n        min-width: 180px;\r\n        pointer-events: none;\r\n    `;\r\n    document.body.appendChild(debugDiv);\r\n\r\n    // Update loop\r\n    const update = (now: number) => {\r\n        if (!debugDiv) return;\r\n\r\n        // Calculate render FPS\r\n        frameCount++;\r\n        if (now - fpsUpdateTime >= 1000) {\r\n            renderFps = frameCount;\r\n            frameCount = 0;\r\n            fpsUpdateTime = now;\r\n        }\r\n\r\n        const eng = debugTarget;\r\n        if (!eng) {\r\n            debugDiv.innerHTML = '<div style=\"color:#f00\">No engine instance</div>';\r\n            return;\r\n        }\r\n\r\n        const clientId = eng.getClientId();\r\n        const frame = eng.getFrame();\r\n        const nodeUrl = eng.getNodeUrl();\r\n        const lastSnap = eng.getLastSnapshot();\r\n        const fps = eng.getServerFps();\r\n        const roomId = eng.getRoomId();\r\n        const up = eng.getUploadRate();\r\n        const down = eng.getDownloadRate();\r\n        const clients = eng.getClients();\r\n        const isAuthority = (eng as any).isAuthority?.() || false;\r\n\r\n        // Compute live state hash (use custom callback if set, otherwise use engine's hash)\r\n        let currentHash = '--------';\r\n        try {\r\n            if (hashCallback) {\r\n                const hash = hashCallback();\r\n                currentHash = typeof hash === 'number' ? hash.toString(16).padStart(8, '0') : String(hash).slice(0, 8);\r\n            } else {\r\n                currentHash = eng.getStateHash();\r\n            }\r\n        } catch (e) {\r\n            currentHash = 'error';\r\n        }\r\n\r\n        // Format bandwidth with appropriate unit\r\n        const formatBandwidth = (bytes: number): string => {\r\n            if (bytes >= 1024) {\r\n                return (bytes / 1024).toFixed(1) + ' kB/s';\r\n            }\r\n            return Math.round(bytes) + ' B/s';\r\n        };\r\n        const upStr = formatBandwidth(up);\r\n        const downStr = formatBandwidth(down);\r\n\r\n        // Get drift stats (field-by-field comparison)\r\n        const driftStats = (eng as any).getDriftStats?.() || { determinismPercent: 100, totalChecks: 0, matchingFieldCount: 0, totalFieldCount: 0 };\r\n        const detPct = driftStats.determinismPercent.toFixed(1);\r\n        const detColor = driftStats.determinismPercent >= 99.9 ? '#0f0' :\r\n                        driftStats.determinismPercent >= 95 ? '#ff0' : '#f00';\r\n\r\n        // Format sync status\r\n        let syncStatus: string;\r\n        if (isAuthority) {\r\n            syncStatus = '<span style=\"color:#888\">I\\'m authority</span>';\r\n        } else if (driftStats.totalChecks === 0) {\r\n            syncStatus = '<span style=\"color:#888\">waiting...</span>';\r\n        } else {\r\n            syncStatus = `<span style=\"color:${detColor}\">${detPct}%</span> <span style=\"color:#888\">(${driftStats.matchingFieldCount}/${driftStats.totalFieldCount})</span>`;\r\n        }\r\n\r\n        // Format received snapshot info with frames ago\r\n        const framesAgo = lastSnap.frame ? frame - lastSnap.frame : 0;\r\n        const snapInfo = lastSnap.hash ? `${lastSnap.hash.slice(0, 8)} <span style=\"color:#888\">(${framesAgo} ago)</span>` : 'none';\r\n\r\n        // Format size with appropriate units\r\n        const formatSize = (bytes: number): string => {\r\n            if (bytes >= 1024 * 1024) {\r\n                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';\r\n            } else if (bytes >= 1024) {\r\n                return (bytes / 1024).toFixed(1) + ' KB';\r\n            }\r\n            return bytes + ' B';\r\n        };\r\n        const sizeStr = lastSnap.size > 0 ? formatSize(lastSnap.size) : '-';\r\n        const entityStr = lastSnap.entityCount > 0 ? String(lastSnap.entityCount) : '-';\r\n\r\n        // Section header style\r\n        const sectionStyle = 'color:#666;font-size:10px;margin-top:6px;margin-bottom:2px;border-bottom:1px solid #333;';\r\n\r\n        debugDiv.innerHTML = `\r\n            <div style=\"${sectionStyle}\">ROOM</div>\r\n            <div>ID: <span style=\"color:#fff\">${roomId || '-'}</span></div>\r\n            <div>Players: <span style=\"color:#ff0\">${clients.length}</span></div>\r\n            <div>Frame: <span style=\"color:#fff\">${frame}</span></div>\r\n            <div>URL: <span style=\"color:#0ff\">${nodeUrl || '-'}</span></div>\r\n\r\n            <div style=\"${sectionStyle}\">ME</div>\r\n            <div>Authority: <span style=\"color:${isAuthority ? '#0ff' : '#888'}\">${isAuthority ? 'Yes' : 'No'}</span></div>\r\n            <div>Client: <span style=\"color:#ff0\">${clientId ? clientId.slice(0, 8) : '-'}</span></div>\r\n\r\n            <div style=\"${sectionStyle}\">ENGINE</div>\r\n            <div>Version: <span style=\"color:#888\">${ENGINE_VERSION}</span></div>\r\n            <div>FPS: <span style=\"color:#0f0\">${renderFps}</span> render, <span style=\"color:#0f0\">${fps}</span> tick</div>\r\n            <div>Net: <span style=\"color:#0f0\">${upStr}</span> up, <span style=\"color:#f80\">${downStr}</span> down</div>\r\n\r\n            <div style=\"${sectionStyle}\">SNAPSHOT</div>\r\n            <div>Current: <span style=\"color:#f0f\">${currentHash}</span></div>\r\n            <div>Received: <span style=\"color:#f80\">${snapInfo}</span></div>\r\n            <div>Size: <span style=\"color:#fff\">${sizeStr}</span>, Entities: <span style=\"color:#fff\">${entityStr}</span></div>\r\n            <div>Last Sync: ${syncStatus}</div>\r\n        `;\r\n    };\r\n\r\n    // Update every frame\r\n    const loop = (now: number) => {\r\n        update(now);\r\n        updateInterval = requestAnimationFrame(loop) as unknown as number;\r\n    };\r\n    fpsUpdateTime = performance.now();\r\n    requestAnimationFrame(loop);\r\n\r\n    return debugDiv;\r\n}\r\n\r\n/**\r\n * Disable debug UI\r\n */\r\nexport function disableDebugUI(): void {\r\n    if (updateInterval) {\r\n        cancelAnimationFrame(updateInterval);\r\n        updateInterval = null;\r\n    }\r\n    if (debugDiv) {\r\n        debugDiv.remove();\r\n        debugDiv = null;\r\n    }\r\n    debugTarget = null;\r\n}\r\n\r\n/**\r\n * Check if debug UI is enabled\r\n */\r\nexport function isDebugUIEnabled(): boolean {\r\n    return debugDiv !== null;\r\n}\r\n", "/**\r\n * Physics 2D Module\r\n *\r\n * Deterministic 2D physics engine with fixed-point math.\r\n * All components use 16.16 fixed-point integers for 100% determinism.\r\n */\r\n\r\n// Shapes and AABB\r\nexport { Shape2DType, CircleShape, BoxShape2D, Shape2D, AABB2D, aabb2DOverlap, aabb2DUnion, aabb2DArea, createCircle, createBox2D, createBox2DFromSize } from './shapes';\r\n\r\n// Collision Layers\r\nexport { CollisionFilter, Layers, DEFAULT_FILTER, createFilter, shouldCollide, filterCollidingWith, filterExcluding } from './layers';\r\n\r\n// Rigid Body\r\nexport { BodyType2D, Vec2, vec2, vec2Zero, vec2Clone, vec2Add, vec2Sub, vec2Scale, vec2Dot, vec2LengthSq, vec2Cross, RigidBody2D, resetBody2DIdCounter, getBody2DIdCounter, setBody2DIdCounter, createBody2D, setBody2DMass, setBody2DVelocity, applyImpulse2D, applyForce2D } from './rigid-body';\r\n\r\n// Collision Detection and Response\r\nexport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\r\n\r\n// Physics World\r\nexport { World2D, createWorld2D, addBody2D, removeBody2D, stepWorld2D, saveWorldState2D, loadWorldState2D, BodyState2D, WorldState2D } from './world';\r\n\r\n// Spatial Partitioning\r\nexport { SpatialHash2D } from './spatial-hash';\r\nexport { QuadTree2D } from './quad-tree';\r\n\r\n// Triggers/Sensors\r\nexport { TriggerEvent, TriggerState, makeTrigger } from './trigger';\r\n", "/**\r\n * 2D Physics Shapes\r\n *\r\n * Defines 2D collision shapes: Circle and Box (AABB).\r\n * Uses fixed-point math for determinism.\r\n */\r\n\r\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpMin, fpMax } from '../../math/fixed';\r\n\r\n// ============================================\r\n// Types\r\n// ============================================\r\n\r\nexport enum Shape2DType {\r\n    Circle = 0,\r\n    Box = 1,\r\n}\r\n\r\nexport interface CircleShape {\r\n    type: Shape2DType.Circle;\r\n    radius: Fixed;\r\n}\r\n\r\nexport interface BoxShape2D {\r\n    type: Shape2DType.Box;\r\n    halfWidth: Fixed;   // Half extent on X axis\r\n    halfHeight: Fixed;  // Half extent on Y axis\r\n}\r\n\r\nexport type Shape2D = CircleShape | BoxShape2D;\r\n\r\n// ============================================\r\n// AABB (Axis-Aligned Bounding Box)\r\n// ============================================\r\n\r\nexport interface AABB2D {\r\n    minX: Fixed;\r\n    minY: Fixed;\r\n    maxX: Fixed;\r\n    maxY: Fixed;\r\n}\r\n\r\n/**\r\n * Check if two AABBs overlap.\r\n */\r\nexport function aabb2DOverlap(a: AABB2D, b: AABB2D): boolean {\r\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\r\n           a.minY <= b.maxY && a.maxY >= b.minY;\r\n}\r\n\r\n/**\r\n * Compute the union of two AABBs.\r\n */\r\nexport function aabb2DUnion(a: AABB2D, b: AABB2D): AABB2D {\r\n    return {\r\n        minX: fpMin(a.minX, b.minX),\r\n        minY: fpMin(a.minY, b.minY),\r\n        maxX: fpMax(a.maxX, b.maxX),\r\n        maxY: fpMax(a.maxY, b.maxY),\r\n    };\r\n}\r\n\r\n/**\r\n * Compute the area of an AABB.\r\n */\r\nexport function aabb2DArea(aabb: AABB2D): Fixed {\r\n    const width = aabb.maxX - aabb.minX;\r\n    const height = aabb.maxY - aabb.minY;\r\n    return fpMul(width as Fixed, height as Fixed);\r\n}\r\n\r\n// ============================================\r\n// Shape Factories\r\n// ============================================\r\n\r\n/**\r\n * Create a circle shape.\r\n */\r\nexport function createCircle(radius: number): CircleShape {\r\n    return {\r\n        type: Shape2DType.Circle,\r\n        radius: toFixed(radius),\r\n    };\r\n}\r\n\r\n/**\r\n * Create a box shape from half-extents.\r\n */\r\nexport function createBox2D(halfWidth: number, halfHeight: number): BoxShape2D {\r\n    return {\r\n        type: Shape2DType.Box,\r\n        halfWidth: toFixed(halfWidth),\r\n        halfHeight: toFixed(halfHeight),\r\n    };\r\n}\r\n\r\n/**\r\n * Create a box shape from full dimensions.\r\n * Uses bit shift for deterministic halving.\r\n */\r\nexport function createBox2DFromSize(width: number, height: number): BoxShape2D {\r\n    // Use bit shift instead of floating-point division for determinism\r\n    const halfWidth = (toFixed(width) >> 1) as Fixed;\r\n    const halfHeight = (toFixed(height) >> 1) as Fixed;\r\n    return {\r\n        type: Shape2DType.Box,\r\n        halfWidth,\r\n        halfHeight,\r\n    };\r\n}\r\n", "/**\r\n * Collision Layers\r\n *\r\n * Controls which bodies can collide with each other using bitmasks.\r\n * Layer = \"what am I\", Mask = \"what do I collide with\"\r\n *\r\n * Shared between 2D and 3D physics engines.\r\n */\r\n\r\n// ============================================\r\n// Collision Filter\r\n// ============================================\r\n\r\nexport interface CollisionFilter {\r\n    /** Which layer this body belongs to (single bit) */\r\n    layer: number;\r\n    /** Which layers this body collides with (bitmask) */\r\n    mask: number;\r\n}\r\n\r\n// ============================================\r\n// Default Layers\r\n// ============================================\r\n\r\nexport const Layers = {\r\n    NONE: 0,\r\n    DEFAULT: 1 << 0,      // 1\r\n    PLAYER: 1 << 1,       // 2\r\n    ENEMY: 1 << 2,        // 4\r\n    PROJECTILE: 1 << 3,   // 8\r\n    ITEM: 1 << 4,         // 16\r\n    TRIGGER: 1 << 5,      // 32\r\n    WORLD: 1 << 6,        // 64\r\n    PROP: 1 << 7,         // 128\r\n    // Layers 8-15 reserved for game-specific use\r\n    CUSTOM_1: 1 << 8,\r\n    CUSTOM_2: 1 << 9,\r\n    CUSTOM_3: 1 << 10,\r\n    CUSTOM_4: 1 << 11,\r\n    CUSTOM_5: 1 << 12,\r\n    CUSTOM_6: 1 << 13,\r\n    CUSTOM_7: 1 << 14,\r\n    CUSTOM_8: 1 << 15,\r\n    ALL: 0xFFFF           // All layers\r\n} as const;\r\n\r\n// ============================================\r\n// Default Filter\r\n// ============================================\r\n\r\n/**\r\n * Default collision filter - collides with everything\r\n */\r\nexport const DEFAULT_FILTER: CollisionFilter = {\r\n    layer: Layers.DEFAULT,\r\n    mask: Layers.ALL\r\n};\r\n\r\n// ============================================\r\n// Filter Helpers\r\n// ============================================\r\n\r\n/**\r\n * Create a collision filter\r\n */\r\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\r\n    return { layer, mask };\r\n}\r\n\r\n/**\r\n * Check if two filters allow collision\r\n * Both must have the other in their mask\r\n */\r\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\r\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\r\n}\r\n\r\n/**\r\n * Create a filter that collides with specific layers\r\n */\r\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\r\n    let mask = 0;\r\n    for (const l of collidesWithLayers) {\r\n        mask |= l;\r\n    }\r\n    return { layer, mask };\r\n}\r\n\r\n/**\r\n * Create a filter that collides with everything except specific layers\r\n */\r\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\r\n    let mask = Layers.ALL;\r\n    for (const l of excludeLayers) {\r\n        mask &= ~l;\r\n    }\r\n    return { layer, mask };\r\n}\r\n", "/**\n * 2D Rigid Body\n *\n * Defines 2D rigid body with position, rotation (angle), velocity.\n * Uses fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2D, Shape2DType, CircleShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);\nconst FRICTION_DEFAULT = toFixed(0.5);\n\n// Pre-computed fixed-point constants for deterministic inertia calculations\nconst FP_ONE_TWELFTH = 5461 as Fixed;  // 65536 / 12 = 5461.33... -> 5461\n\n// ============================================\n// Types\n// ============================================\n\nexport enum BodyType2D {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n/**\n * 2D Vector using fixed-point math.\n */\nexport interface Vec2 {\n    x: Fixed;\n    y: Fixed;\n}\n\nexport function vec2Zero(): Vec2 {\n    return { x: 0, y: 0 };\n}\n\nexport function vec2(x: number, y: number): Vec2 {\n    return { x: toFixed(x), y: toFixed(y) };\n}\n\nexport function vec2Clone(v: Vec2): Vec2 {\n    return { x: v.x, y: v.y };\n}\n\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x + b.x) as Fixed, y: (a.y + b.y) as Fixed };\n}\n\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x - b.x) as Fixed, y: (a.y - b.y) as Fixed };\n}\n\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\n}\n\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\n    return (fpMul(a.x, b.x) + fpMul(a.y, b.y)) as Fixed;\n}\n\nexport function vec2LengthSq(v: Vec2): Fixed {\n    return (fpMul(v.x, v.x) + fpMul(v.y, v.y)) as Fixed;\n}\n\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\n    // 2D cross product returns scalar (z component of 3D cross)\n    return (fpMul(a.x, b.y) - fpMul(a.y, b.x)) as Fixed;\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody2D {\n    id: number;\n    type: BodyType2D;\n    shape: Shape2D;\n    label: string;\n\n    // Transform\n    position: Vec2;\n    angle: Fixed;  // Rotation in radians (not quaternion like 3D)\n\n    // Velocity\n    linearVelocity: Vec2;\n    angularVelocity: Fixed;  // Radians per second\n\n    // Mass properties\n    mass: Fixed;\n    invMass: Fixed;\n    inertia: Fixed;\n    invInertia: Fixed;\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotation: boolean;\n    isSensor: boolean;\n    isBullet: boolean;  // Enable CCD (continuous collision detection) for fast-moving objects\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId2D = 1;\n\nexport function resetBody2DIdCounter(): void {\n    nextBodyId2D = 1;\n}\n\nexport function getBody2DIdCounter(): number {\n    return nextBodyId2D;\n}\n\nexport function setBody2DIdCounter(value: number): void {\n    nextBodyId2D = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody2D(\n    type: BodyType2D,\n    shape: Shape2D,\n    x: number,\n    y: number,\n    label?: string\n): RigidBody2D {\n    const mass = type === BodyType2D.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType2D.Dynamic ? FP_ONE : 0;\n\n    // Calculate moment of inertia using pre-computed constants\n    let inertia = 0;\n    if (type === BodyType2D.Dynamic) {\n        if (shape.type === Shape2DType.Circle) {\n            // I = (1/2) * m * r\u00B2\n            const r = (shape as CircleShape).radius;\n            inertia = fpMul(fpMul(mass, FP_HALF), fpMul(r, r));\n        } else {\n            // I = (1/12) * m * (w\u00B2 + h\u00B2)\n            // Use bit shift for *2 instead of fpMul with toFixed(2)\n            const w = (shape.halfWidth << 1) as Fixed;\n            const h = (shape.halfHeight << 1) as Fixed;\n            inertia = fpMul(fpMul(mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\n        }\n    }\n\n    // Always increment counter for new bodies (ID will be overwritten for snapshot restoration)\n    const bodyId = nextBodyId2D++;\n    const bodyLabel = label || 'body2d_' + bodyId;\n\n    return {\n        id: bodyId,\n        type,\n        shape,\n        label: bodyLabel,\n        position: vec2(x, y),\n        angle: 0,\n        linearVelocity: vec2Zero(),\n        angularVelocity: 0,\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotation: false,\n        isSensor: false,\n        isBullet: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBody2DMass(body: RigidBody2D, mass: number): void {\n    if (body.type !== BodyType2D.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBody2DVelocity(body: RigidBody2D, vx: number, vy: number): void {\n    body.linearVelocity = vec2(vx, vy);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse2D(body: RigidBody2D, impulse: Vec2, point?: Vec2): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(impulse, body.invMass));\n\n    if (point && !body.lockRotation) {\n        const r = vec2Sub(point, body.position);\n        const torque = vec2Cross(r, impulse);\n        body.angularVelocity = (body.angularVelocity + fpMul(torque, body.invInertia)) as Fixed;\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce2D(body: RigidBody2D, force: Vec2, dt: Fixed): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n    const impulse = vec2Scale(force, dt);\n    applyImpulse2D(body, impulse);\n}\n", "/**\n * 2D Collision Detection and Response\n *\n * Uses Box2D-style collision detection:\n * - SAT (Separating Axis Theorem) for box-box\n * - Closest point on box for circle-box\n * - Direct distance for circle-circle\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt, fpMin, fpMax, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2DType, Shape2D, CircleShape, BoxShape2D, AABB2D } from './shapes';\nimport { RigidBody2D, Vec2, vec2, vec2Zero, vec2Sub, vec2Add, vec2Scale, vec2Dot, vec2LengthSq, BodyType2D } from './rigid-body';\n\n// ============================================\n// Contact\n// ============================================\n\nexport interface Contact2D {\n    bodyA: RigidBody2D;\n    bodyB: RigidBody2D;\n    point: Vec2;\n    normal: Vec2;  // Points from A to B\n    depth: Fixed;\n}\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB2D(body: RigidBody2D): AABB2D {\n    const { position, shape, angle } = body;\n\n    if (shape.type === Shape2DType.Circle) {\n        const radius = (shape as CircleShape).radius;\n        return {\n            minX: (position.x - radius) as Fixed,\n            minY: (position.y - radius) as Fixed,\n            maxX: (position.x + radius) as Fixed,\n            maxY: (position.y + radius) as Fixed,\n        };\n    } else {\n        const box = shape as BoxShape2D;\n        const halfWidth = box.halfWidth;\n        const halfHeight = box.halfHeight;\n\n        if (angle === 0) {\n            return {\n                minX: (position.x - halfWidth) as Fixed,\n                minY: (position.y - halfHeight) as Fixed,\n                maxX: (position.x + halfWidth) as Fixed,\n                maxY: (position.y + halfHeight) as Fixed,\n            };\n        }\n\n        // Rotated box - compute bounding box\n        const cosAngle = fpCos(angle);\n        const sinAngle = fpSin(angle);\n        const absCos = fpAbs(cosAngle);\n        const absSin = fpAbs(sinAngle);\n\n        const extentX = (fpMul(halfWidth, absCos) + fpMul(halfHeight, absSin)) as Fixed;\n        const extentY = (fpMul(halfWidth, absSin) + fpMul(halfHeight, absCos)) as Fixed;\n\n        return {\n            minX: (position.x - extentX) as Fixed,\n            minY: (position.y - extentY) as Fixed,\n            maxX: (position.x + extentX) as Fixed,\n            maxY: (position.y + extentY) as Fixed,\n        };\n    }\n}\n\n// ============================================\n// Collision Detection\n// ============================================\n\nexport function detectCollision2D(bodyA: RigidBody2D, bodyB: RigidBody2D): Contact2D | null {\n    const shapeA = bodyA.shape;\n    const shapeB = bodyB.shape;\n\n    // Circle-Circle\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Circle) {\n        return detectCircleCircle(bodyA, bodyB);\n    }\n\n    // Box-Box\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Box) {\n        return detectBoxBox(bodyA, bodyB);\n    }\n\n    // Circle-Box (ensure circle is always first for consistent normal direction)\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Box) {\n        return detectCircleBox(bodyA, bodyB);\n    }\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Circle) {\n        const contact = detectCircleBox(bodyB, bodyA);\n        if (contact) {\n            // Swap bodies and flip normal to maintain A->B convention\n            return {\n                bodyA: bodyA,\n                bodyB: bodyB,\n                point: contact.point,\n                normal: { x: (-contact.normal.x) as Fixed, y: (-contact.normal.y) as Fixed },\n                depth: contact.depth\n            };\n        }\n        return null;\n    }\n\n    return null;\n}\n\n/**\n * Circle vs Circle collision detection\n */\nfunction detectCircleCircle(circleA: RigidBody2D, circleB: RigidBody2D): Contact2D | null {\n    const radiusA = (circleA.shape as CircleShape).radius;\n    const radiusB = (circleB.shape as CircleShape).radius;\n    const sumRadius = (radiusA + radiusB) as Fixed;\n\n    // Vector from A to B\n    const deltaX = (circleB.position.x - circleA.position.x) as Fixed;\n    const deltaY = (circleB.position.y - circleA.position.y) as Fixed;\n    const distanceSq = (fpMul(deltaX, deltaX) + fpMul(deltaY, deltaY)) as Fixed;\n    const minDistSq = fpMul(sumRadius, sumRadius);\n\n    if (distanceSq >= minDistSq) return null;\n\n    const distance = fpSqrt(distanceSq);\n    const penetration = (sumRadius - distance) as Fixed;\n\n    // Normal points from A to B\n    let normalX: Fixed, normalY: Fixed;\n    if (distance > 0) {\n        const invDist = fpDiv(FP_ONE, distance);\n        normalX = fpMul(deltaX, invDist);\n        normalY = fpMul(deltaY, invDist);\n    } else {\n        // Circles at same position - arbitrary normal\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n    }\n\n    // Contact point on surface of A\n    const contactX = (circleA.position.x + fpMul(normalX, radiusA)) as Fixed;\n    const contactY = (circleA.position.y + fpMul(normalY, radiusA)) as Fixed;\n\n    return {\n        bodyA: circleA,\n        bodyB: circleB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Box vs Box collision detection (AABB - assumes no rotation)\n */\nfunction detectBoxBox(boxA: RigidBody2D, boxB: RigidBody2D): Contact2D | null {\n    const shapeA = boxA.shape as BoxShape2D;\n    const shapeB = boxB.shape as BoxShape2D;\n\n    // Vector from A to B\n    const deltaX = (boxB.position.x - boxA.position.x) as Fixed;\n    const deltaY = (boxB.position.y - boxA.position.y) as Fixed;\n\n    // Overlap on each axis\n    const overlapX = ((shapeA.halfWidth + shapeB.halfWidth) - fpAbs(deltaX)) as Fixed;\n    const overlapY = ((shapeA.halfHeight + shapeB.halfHeight) - fpAbs(deltaY)) as Fixed;\n\n    if (overlapX <= 0 || overlapY <= 0) return null;\n\n    // Use axis with minimum overlap (SAT)\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (overlapX < overlapY) {\n        penetration = overlapX;\n        normalX = deltaX > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n        normalY = 0 as Fixed;\n    } else {\n        penetration = overlapY;\n        normalX = 0 as Fixed;\n        normalY = deltaY > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n    }\n\n    // Contact point at midpoint\n    const contactX = ((boxA.position.x + boxB.position.x) >> 1) as Fixed;\n    const contactY = ((boxA.position.y + boxB.position.y) >> 1) as Fixed;\n\n    return {\n        bodyA: boxA,\n        bodyB: boxB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Circle vs Box collision detection\n * Box2D-style: find closest point on box, check distance to circle center\n */\nfunction detectCircleBox(circle: RigidBody2D, box: RigidBody2D): Contact2D | null {\n    const radius = (circle.shape as CircleShape).radius;\n    const boxShape = box.shape as BoxShape2D;\n\n    // Circle center in box's local space (box at origin)\n    const localX = (circle.position.x - box.position.x) as Fixed;\n    const localY = (circle.position.y - box.position.y) as Fixed;\n\n    // Clamp to box bounds to find closest point\n    const clampedX = fpMax((-boxShape.halfWidth) as Fixed, fpMin(boxShape.halfWidth, localX));\n    const clampedY = fpMax((-boxShape.halfHeight) as Fixed, fpMin(boxShape.halfHeight, localY));\n\n    // Check if circle center is inside box\n    const centerInside = fpAbs(localX) < boxShape.halfWidth && fpAbs(localY) < boxShape.halfHeight;\n\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (centerInside) {\n        // Circle center is inside box - find closest face\n        const distToRight = (boxShape.halfWidth - localX) as Fixed;\n        const distToLeft = (boxShape.halfWidth + localX) as Fixed;\n        const distToTop = (boxShape.halfHeight - localY) as Fixed;\n        const distToBottom = (boxShape.halfHeight + localY) as Fixed;\n\n        // Find minimum distance to any face\n        let minDist = distToRight;\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n\n        if (distToLeft < minDist) {\n            minDist = distToLeft;\n            normalX = (-FP_ONE) as Fixed;\n            normalY = 0 as Fixed;\n        }\n        if (distToTop < minDist) {\n            minDist = distToTop;\n            normalX = 0 as Fixed;\n            normalY = FP_ONE;\n        }\n        if (distToBottom < minDist) {\n            minDist = distToBottom;\n            normalX = 0 as Fixed;\n            normalY = (-FP_ONE) as Fixed;\n        }\n\n        // Penetration is distance to face plus radius\n        penetration = (minDist + radius) as Fixed;\n    } else {\n        // Circle center is outside box - normal case\n        const diffX = (localX - clampedX) as Fixed;\n        const diffY = (localY - clampedY) as Fixed;\n        const distanceSq = (fpMul(diffX, diffX) + fpMul(diffY, diffY)) as Fixed;\n\n        // No collision if distance > radius\n        if (distanceSq >= fpMul(radius, radius)) return null;\n\n        const distance = fpSqrt(distanceSq);\n        penetration = (radius - distance) as Fixed;\n\n        if (distance > 0) {\n            const invDist = fpDiv(FP_ONE, distance);\n            // Normal points from circle toward box (from A to B)\n            // diffX/diffY points from box surface toward circle, so negate\n            normalX = fpMul((-diffX) as Fixed, invDist);\n            normalY = fpMul((-diffY) as Fixed, invDist);\n        } else {\n            // Edge case: circle exactly on box corner\n            normalX = FP_ONE;\n            normalY = 0 as Fixed;\n        }\n    }\n\n    // Contact point on circle surface (toward box)\n    const contactX = (circle.position.x + fpMul(normalX, radius)) as Fixed;\n    const contactY = (circle.position.y + fpMul(normalY, radius)) as Fixed;\n\n    return {\n        bodyA: circle,\n        bodyB: box,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\n/**\n * Resolve collision by applying position correction and velocity impulses.\n *\n * For kinematic bodies: position correction only (no velocity response)\n * For dynamic bodies: both position and velocity correction\n */\nexport function resolveCollision2D(contact: Contact2D): void {\n    const { bodyA, bodyB, normal, depth } = contact;\n\n    // Skip triggers\n    if (bodyA.isSensor || bodyB.isSensor) return;\n\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Static-Static: nothing to do\n    if (typeA === BodyType2D.Static && typeB === BodyType2D.Static) return;\n\n    // Apply position correction based on body types\n    applyPositionCorrection(bodyA, bodyB, normal, depth);\n\n    // Apply velocity impulses only for dynamic bodies\n    if (typeA === BodyType2D.Dynamic || typeB === BodyType2D.Dynamic) {\n        applyVelocityImpulse(bodyA, bodyB, normal);\n    }\n}\n\n/**\n * Apply position correction to separate overlapping bodies.\n * Called once per contact, not iterated.\n */\nfunction applyPositionCorrection(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    depth: Fixed\n): void {\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Determine how to distribute the correction\n    const aMovable = typeA !== BodyType2D.Static;\n    const bMovable = typeB !== BodyType2D.Static;\n\n    if (!aMovable && !bMovable) return;\n\n    // Tiny slop to prevent jitter (0.01 units)\n    const slop = toFixed(0.01);\n    const correctionDepth = fpMax(0 as Fixed, (depth - slop) as Fixed);\n\n    if (correctionDepth <= 0) return;\n\n    if (aMovable && bMovable) {\n        // Both movable: split correction equally\n        const halfCorrection = (correctionDepth >> 1) as Fixed;\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, halfCorrection)) as Fixed;\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, halfCorrection)) as Fixed;\n    } else if (aMovable) {\n        // Only A moves\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, correctionDepth)) as Fixed;\n    } else {\n        // Only B moves\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, correctionDepth)) as Fixed;\n    }\n}\n\n/**\n * Apply velocity impulse for dynamic body collisions.\n */\nfunction applyVelocityImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2\n): void {\n    // Get effective inverse masses (0 for non-dynamic)\n    const invMassA = bodyA.type === BodyType2D.Dynamic ? bodyA.invMass : 0 as Fixed;\n    const invMassB = bodyB.type === BodyType2D.Dynamic ? bodyB.invMass : 0 as Fixed;\n    const totalInvMass = (invMassA + invMassB) as Fixed;\n\n    if (totalInvMass === 0) return;\n\n    // Relative velocity (B relative to A)\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    // Velocity along collision normal\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Don't resolve if separating\n    if (velAlongNormal > 0) return;\n\n    // Coefficient of restitution (bounciness)\n    const restitution = fpMin(bodyA.restitution, bodyB.restitution);\n\n    // Impulse magnitude\n    const impulseMag = fpDiv(\n        fpMul((-(FP_ONE + restitution)) as Fixed, velAlongNormal),\n        totalInvMass\n    );\n\n    // Apply impulse\n    const impulseX = fpMul(normal.x, impulseMag);\n    const impulseY = fpMul(normal.y, impulseMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(impulseX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(impulseY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(impulseX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(impulseY, invMassB)) as Fixed;\n    }\n\n    // Friction impulse\n    applyFrictionImpulse(bodyA, bodyB, normal, impulseMag, invMassA, invMassB, totalInvMass);\n}\n\n/**\n * Apply friction impulse tangent to collision normal.\n */\nfunction applyFrictionImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    normalImpulse: Fixed,\n    invMassA: Fixed,\n    invMassB: Fixed,\n    totalInvMass: Fixed\n): void {\n    // Recalculate relative velocity after normal impulse\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Tangent velocity\n    const tangentX = (relVelX - fpMul(normal.x, velAlongNormal)) as Fixed;\n    const tangentY = (relVelY - fpMul(normal.y, velAlongNormal)) as Fixed;\n    const tangentLenSq = (fpMul(tangentX, tangentX) + fpMul(tangentY, tangentY)) as Fixed;\n\n    if (tangentLenSq === 0) return;\n\n    const tangentLen = fpSqrt(tangentLenSq);\n    const invTangentLen = fpDiv(FP_ONE, tangentLen);\n    const tangentNormX = fpMul(tangentX, invTangentLen);\n    const tangentNormY = fpMul(tangentY, invTangentLen);\n\n    // Friction coefficient\n    const friction = fpMul(bodyA.friction, bodyB.friction);\n\n    // Friction impulse magnitude\n    const tangentVel = (fpMul(relVelX, tangentNormX) + fpMul(relVelY, tangentNormY)) as Fixed;\n    let frictionMag = fpDiv(-tangentVel, totalInvMass);\n\n    // Coulomb friction: clamp to mu * normal force\n    const maxFriction = fpMul(friction, fpAbs(normalImpulse));\n    if (fpAbs(frictionMag) > maxFriction) {\n        frictionMag = frictionMag > 0 ? maxFriction : (-maxFriction) as Fixed;\n    }\n\n    // Apply friction\n    const frictionX = fpMul(tangentNormX, frictionMag);\n    const frictionY = fpMul(tangentNormY, frictionMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(frictionX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(frictionY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(frictionX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(frictionY, invMassB)) as Fixed;\n    }\n}\n", "/**\r\n * Spatial Hash Grid for O(1) Broad Phase Collision Detection\r\n *\r\n * Divides the world into fixed-size cells. Bodies are hashed to cells\r\n * based on their position. Collision queries only check nearby cells.\r\n *\r\n * Handles oversized entities (larger than cell size) by checking them\r\n * against all other entities - since there are typically few of these,\r\n * the O(n) cost is acceptable.\r\n *\r\n * Optimal for .io games with many uniform-sized entities (food, bullets)\r\n * plus a few large obstacles or grown players.\r\n */\r\n\r\nimport { RigidBody2D } from './rigid-body';\r\nimport { Fixed, toFloat } from '../../math/fixed';\r\nimport { Shape2DType, CircleShape, BoxShape2D } from './shapes';\r\n\r\n// ============================================\r\n// Helper: Get body radius for size comparison\r\n// ============================================\r\n\r\nfunction getBodyRadius(body: RigidBody2D): number {\r\n    if (body.shape.type === Shape2DType.Circle) {\r\n        return toFloat((body.shape as CircleShape).radius);\r\n    } else {\r\n        const box = body.shape as BoxShape2D;\r\n        // Use diagonal half-length as radius\r\n        const hw = toFloat(box.halfWidth);\r\n        const hh = toFloat(box.halfHeight);\r\n        return Math.sqrt(hw * hw + hh * hh);\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Spatial Hash Grid\r\n// ============================================\r\n\r\nexport class SpatialHash2D {\r\n    private cellSize: number;\r\n    private invCellSize: number;\r\n    private cells: Map<number, RigidBody2D[]> = new Map();\r\n    private bodyToCell: Map<RigidBody2D, number> = new Map();\r\n\r\n    // Oversized entities (diameter > cellSize) - checked against all others\r\n    private oversized: RigidBody2D[] = [];\r\n    // All regular (non-oversized) bodies for oversized checks\r\n    private allRegular: RigidBody2D[] = [];\r\n\r\n    /**\r\n     * Create a spatial hash grid.\r\n     * @param cellSize Size of each cell. Entities larger than this are\r\n     *                 handled specially (checked against all others).\r\n     */\r\n    constructor(cellSize: number = 64) {\r\n        this.cellSize = cellSize;\r\n        this.invCellSize = 1 / cellSize;\r\n    }\r\n\r\n    /**\r\n     * Hash a position to a cell key.\r\n     * Uses bit packing for fast integer key: (x << 16) | y\r\n     */\r\n    private hashPosition(x: number, y: number): number {\r\n        const cellX = Math.floor(x * this.invCellSize) & 0xFFFF;\r\n        const cellY = Math.floor(y * this.invCellSize) & 0xFFFF;\r\n        return (cellX << 16) | cellY;\r\n    }\r\n\r\n    /**\r\n     * Clear all cells (call at start of each frame).\r\n     */\r\n    clear(): void {\r\n        this.cells.clear();\r\n        this.bodyToCell.clear();\r\n        this.oversized.length = 0;\r\n        this.allRegular.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Insert a body into the grid.\r\n     * Oversized bodies (diameter > cellSize) are tracked separately.\r\n     */\r\n    insert(body: RigidBody2D): void {\r\n        const radius = getBodyRadius(body);\r\n        const diameter = radius * 2;\r\n\r\n        // Oversized entities are checked against everything\r\n        if (diameter > this.cellSize) {\r\n            this.oversized.push(body);\r\n            return;\r\n        }\r\n\r\n        // Regular entities go into spatial hash\r\n        this.allRegular.push(body);\r\n\r\n        const x = toFloat(body.position.x);\r\n        const y = toFloat(body.position.y);\r\n        const key = this.hashPosition(x, y);\r\n\r\n        let cell = this.cells.get(key);\r\n        if (!cell) {\r\n            cell = [];\r\n            this.cells.set(key, cell);\r\n        }\r\n        cell.push(body);\r\n        this.bodyToCell.set(body, key);\r\n    }\r\n\r\n    /**\r\n     * Insert all bodies into the grid.\r\n     */\r\n    insertAll(bodies: RigidBody2D[]): void {\r\n        for (const body of bodies) {\r\n            this.insert(body);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all bodies in the same cell as a position.\r\n     */\r\n    queryPoint(x: number, y: number): RigidBody2D[] {\r\n        const key = this.hashPosition(x, y);\r\n        return this.cells.get(key) || [];\r\n    }\r\n\r\n    /**\r\n     * Get all bodies in the same and adjacent cells (3x3 neighborhood).\r\n     * This handles bodies near cell boundaries.\r\n     */\r\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\r\n        const x = toFloat(body.position.x);\r\n        const y = toFloat(body.position.y);\r\n        const cellX = Math.floor(x * this.invCellSize);\r\n        const cellY = Math.floor(y * this.invCellSize);\r\n\r\n        const result: RigidBody2D[] = [];\r\n\r\n        // Check 3x3 grid of cells\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            for (let dy = -1; dy <= 1; dy++) {\r\n                const nx = (cellX + dx) & 0xFFFF;\r\n                const ny = (cellY + dy) & 0xFFFF;\r\n                const key = (nx << 16) | ny;\r\n                const cell = this.cells.get(key);\r\n                if (cell) {\r\n                    for (const other of cell) {\r\n                        if (other !== body) {\r\n                            result.push(other);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Query bodies within a radius (for larger entities that span multiple cells).\r\n     */\r\n    queryRadius(x: number, y: number, radius: number): RigidBody2D[] {\r\n        const cellRadius = Math.ceil(radius * this.invCellSize);\r\n        const cellX = Math.floor(x * this.invCellSize);\r\n        const cellY = Math.floor(y * this.invCellSize);\r\n\r\n        const result: RigidBody2D[] = [];\r\n        const seen = new Set<RigidBody2D>();\r\n\r\n        for (let dx = -cellRadius; dx <= cellRadius; dx++) {\r\n            for (let dy = -cellRadius; dy <= cellRadius; dy++) {\r\n                const nx = (cellX + dx) & 0xFFFF;\r\n                const ny = (cellY + dy) & 0xFFFF;\r\n                const key = (nx << 16) | ny;\r\n                const cell = this.cells.get(key);\r\n                if (cell) {\r\n                    for (const body of cell) {\r\n                        if (!seen.has(body)) {\r\n                            seen.add(body);\r\n                            result.push(body);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Iterate over potential collision pairs, calling the callback for each.\r\n     * Each pair is visited exactly once. No Set or deduplication needed -\r\n     * the algorithm structure guarantees uniqueness.\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        for (const [key, cell] of this.cells) {\r\n            // Check within same cell - pairs (i, j) where i < j are unique\r\n            for (let i = 0; i < cell.length; i++) {\r\n                for (let j = i + 1; j < cell.length; j++) {\r\n                    callback(cell[i], cell[j]);\r\n                }\r\n            }\r\n\r\n            // Check against neighbor cells with HIGHER keys only\r\n            // This ensures each cross-cell pair is checked exactly once\r\n            const cellX = (key >> 16) & 0xFFFF;\r\n            const cellY = key & 0xFFFF;\r\n\r\n            // Only check neighbors with higher cell keys to avoid duplicates\r\n            const neighbors = [\r\n                ((cellX + 1) & 0xFFFF) << 16 | cellY,           // Right (+x)\r\n                (cellX << 16) | ((cellY + 1) & 0xFFFF),         // Below (+y)\r\n                (((cellX + 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF), // Below-right (+x,+y)\r\n            ];\r\n\r\n            for (const neighborKey of neighbors) {\r\n                // Only process if neighbor key > current key (avoids duplicates)\r\n                if (neighborKey <= key) continue;\r\n\r\n                const neighborCell = this.cells.get(neighborKey);\r\n                if (!neighborCell) continue;\r\n\r\n                for (const a of cell) {\r\n                    for (const b of neighborCell) {\r\n                        callback(a, b);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Below-left neighbor needs special handling (has lower x but higher y)\r\n            const belowLeftKey = (((cellX - 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF);\r\n            const belowLeftCell = this.cells.get(belowLeftKey);\r\n            if (belowLeftCell) {\r\n                for (const a of cell) {\r\n                    for (const b of belowLeftCell) {\r\n                        callback(a, b);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Handle oversized entities - check against ALL other entities\r\n        // This is O(oversized * total) but there are typically very few oversized entities\r\n        const oversized = this.oversized;\r\n        const allRegular = this.allRegular;\r\n\r\n        // Oversized vs oversized\r\n        for (let i = 0; i < oversized.length; i++) {\r\n            for (let j = i + 1; j < oversized.length; j++) {\r\n                callback(oversized[i], oversized[j]);\r\n            }\r\n        }\r\n\r\n        // Oversized vs all regular entities\r\n        for (const big of oversized) {\r\n            for (const small of allRegular) {\r\n                callback(big, small);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get potential collision pairs as an array.\r\n     * For large body counts, prefer forEachPair() to avoid array allocation.\r\n     */\r\n    getPotentialPairs(): Array<[RigidBody2D, RigidBody2D]> {\r\n        const pairs: Array<[RigidBody2D, RigidBody2D]> = [];\r\n        this.forEachPair((a, b) => pairs.push([a, b]));\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Get statistics for debugging.\r\n     */\r\n    getStats(): { cellCount: number; maxPerCell: number; avgPerCell: number; oversizedCount: number } {\r\n        let maxPerCell = 0;\r\n        let totalBodies = 0;\r\n\r\n        for (const cell of this.cells.values()) {\r\n            maxPerCell = Math.max(maxPerCell, cell.length);\r\n            totalBodies += cell.length;\r\n        }\r\n\r\n        return {\r\n            cellCount: this.cells.size,\r\n            maxPerCell,\r\n            avgPerCell: this.cells.size > 0 ? totalBodies / this.cells.size : 0,\r\n            oversizedCount: this.oversized.length\r\n        };\r\n    }\r\n}\r\n", "/**\r\n * 2D Physics World\r\n *\r\n * Manages the 2D physics simulation including gravity, collision detection,\r\n * and integration of velocities and positions.\r\n */\r\n\r\nimport { Fixed, FP_ONE, FP_HALF, toFixed, toFloat, fpMul, fpDiv, fpAbs } from '../../math/fixed';\r\nimport { aabb2DOverlap, Shape2D, Shape2DType, CircleShape, BoxShape2D } from './shapes';\r\nimport { RigidBody2D, BodyType2D, Vec2, vec2, vec2Zero, vec2Add, vec2Scale, vec2LengthSq, createBody2D, setBody2DIdCounter, getBody2DIdCounter } from './rigid-body';\r\nimport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\r\nimport { shouldCollide, CollisionFilter, DEFAULT_FILTER } from './layers';\r\nimport { TriggerState, TriggerEvent } from './trigger';\r\nimport { SpatialHash2D } from './spatial-hash';\r\n\r\n// ============================================\r\n// Constants\r\n// ============================================\r\n\r\nconst GRAVITY_2D: Vec2 = { x: 0, y: toFixed(-30) };  // -30 units/s\u00B2 (down in Y)\r\nconst LINEAR_DAMPING = toFixed(0.1);\r\nconst ANGULAR_DAMPING = toFixed(0.1);\r\nconst SLEEP_THRESHOLD = toFixed(0.12);\r\nconst SLEEP_FRAMES_REQUIRED = 20;\r\n\r\n// Default spatial hash cell size - should be >= largest entity diameter\r\nconst DEFAULT_CELL_SIZE = 64;\r\n\r\n// ============================================\r\n// Trigger Event 2D\r\n// ============================================\r\n\r\nexport interface TriggerEvent2D {\r\n    trigger: RigidBody2D;\r\n    other: RigidBody2D;\r\n}\r\n\r\n// ============================================\r\n// Contact Listener\r\n// ============================================\r\n\r\nexport interface ContactListener2D {\r\n    onContact(bodyA: RigidBody2D, bodyB: RigidBody2D): void;\r\n}\r\n\r\n// ============================================\r\n// World Interface\r\n// ============================================\r\n\r\nexport interface World2D {\r\n    bodies: RigidBody2D[];\r\n    gravity: Vec2;\r\n    dt: Fixed;\r\n    contactListener?: ContactListener2D;\r\n    /** Reference to Physics2D system for type-based collision handling */\r\n    physics2d?: any;\r\n    /** Step the physics simulation */\r\n    step(): void;\r\n}\r\n\r\nexport function createWorld2D(dt: number = 1 / 60): World2D {\r\n    const world: World2D = {\r\n        bodies: [],\r\n        gravity: { x: GRAVITY_2D.x, y: GRAVITY_2D.y },\r\n        dt: toFixed(dt),\r\n        step() {\r\n            stepWorld2D(world);\r\n        }\r\n    };\r\n    return world;\r\n}\r\n\r\nexport function addBody2D(world: World2D, body: RigidBody2D): void {\r\n    world.bodies.push(body);\r\n}\r\n\r\nexport function removeBody2D(world: World2D, body: RigidBody2D): void {\r\n    const index = world.bodies.indexOf(body);\r\n    if (index >= 0) {\r\n        world.bodies.splice(index, 1);\r\n    }\r\n}\r\n\r\n// ============================================\r\n// World Step\r\n// ============================================\r\n\r\nexport function stepWorld2D(world: World2D): { contacts: Contact2D[]; triggers: TriggerEvent2D[] } {\r\n    const { gravity, dt } = world;\r\n    const contacts: Contact2D[] = [];\r\n    const triggerOverlaps: TriggerEvent2D[] = [];\r\n\r\n    // Collect collision pairs for deterministic callback firing AFTER detection\r\n    const collisionPairs: Array<{ entityA: any; entityB: any; labelA: string; labelB: string }> = [];\r\n\r\n    // Sort bodies by label for deterministic collision processing\r\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\r\n\r\n    // Integrate velocities (apply gravity)\r\n    for (const body of bodies) {\r\n        if (body.type !== BodyType2D.Dynamic) continue;\r\n        if (body.isSleeping) continue;\r\n\r\n        // Apply gravity\r\n        body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(gravity, dt));\r\n\r\n        // Apply damping\r\n        const linearDamp = (FP_ONE - LINEAR_DAMPING) as Fixed;\r\n        const angularDamp = (FP_ONE - ANGULAR_DAMPING) as Fixed;\r\n\r\n        body.linearVelocity = vec2Scale(body.linearVelocity, linearDamp);\r\n        body.angularVelocity = fpMul(body.angularVelocity, angularDamp);\r\n    }\r\n\r\n    // Collision detection using spatial hash for O(1) broad phase\r\n    // Cell size should be >= largest entity diameter for optimal performance\r\n    const spatialHash = new SpatialHash2D(DEFAULT_CELL_SIZE);\r\n    spatialHash.insertAll(bodies);\r\n\r\n    // Process potential collision pairs directly (no intermediate array allocation)\r\n    spatialHash.forEachPair((bodyA, bodyB) => {\r\n        // Skip static-static (no collision needed)\r\n        if (bodyA.type === BodyType2D.Static && bodyB.type === BodyType2D.Static) return;\r\n        if (!shouldCollide(bodyA.filter, bodyB.filter)) return;\r\n\r\n        // Broad phase: AABB overlap test (spatial hash gives candidates, still need precise AABB)\r\n        const aabbA = computeAABB2D(bodyA);\r\n        const aabbB = computeAABB2D(bodyB);\r\n        if (!aabb2DOverlap(aabbA, aabbB)) return;\r\n\r\n        // Narrow phase: precise collision detection\r\n        const contact = detectCollision2D(bodyA, bodyB);\r\n\r\n        if (!contact) return;\r\n\r\n        // Collect entity pairs for callback firing (all collisions including sensors)\r\n        const entityA = bodyA.userData;\r\n        const entityB = bodyB.userData;\r\n        if (entityA || entityB) {\r\n            collisionPairs.push({\r\n                entityA,\r\n                entityB,\r\n                labelA: bodyA.label,\r\n                labelB: bodyB.label\r\n            });\r\n        }\r\n\r\n        // Sensors: detect overlap but skip physics response\r\n        if (bodyA.isSensor || bodyB.isSensor) {\r\n            if (bodyA.isSensor) triggerOverlaps.push({ trigger: bodyA, other: bodyB });\r\n            if (bodyB.isSensor) triggerOverlaps.push({ trigger: bodyB, other: bodyA });\r\n            return;\r\n        }\r\n\r\n        // Store contact and fire contact listener\r\n        contacts.push(contact);\r\n        if (world.contactListener) world.contactListener.onContact(bodyA, bodyB);\r\n\r\n        // Resolve collision (position + velocity)\r\n        resolveCollision2D(contact);\r\n    });\r\n\r\n    // Fire entity collision callbacks AFTER all detection is complete\r\n    // Sort by both labels to ensure deterministic ordering across clients\r\n    collisionPairs.sort((a, b) => {\r\n        const cmp = a.labelA.localeCompare(b.labelA);\r\n        return cmp !== 0 ? cmp : a.labelB.localeCompare(b.labelB);\r\n    });\r\n\r\n    for (const pair of collisionPairs) {\r\n        // Check active status at callback time (may have changed during earlier callbacks)\r\n        if (pair.entityA?.active === false || pair.entityB?.active === false) continue;\r\n\r\n        // Try Physics2D type-based handlers first (preferred - auto-restored)\r\n        if (world.physics2d?.handleCollision?.(pair.entityA, pair.entityB)) {\r\n            continue; // Handler found and called, skip entity.onCollision\r\n        }\r\n\r\n        // Fall back to entity.onCollision (legacy - requires manual restore in onSnapshot)\r\n        if (pair.entityA?.onCollision) {\r\n            pair.entityA.onCollision(pair.entityB);\r\n        }\r\n        if (pair.entityB?.onCollision) {\r\n            pair.entityB.onCollision(pair.entityA);\r\n        }\r\n    }\r\n\r\n    // Integrate positions\r\n    for (const body of bodies) {\r\n        if (body.type === BodyType2D.Static) continue;\r\n        if (body.isSleeping) continue;\r\n\r\n        // Clamp tiny velocities\r\n        const linearClamp = toFixed(0.05);\r\n        const angularClamp = toFixed(0.01);\r\n\r\n        if (fpAbs(body.linearVelocity.x) < linearClamp) body.linearVelocity.x = 0;\r\n        if (fpAbs(body.linearVelocity.y) < linearClamp) body.linearVelocity.y = 0;\r\n        if (fpAbs(body.angularVelocity) < angularClamp) body.angularVelocity = 0;\r\n\r\n        // Update position\r\n        body.position = vec2Add(body.position, vec2Scale(body.linearVelocity, dt));\r\n\r\n        // Update angle\r\n        if (!body.lockRotation && body.angularVelocity !== 0) {\r\n            body.angle = (body.angle + fpMul(body.angularVelocity, dt)) as Fixed;\r\n        }\r\n\r\n        // Sleep detection\r\n        const speedSq = vec2LengthSq(body.linearVelocity);\r\n        const angSpeedSq = fpMul(body.angularVelocity, body.angularVelocity);\r\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\r\n\r\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\r\n            body.sleepFrames++;\r\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\r\n                body.isSleeping = true;\r\n                body.linearVelocity = vec2Zero();\r\n                body.angularVelocity = 0;\r\n            }\r\n        } else {\r\n            body.sleepFrames = 0;\r\n            body.isSleeping = false;\r\n        }\r\n    }\r\n\r\n    return { contacts, triggers: triggerOverlaps };\r\n}\r\n\r\n// ============================================\r\n// State Serialization\r\n// ============================================\r\n\r\n/**\r\n * Serialized shape data for snapshots.\r\n * Contains all information needed to recreate a shape.\r\n */\r\nexport interface ShapeState2D {\r\n    type: Shape2DType;\r\n    // Circle\r\n    radius?: Fixed;\r\n    // Box\r\n    halfWidth?: Fixed;\r\n    halfHeight?: Fixed;\r\n}\r\n\r\n/**\r\n * Complete body state for snapshots.\r\n * Contains ALL information needed to recreate a body from scratch.\r\n * This is critical for late joiners who have an empty world.\r\n */\r\nexport interface BodyState2D {\r\n    // Identity\r\n    id: number;\r\n    label: string;\r\n    bodyType: BodyType2D;\r\n\r\n    // Shape (required for body creation)\r\n    shape: ShapeState2D;\r\n\r\n    // Transform\r\n    px: Fixed;\r\n    py: Fixed;\r\n    angle: Fixed;\r\n\r\n    // Velocity\r\n    vx: Fixed;\r\n    vy: Fixed;\r\n    av: Fixed;\r\n\r\n    // Material properties\r\n    mass: Fixed;\r\n    restitution: Fixed;\r\n    friction: Fixed;\r\n\r\n    // State flags\r\n    isSleeping: boolean;\r\n    sleepFrames: number;\r\n    lockRotation: boolean;\r\n    isSensor: boolean;\r\n    isBullet: boolean;\r\n\r\n    // Collision filter\r\n    filter: CollisionFilter;\r\n\r\n    // User data (game-specific)\r\n    userData?: any;\r\n}\r\n\r\nexport interface WorldState2D {\r\n    bodies: BodyState2D[];\r\n}\r\n\r\nexport interface WorldStateWithHash2D {\r\n    state: WorldState2D;\r\n    hash: number;\r\n}\r\n\r\n/**\r\n * Serialize a shape to ShapeState2D.\r\n */\r\nfunction serializeShape(shape: Shape2D): ShapeState2D {\r\n    if (shape.type === Shape2DType.Circle) {\r\n        return {\r\n            type: Shape2DType.Circle,\r\n            radius: (shape as CircleShape).radius,\r\n        };\r\n    } else {\r\n        const box = shape as BoxShape2D;\r\n        return {\r\n            type: Shape2DType.Box,\r\n            halfWidth: box.halfWidth,\r\n            halfHeight: box.halfHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Deserialize ShapeState2D back to Shape2D.\r\n */\r\nfunction deserializeShape(state: ShapeState2D): Shape2D {\r\n    if (state.type === Shape2DType.Circle) {\r\n        return {\r\n            type: Shape2DType.Circle,\r\n            radius: state.radius!,\r\n        } as CircleShape;\r\n    } else {\r\n        return {\r\n            type: Shape2DType.Box,\r\n            halfWidth: state.halfWidth!,\r\n            halfHeight: state.halfHeight!,\r\n        } as BoxShape2D;\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize a single body to BodyState2D.\r\n * Contains ALL information needed to recreate the body.\r\n */\r\nfunction serializeBody(b: RigidBody2D): BodyState2D {\r\n    return {\r\n        id: b.id,\r\n        label: b.label,\r\n        bodyType: b.type,\r\n        shape: serializeShape(b.shape),\r\n        px: b.position.x,\r\n        py: b.position.y,\r\n        angle: b.angle,\r\n        vx: b.linearVelocity.x,\r\n        vy: b.linearVelocity.y,\r\n        av: b.angularVelocity,\r\n        mass: b.mass,\r\n        restitution: b.restitution,\r\n        friction: b.friction,\r\n        isSleeping: b.isSleeping,\r\n        sleepFrames: b.sleepFrames,\r\n        lockRotation: b.lockRotation,\r\n        isSensor: b.isSensor,\r\n        isBullet: b.isBullet,\r\n        filter: { ...b.filter },\r\n        userData: b.userData,\r\n    };\r\n}\r\n\r\n/**\r\n * Save world state - use saveWorldStateWithHash2D for efficiency when you need both\r\n */\r\nexport function saveWorldState2D(world: World2D): WorldState2D {\r\n    return {\r\n        bodies: world.bodies.map(serializeBody)\r\n    };\r\n}\r\n\r\n/**\r\n * Save world state AND compute hash in a single pass.\r\n * More efficient than calling saveWorldState2D + separate hash function.\r\n */\r\nexport function saveWorldStateWithHash2D(world: World2D): WorldStateWithHash2D {\r\n    const bodies: BodyState2D[] = [];\r\n    let hash = 0;\r\n\r\n    // Single pass: serialize and hash simultaneously\r\n    for (const b of world.bodies) {\r\n        const bs = serializeBody(b);\r\n        bodies.push(bs);\r\n\r\n        // Compute hash inline - include all determinism-relevant state\r\n        hash = ((hash << 5) - hash + bs.id) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.bodyType) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.shape.type) >>> 0;\r\n        if (bs.shape.radius !== undefined) {\r\n            hash = ((hash << 5) - hash + bs.shape.radius) >>> 0;\r\n        }\r\n        if (bs.shape.halfWidth !== undefined) {\r\n            hash = ((hash << 5) - hash + bs.shape.halfWidth) >>> 0;\r\n            hash = ((hash << 5) - hash + bs.shape.halfHeight!) >>> 0;\r\n        }\r\n        hash = ((hash << 5) - hash + bs.px) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.py) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.vx) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.vy) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.angle) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.av) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.mass) >>> 0;\r\n    }\r\n\r\n    return { state: { bodies }, hash };\r\n}\r\n\r\n/**\r\n * Create a body from serialized state.\r\n * This is used for late joiners who need to recreate bodies from scratch.\r\n */\r\nfunction createBodyFromState(bs: BodyState2D): RigidBody2D {\r\n    const shape = deserializeShape(bs.shape);\r\n\r\n    // We need to create the body with the correct ID\r\n    // Temporarily set the counter to ensure consistent IDs\r\n    const savedCounter = getBody2DIdCounter();\r\n\r\n    // Create body at position (0, 0) - we'll set exact position after\r\n    // Use toFloat to convert fixed-point back to float for createBody2D\r\n    const body = createBody2D(bs.bodyType, shape, 0, 0, bs.label);\r\n\r\n    // Override the auto-generated ID with the snapshot ID\r\n    body.id = bs.id;\r\n\r\n    // Restore the counter (createBody2D incremented it)\r\n    // The next new body will use the max ID from snapshot + 1\r\n    setBody2DIdCounter(savedCounter);\r\n\r\n    // Set all properties from snapshot\r\n    body.position = { x: bs.px, y: bs.py };\r\n    body.angle = bs.angle;\r\n    body.linearVelocity = { x: bs.vx, y: bs.vy };\r\n    body.angularVelocity = bs.av;\r\n\r\n    // Mass properties - need to recalculate invMass and inertia\r\n    body.mass = bs.mass;\r\n    body.invMass = bs.mass > 0 ? fpDiv(FP_ONE, bs.mass) : 0;\r\n\r\n    // Recalculate inertia based on shape and mass\r\n    if (bs.bodyType === BodyType2D.Dynamic && bs.mass > 0) {\r\n        if (shape.type === Shape2DType.Circle) {\r\n            const r = (shape as CircleShape).radius;\r\n            body.inertia = fpMul(fpMul(bs.mass, FP_HALF), fpMul(r, r));\r\n        } else {\r\n            const box = shape as BoxShape2D;\r\n            const w = (box.halfWidth << 1) as Fixed;\r\n            const h = (box.halfHeight << 1) as Fixed;\r\n            const FP_ONE_TWELFTH = 5461 as Fixed;\r\n            body.inertia = fpMul(fpMul(bs.mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\r\n        }\r\n        body.invInertia = body.inertia > 0 ? fpDiv(FP_ONE, body.inertia) : 0;\r\n    }\r\n\r\n    // Material\r\n    body.restitution = bs.restitution;\r\n    body.friction = bs.friction;\r\n\r\n    // State\r\n    body.isSleeping = bs.isSleeping;\r\n    body.sleepFrames = bs.sleepFrames;\r\n    body.lockRotation = bs.lockRotation;\r\n    body.isSensor = bs.isSensor;\r\n    body.isBullet = bs.isBullet ?? false;\r\n\r\n    // Collision filter\r\n    body.filter = { ...bs.filter };\r\n\r\n    // User data\r\n    body.userData = bs.userData;\r\n\r\n    return body;\r\n}\r\n\r\n/**\r\n * Load world state from snapshot.\r\n *\r\n * IMPORTANT: This function fully recreates the world from the snapshot.\r\n * It handles both:\r\n * 1. Existing worlds (rollback) - updates existing bodies, removes/adds as needed\r\n * 2. Empty worlds (late joiners) - creates all bodies from scratch\r\n *\r\n * The snapshot contains complete body information including shape data,\r\n * so bodies can be fully recreated without any prior state.\r\n */\r\nexport function loadWorldState2D(world: World2D, state: WorldState2D): void {\r\n    // Sort snapshot bodies by label for deterministic iteration\r\n    const sortedBodies = [...state.bodies].sort((a, b) => a.label.localeCompare(b.label));\r\n\r\n    // Build a set of labels in the snapshot\r\n    const snapshotLabels = new Set(sortedBodies.map(bs => bs.label));\r\n\r\n    // Remove bodies not in snapshot\r\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\r\n        if (!snapshotLabels.has(world.bodies[i].label)) {\r\n            world.bodies.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    // Build map of existing bodies\r\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\r\n\r\n    // Track the highest ID we see to update the counter\r\n    let maxId = 0;\r\n\r\n    for (const bs of sortedBodies) {\r\n        if (bs.id > maxId) maxId = bs.id;\r\n\r\n        const existingBody = bodyMap.get(bs.label);\r\n\r\n        if (existingBody) {\r\n            // Update existing body\r\n            existingBody.position = { x: bs.px, y: bs.py };\r\n            existingBody.angle = bs.angle;\r\n            existingBody.linearVelocity = { x: bs.vx, y: bs.vy };\r\n            existingBody.angularVelocity = bs.av;\r\n            existingBody.isSleeping = bs.isSleeping;\r\n            existingBody.sleepFrames = bs.sleepFrames;\r\n            existingBody.lockRotation = bs.lockRotation;\r\n            existingBody.isSensor = bs.isSensor;\r\n            existingBody.restitution = bs.restitution;\r\n            existingBody.friction = bs.friction;\r\n            existingBody.filter = { ...bs.filter };\r\n            if (bs.userData !== undefined) {\r\n                existingBody.userData = bs.userData;\r\n            }\r\n        } else {\r\n            // Create new body from snapshot - this is critical for late joiners\r\n            const newBody = createBodyFromState(bs);\r\n            world.bodies.push(newBody);\r\n        }\r\n    }\r\n\r\n    // Update the body ID counter to be higher than any ID in the snapshot\r\n    // This ensures new bodies created after loading won't have conflicting IDs\r\n    const currentCounter = getBody2DIdCounter();\r\n    if (maxId >= currentCounter) {\r\n        setBody2DIdCounter(maxId + 1);\r\n    }\r\n\r\n    // Sort world bodies by label for deterministic order\r\n    world.bodies.sort((a, b) => a.label.localeCompare(b.label));\r\n}\r\n", "/**\r\n * QuadTree for Dynamic Spatial Partitioning\r\n *\r\n * Recursively subdivides space based on entity density.\r\n * Adapts to mixed entity sizes and non-uniform distributions.\r\n * Ideal for .io games where players grow from tiny to huge.\r\n */\r\n\r\nimport { RigidBody2D } from './rigid-body';\r\nimport { computeAABB2D } from './collision';\r\nimport { toFloat } from '../../math/fixed';\r\n\r\n// ============================================\r\n// Configuration\r\n// ============================================\r\n\r\nconst DEFAULT_MAX_ENTITIES = 8;   // Max entities before subdivision\r\nconst DEFAULT_MAX_DEPTH = 8;      // Max tree depth (prevents infinite subdivision)\r\n\r\n// ============================================\r\n// AABB Helpers\r\n// ============================================\r\n\r\ninterface Bounds {\r\n    minX: number;\r\n    minY: number;\r\n    maxX: number;\r\n    maxY: number;\r\n}\r\n\r\nfunction boundsContains(bounds: Bounds, x: number, y: number): boolean {\r\n    return x >= bounds.minX && x <= bounds.maxX &&\r\n           y >= bounds.minY && y <= bounds.maxY;\r\n}\r\n\r\nfunction boundsIntersects(a: Bounds, b: Bounds): boolean {\r\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\r\n           a.minY <= b.maxY && a.maxY >= b.minY;\r\n}\r\n\r\nfunction getBodyBounds(body: RigidBody2D): Bounds {\r\n    const aabb = computeAABB2D(body);\r\n    return {\r\n        minX: toFloat(aabb.minX),\r\n        minY: toFloat(aabb.minY),\r\n        maxX: toFloat(aabb.maxX),\r\n        maxY: toFloat(aabb.maxY)\r\n    };\r\n}\r\n\r\n// ============================================\r\n// QuadTree Node\r\n// ============================================\r\n\r\nclass QuadTreeNode {\r\n    bounds: Bounds;\r\n    depth: number;\r\n    maxEntities: number;\r\n    maxDepth: number;\r\n\r\n    // Entities stored in this node (entities that span multiple children stay here)\r\n    entities: RigidBody2D[] = [];\r\n\r\n    // Child quadrants: NW, NE, SW, SE (null until subdivided)\r\n    children: [QuadTreeNode, QuadTreeNode, QuadTreeNode, QuadTreeNode] | null = null;\r\n\r\n    constructor(bounds: Bounds, depth: number, maxEntities: number, maxDepth: number) {\r\n        this.bounds = bounds;\r\n        this.depth = depth;\r\n        this.maxEntities = maxEntities;\r\n        this.maxDepth = maxDepth;\r\n    }\r\n\r\n    /**\r\n     * Insert an entity into the tree.\r\n     */\r\n    insert(body: RigidBody2D, bodyBounds: Bounds): void {\r\n        // If we have children, try to insert into a child\r\n        if (this.children) {\r\n            const index = this.getChildIndex(bodyBounds);\r\n            if (index !== -1) {\r\n                this.children[index].insert(body, bodyBounds);\r\n                return;\r\n            }\r\n            // Entity spans multiple quadrants - store in this node\r\n            this.entities.push(body);\r\n            return;\r\n        }\r\n\r\n        // No children yet - store in this node\r\n        this.entities.push(body);\r\n\r\n        // Subdivide if we have too many entities and haven't reached max depth\r\n        if (this.entities.length > this.maxEntities && this.depth < this.maxDepth) {\r\n            this.subdivide();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subdivide this node into 4 children.\r\n     */\r\n    private subdivide(): void {\r\n        const { minX, minY, maxX, maxY } = this.bounds;\r\n        const midX = (minX + maxX) / 2;\r\n        const midY = (minY + maxY) / 2;\r\n\r\n        this.children = [\r\n            new QuadTreeNode({ minX, minY, maxX: midX, maxY: midY }, this.depth + 1, this.maxEntities, this.maxDepth),           // NW (top-left)\r\n            new QuadTreeNode({ minX: midX, minY, maxX, maxY: midY }, this.depth + 1, this.maxEntities, this.maxDepth),           // NE (top-right)\r\n            new QuadTreeNode({ minX, minY: midY, maxX: midX, maxY }, this.depth + 1, this.maxEntities, this.maxDepth),           // SW (bottom-left)\r\n            new QuadTreeNode({ minX: midX, minY: midY, maxX, maxY }, this.depth + 1, this.maxEntities, this.maxDepth),           // SE (bottom-right)\r\n        ];\r\n\r\n        // Re-insert entities into children\r\n        const oldEntities = this.entities;\r\n        this.entities = [];\r\n\r\n        for (const body of oldEntities) {\r\n            const bodyBounds = getBodyBounds(body);\r\n            const index = this.getChildIndex(bodyBounds);\r\n            if (index !== -1) {\r\n                this.children[index].insert(body, bodyBounds);\r\n            } else {\r\n                // Entity spans multiple quadrants - keep in this node\r\n                this.entities.push(body);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the child index for an entity, or -1 if it spans multiple children.\r\n     */\r\n    private getChildIndex(bodyBounds: Bounds): number {\r\n        const { minX, minY, maxX, maxY } = this.bounds;\r\n        const midX = (minX + maxX) / 2;\r\n        const midY = (minY + maxY) / 2;\r\n\r\n        const inTop = bodyBounds.maxY <= midY;\r\n        const inBottom = bodyBounds.minY >= midY;\r\n        const inLeft = bodyBounds.maxX <= midX;\r\n        const inRight = bodyBounds.minX >= midX;\r\n\r\n        if (inTop && inLeft) return 0;  // NW\r\n        if (inTop && inRight) return 1; // NE\r\n        if (inBottom && inLeft) return 2; // SW\r\n        if (inBottom && inRight) return 3; // SE\r\n\r\n        return -1; // Spans multiple quadrants\r\n    }\r\n\r\n    /**\r\n     * Query all entities that might collide with the given bounds.\r\n     */\r\n    query(queryBounds: Bounds, result: RigidBody2D[]): void {\r\n        // Check entities in this node\r\n        for (const body of this.entities) {\r\n            result.push(body);\r\n        }\r\n\r\n        // Check children\r\n        if (this.children) {\r\n            for (const child of this.children) {\r\n                if (boundsIntersects(child.bounds, queryBounds)) {\r\n                    child.query(queryBounds, result);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate all potential collision pairs (iterative version).\r\n     * Uses stack-based traversal to avoid recursive overhead.\r\n     */\r\n    forEachPairIterative(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        // Stack entries: [node, ancestorStartIndex]\r\n        const stack: Array<{ node: QuadTreeNode; ancestorStart: number }> = [];\r\n        const ancestors: RigidBody2D[] = [];\r\n\r\n        stack.push({ node: this, ancestorStart: 0 });\r\n\r\n        while (stack.length > 0) {\r\n            const { node, ancestorStart } = stack.pop()!;\r\n\r\n            // Trim ancestors to correct level\r\n            ancestors.length = ancestorStart;\r\n\r\n            // Check pairs within this node's entities\r\n            const entities = node.entities;\r\n            for (let i = 0; i < entities.length; i++) {\r\n                for (let j = i + 1; j < entities.length; j++) {\r\n                    callback(entities[i], entities[j]);\r\n                }\r\n            }\r\n\r\n            // Check this node's entities against ancestors\r\n            for (let i = 0; i < ancestorStart; i++) {\r\n                for (const entity of entities) {\r\n                    callback(ancestors[i], entity);\r\n                }\r\n            }\r\n\r\n            // Add this node's entities to ancestors for children\r\n            const newAncestorStart = ancestors.length;\r\n            for (const entity of entities) {\r\n                ancestors.push(entity);\r\n            }\r\n\r\n            // Push children in reverse order (so NW is processed first)\r\n            if (node.children) {\r\n                for (let i = 3; i >= 0; i--) {\r\n                    stack.push({ node: node.children[i], ancestorStart: ancestors.length });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate all potential collision pairs.\r\n     * Callback receives each unique pair exactly once.\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void, ancestors: RigidBody2D[] = []): void {\r\n        this.forEachPairIterative(callback);\r\n    }\r\n\r\n    /**\r\n     * Get statistics about this subtree.\r\n     */\r\n    getStats(): { nodeCount: number; maxDepth: number; entityCount: number } {\r\n        let nodeCount = 1;\r\n        let maxDepth = this.depth;\r\n        let entityCount = this.entities.length;\r\n\r\n        if (this.children) {\r\n            for (const child of this.children) {\r\n                const childStats = child.getStats();\r\n                nodeCount += childStats.nodeCount;\r\n                maxDepth = Math.max(maxDepth, childStats.maxDepth);\r\n                entityCount += childStats.entityCount;\r\n            }\r\n        }\r\n\r\n        return { nodeCount, maxDepth, entityCount };\r\n    }\r\n}\r\n\r\n// ============================================\r\n// QuadTree2D Public API\r\n// ============================================\r\n\r\nexport class QuadTree2D {\r\n    private root: QuadTreeNode | null = null;\r\n    private maxEntities: number;\r\n    private maxDepth: number;\r\n\r\n    constructor(maxEntities: number = DEFAULT_MAX_ENTITIES, maxDepth: number = DEFAULT_MAX_DEPTH) {\r\n        this.maxEntities = maxEntities;\r\n        this.maxDepth = maxDepth;\r\n    }\r\n\r\n    /**\r\n     * Clear the tree.\r\n     */\r\n    clear(): void {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Insert all bodies into the tree.\r\n     * Automatically computes world bounds from entities.\r\n     */\r\n    insertAll(bodies: RigidBody2D[]): void {\r\n        if (bodies.length === 0) return;\r\n\r\n        // Compute world bounds from all entities (with padding)\r\n        let minX = Infinity, minY = Infinity;\r\n        let maxX = -Infinity, maxY = -Infinity;\r\n\r\n        for (const body of bodies) {\r\n            const bounds = getBodyBounds(body);\r\n            minX = Math.min(minX, bounds.minX);\r\n            minY = Math.min(minY, bounds.minY);\r\n            maxX = Math.max(maxX, bounds.maxX);\r\n            maxY = Math.max(maxY, bounds.maxY);\r\n        }\r\n\r\n        // Add small padding to avoid edge cases\r\n        const padding = 1;\r\n        this.root = new QuadTreeNode(\r\n            { minX: minX - padding, minY: minY - padding, maxX: maxX + padding, maxY: maxY + padding },\r\n            0,\r\n            this.maxEntities,\r\n            this.maxDepth\r\n        );\r\n\r\n        // Insert all bodies\r\n        for (const body of bodies) {\r\n            const bounds = getBodyBounds(body);\r\n            this.root.insert(body, bounds);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Query entities that might collide with the given body.\r\n     */\r\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\r\n        if (!this.root) return [];\r\n        const result: RigidBody2D[] = [];\r\n        const bounds = getBodyBounds(body);\r\n        this.root.query(bounds, result);\r\n        return result.filter(b => b !== body);\r\n    }\r\n\r\n    /**\r\n     * Iterate all potential collision pairs.\r\n     * Each pair is visited exactly once.\r\n     * Order is deterministic (depth-first, NW\u2192NE\u2192SW\u2192SE).\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        if (!this.root) return;\r\n        this.root.forEachPair(callback);\r\n    }\r\n\r\n    /**\r\n     * Get tree statistics for debugging.\r\n     */\r\n    getStats(): { nodeCount: number; maxDepth: number; entityCount: number } {\r\n        if (!this.root) return { nodeCount: 0, maxDepth: 0, entityCount: 0 };\r\n        return this.root.getStats();\r\n    }\r\n}\r\n", "/**\n * Trigger System\n *\n * Handles trigger (sensor) bodies that detect overlap without physics response.\n * Generic implementation shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Body Interface (minimal contract)\n// ============================================\n\n/**\n * Minimal interface for a physics body used by triggers.\n * Both RigidBody (3D) and RigidBody2D implement this.\n */\nexport interface TriggerBody {\n    label: string;\n    isSensor: boolean;\n}\n\n// ============================================\n// Trigger Event\n// ============================================\n\nexport interface TriggerEvent<T extends TriggerBody = TriggerBody> {\n    trigger: T;\n    other: T;\n}\n\ntype TriggerCallback<T extends TriggerBody> = (event: TriggerEvent<T>) => void;\n\n// ============================================\n// Trigger State\n// ============================================\n\nexport class TriggerState<T extends TriggerBody = TriggerBody> {\n    private overlaps = new Map<string, { trigger: T; other: T }>();\n    private enterCallbacks: TriggerCallback<T>[] = [];\n    private stayCallbacks: TriggerCallback<T>[] = [];\n    private exitCallbacks: TriggerCallback<T>[] = [];\n\n    onEnter(cb: TriggerCallback<T>): void { this.enterCallbacks.push(cb); }\n    onStay(cb: TriggerCallback<T>): void { this.stayCallbacks.push(cb); }\n    onExit(cb: TriggerCallback<T>): void { this.exitCallbacks.push(cb); }\n\n    processOverlaps(currentOverlaps: TriggerEvent<T>[]): void {\n        const currentKeys = new Set<string>();\n        const sortedOverlaps = [...currentOverlaps].sort((a, b) => {\n            return this.makeKey(a.trigger, a.other).localeCompare(this.makeKey(b.trigger, b.other));\n        });\n\n        for (const overlap of sortedOverlaps) {\n            const key = this.makeKey(overlap.trigger, overlap.other);\n            currentKeys.add(key);\n\n            if (this.overlaps.has(key)) {\n                for (const cb of this.stayCallbacks) cb(overlap);\n            } else {\n                this.overlaps.set(key, overlap);\n                for (const cb of this.enterCallbacks) cb(overlap);\n            }\n        }\n\n        const sortedExistingKeys = [...this.overlaps.keys()].sort();\n        for (const key of sortedExistingKeys) {\n            if (!currentKeys.has(key)) {\n                const overlap = this.overlaps.get(key)!;\n                this.overlaps.delete(key);\n                for (const cb of this.exitCallbacks) cb(overlap);\n            }\n        }\n    }\n\n    clear(): void {\n        this.overlaps.clear();\n    }\n\n    removeBody(body: T): void {\n        const keysToRemove: string[] = [];\n        for (const [key, overlap] of this.overlaps) {\n            if (overlap.trigger === body || overlap.other === body) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.sort();\n        for (const key of keysToRemove) {\n            const overlap = this.overlaps.get(key)!;\n            this.overlaps.delete(key);\n            for (const cb of this.exitCallbacks) cb(overlap);\n        }\n    }\n\n    getOverlappingBodies(trigger: T): T[] {\n        const bodies: T[] = [];\n        for (const overlap of this.overlaps.values()) {\n            if (overlap.trigger === trigger) {\n                bodies.push(overlap.other);\n            }\n        }\n        return bodies.sort((a, b) => a.label.localeCompare(b.label));\n    }\n\n    isBodyInTrigger(trigger: T, body: T): boolean {\n        return this.overlaps.has(this.makeKey(trigger, body));\n    }\n\n    overlapCount(): number {\n        return this.overlaps.size;\n    }\n\n    saveState(): [string, string][] {\n        const pairs: [string, string][] = [];\n        for (const overlap of this.overlaps.values()) {\n            pairs.push([overlap.trigger.label, overlap.other.label]);\n        }\n        return pairs.sort((a, b) => a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]));\n    }\n\n    private pendingPairs: [string, string][] = [];\n\n    loadState(pairs: [string, string][]): void {\n        this.overlaps.clear();\n        this.pendingPairs = pairs;\n    }\n\n    syncWithWorld(bodies: T[]): void {\n        const bodyByLabel = new Map<string, T>();\n        for (const body of bodies) bodyByLabel.set(body.label, body);\n\n        for (const [triggerLabel, otherLabel] of this.pendingPairs) {\n            const trigger = bodyByLabel.get(triggerLabel);\n            const other = bodyByLabel.get(otherLabel);\n            if (trigger && other) {\n                this.overlaps.set(this.makeKey(trigger, other), { trigger, other });\n            }\n        }\n        this.pendingPairs = [];\n    }\n\n    private makeKey(trigger: T, other: T): string {\n        return `${trigger.label}:${other.label}`;\n    }\n}\n\n// ============================================\n// Helper Function\n// ============================================\n\n/**\n * Mark a body as a trigger (sensor).\n * Works with any body type that has an isSensor property.\n */\nexport function makeTrigger<T extends TriggerBody>(body: T): T {\n    body.isSensor = true;\n    return body;\n}\n", "/**\n * Physics2D System for ECS\n *\n * Integrates the deterministic 2D physics engine with the ECS.\n * This system:\n * - Reads Transform2D + Body2D components\n * - Creates/manages physics bodies internally\n * - Steps the physics simulation\n * - Writes results back to Transform2D component\n * - Handles collision callbacks\n */\n\nimport { World } from '../../core/world';\nimport { Entity } from '../../core/entity';\nimport { ComponentType, hasComponent } from '../../core/component';\nimport { Transform2D, Body2D, BODY_DYNAMIC, BODY_STATIC, BODY_KINEMATIC, SHAPE_CIRCLE, SHAPE_RECT } from '../../components';\nimport { INDEX_MASK } from '../../core/constants';\nimport { toFixed, toFloat } from '../../math';\n\n// Forward declaration for Game to avoid circular import\ninterface GameLike {\n    world: World;\n    physics: Physics2DSystem | null;\n}\n\n// Import physics engine primitives (same folder now)\nimport {\n    World2D,\n    createWorld2D,\n    stepWorld2D,\n    addBody2D,\n    removeBody2D,\n    RigidBody2D,\n    BodyType2D,\n    createBody2D,\n    createCircle,\n    createBox2DFromSize,\n    resetBody2DIdCounter\n} from '.';\n\n/**\n * Collision handler type.\n */\nexport type CollisionHandler = (entityA: Entity, entityB: Entity) => void;\n\n/**\n * Physics2D System configuration.\n */\nexport interface Physics2DSystemConfig {\n    gravity?: { x: number; y: number };\n    dt?: number;  // Timestep (default: 1/60)\n}\n\n/**\n * Physics2D System - manages physics simulation for ECS entities.\n *\n * Can be used as a plugin via game.addPlugin() or standalone via attach().\n *\n * @example\n * // Plugin pattern (recommended)\n * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n *\n * // Standalone pattern (legacy)\n * const physics = createPhysics2DSystem({ gravity: { x: 0, y: 0 } });\n * physics.attach(game.world);\n * game.physics = physics;\n */\nexport class Physics2DSystem {\n    /** Physics world */\n    readonly physicsWorld: World2D;\n\n    /** ECS World reference */\n    private world: World | null = null;\n\n    /** Map entity ID to physics body */\n    private entityToBody: Map<number, RigidBody2D> = new Map();\n\n    /** Map body ID to entity ID */\n    private bodyToEntity: Map<number, number> = new Map();\n\n    /** Collision handlers by type pair */\n    private collisionHandlers: Map<string, CollisionHandler> = new Map();\n\n    /** Entities pending body creation */\n    private pendingEntities: Set<number> = new Set();\n\n    /**\n     * Create a Physics2D system.\n     *\n     * @param gameOrConfig - Game instance (plugin mode) or config (standalone mode)\n     * @param config - Config when using plugin mode\n     */\n    constructor(gameOrConfig?: GameLike | Physics2DSystemConfig, config?: Physics2DSystemConfig) {\n        // Determine if first arg is a Game or config\n        let actualConfig: Physics2DSystemConfig;\n        let game: GameLike | null = null;\n\n        if (gameOrConfig && 'world' in gameOrConfig) {\n            // Plugin mode: first arg is Game\n            game = gameOrConfig;\n            actualConfig = config ?? {};\n        } else {\n            // Standalone mode: first arg is config\n            actualConfig = (gameOrConfig as Physics2DSystemConfig) ?? {};\n        }\n\n        this.physicsWorld = createWorld2D(actualConfig.dt ?? 1 / 60);\n\n        if (actualConfig.gravity) {\n            this.physicsWorld.gravity = {\n                x: toFixed(actualConfig.gravity.x),\n                y: toFixed(actualConfig.gravity.y)\n            };\n        }\n\n        // Set up collision callback via contactListener (for non-sensor collisions)\n        const system = this;\n        this.physicsWorld.contactListener = {\n            onContact(bodyA: RigidBody2D, bodyB: RigidBody2D) {\n                system.handleCollision(bodyA, bodyB);\n            }\n        };\n\n        // Set up physics2d reference for sensor collisions\n        // The physics world uses this for type-based collision handling\n        (this.physicsWorld as any).physics2d = {\n            handleCollision: (entityA: Entity, entityB: Entity) => {\n                return this.handleCollisionByType(entityA, entityB);\n            }\n        };\n\n        // Auto-attach if game was provided\n        if (game) {\n            this.attach(game.world);\n            game.physics = this;\n        }\n    }\n\n    /**\n     * Attach to an ECS World.\n     * Registers prePhysics and physics systems.\n     */\n    attach(world: World): this {\n        this.world = world;\n\n        // Register prePhysics system - sync component data to bodies\n        world.addSystem(() => this.syncBodiesToPhysics(), { phase: 'prePhysics', order: 0 });\n\n        // Register physics system - step simulation\n        world.addSystem(() => this.step(), { phase: 'physics', order: 0 });\n\n        // Register postPhysics system - sync results back to components\n        world.addSystem(() => this.syncPhysicsToComponents(), { phase: 'postPhysics', order: 0 });\n\n        return this;\n    }\n\n    /**\n     * Register collision handler for two entity types.\n     *\n     * For different types (e.g., 'cell', 'food'), the handler is called once\n     * with arguments in the registered order.\n     *\n     * For same types (e.g., 'cell', 'cell'), the handler is called twice -\n     * once as (A, B) and once as (B, A). This lets you write \"first acts on second\"\n     * logic without manually checking both directions.\n     *\n     * @example\n     * // Cell eats food - called once per collision\n     * physics.onCollision('cell', 'food', (cell, food) => {\n     *     food.destroy();\n     * });\n     *\n     * // Cell eats smaller cell - called twice, just check if first > second\n     * physics.onCollision('cell', 'cell', (eater, prey) => {\n     *     if (eater.get(Sprite).radius > prey.get(Sprite).radius * 1.2) {\n     *         prey.destroy();\n     *     }\n     * });\n     */\n    onCollision(typeA: string, typeB: string, handler: CollisionHandler): this {\n        const key1 = `${typeA}:${typeB}`;\n        const key2 = `${typeB}:${typeA}`;\n\n        this.collisionHandlers.set(key1, handler);\n\n        // For different types, register reverse lookup that swaps arguments\n        if (typeA !== typeB) {\n            this.collisionHandlers.set(key2, (a, b) => handler(b, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Set gravity.\n     */\n    setGravity(x: number, y: number): this {\n        this.physicsWorld.gravity = { x: toFixed(x), y: toFixed(y) };\n        return this;\n    }\n\n    /**\n     * Create or get physics body for entity.\n     */\n    private ensureBody(entity: Entity): RigidBody2D | null {\n        const eid = entity.eid;\n\n        // Check if body already exists\n        let body = this.entityToBody.get(eid);\n        if (body) return body;\n\n        // Check if entity has required components\n        if (!entity.has(Transform2D) || !entity.has(Body2D)) {\n            return null;\n        }\n\n        // Get component data\n        const transform = entity.get(Transform2D);\n        const bodyData = entity.get(Body2D);\n\n        // Determine body type\n        let bodyType: BodyType2D;\n        switch (bodyData.bodyType) {\n            case BODY_STATIC:\n                bodyType = BodyType2D.Static;\n                break;\n            case BODY_KINEMATIC:\n                bodyType = BodyType2D.Kinematic;\n                break;\n            default:\n                bodyType = BodyType2D.Dynamic;\n        }\n\n        // Determine shape\n        let shape;\n        if (bodyData.shapeType === SHAPE_CIRCLE || bodyData.radius > 0) {\n            shape = createCircle(bodyData.radius || 10);\n        } else {\n            shape = createBox2DFromSize(bodyData.width || 10, bodyData.height || 10);\n        }\n\n        // Create body\n        body = createBody2D(bodyType, shape, transform.x, transform.y);\n        body.angle = toFixed(transform.angle);\n        body.linearVelocity = { x: toFixed(bodyData.vx), y: toFixed(bodyData.vy) };\n        body.isSensor = bodyData.isSensor;\n\n        // CRITICAL: All new bodies start awake for determinism\n        // Without this, late joiners would have awake bodies while existing clients\n        // have sleeping bodies, causing physics simulation divergence\n        body.isSleeping = false;\n        body.sleepFrames = 0;\n\n        // Store entity reference in body's userData\n        body.userData = entity;\n        body.label = eid.toString();\n\n        // Add to physics world\n        addBody2D(this.physicsWorld, body);\n\n        // Track mapping\n        this.entityToBody.set(eid, body);\n        this.bodyToEntity.set(body.id, eid);\n\n        return body;\n    }\n\n    /**\n     * Remove physics body for entity.\n     */\n    removeBody(entity: Entity): void {\n        const eid = entity.eid;\n        const body = this.entityToBody.get(eid);\n\n        if (body) {\n            removeBody2D(this.physicsWorld, body);\n            this.entityToBody.delete(eid);\n            this.bodyToEntity.delete(body.id);\n        }\n    }\n\n    /**\n     * Sync component data to physics bodies (prePhysics).\n     */\n    private syncBodiesToPhysics(): void {\n        if (!this.world) return;\n\n        // Iterate all entities with Body2D\n        for (const entity of this.world.query(Body2D)) {\n            // Ensure body exists\n            const body = this.ensureBody(entity);\n            if (!body) continue;\n\n            // Sync position from component for kinematic and static bodies\n            // (both can be moved by game code, only dynamic bodies are physics-driven)\n            const bodyData = entity.get(Body2D);\n            if (bodyData.bodyType === BODY_KINEMATIC || bodyData.bodyType === BODY_STATIC) {\n                const transform = entity.get(Transform2D);\n                body.position.x = toFixed(transform.x);\n                body.position.y = toFixed(transform.y);\n                body.angle = toFixed(transform.angle);\n            }\n\n            // Apply impulses (instant velocity change)\n            if (bodyData.impulseX !== 0 || bodyData.impulseY !== 0) {\n                bodyData.vx += bodyData.impulseX;\n                bodyData.vy += bodyData.impulseY;\n                bodyData.impulseX = 0;\n                bodyData.impulseY = 0;\n            }\n\n            // Apply forces (add to velocity)\n            if (bodyData.forceX !== 0 || bodyData.forceY !== 0) {\n                bodyData.vx += bodyData.forceX;\n                bodyData.vy += bodyData.forceY;\n                bodyData.forceX = 0;\n                bodyData.forceY = 0;\n            }\n\n            // Apply damping\n            if (bodyData.damping > 0) {\n                const damp = 1 - bodyData.damping;\n                bodyData.vx *= damp;\n                bodyData.vy *= damp;\n            }\n\n            // Sync velocity for all body types\n            const newVelX = toFixed(bodyData.vx);\n            const newVelY = toFixed(bodyData.vy);\n            body.linearVelocity.x = newVelX;\n            body.linearVelocity.y = newVelY;\n\n            // Wake up body if velocity is non-zero (prevents sleeping bodies from ignoring velocity)\n            if (newVelX !== 0 || newVelY !== 0) {\n                body.isSleeping = false;\n                body.sleepFrames = 0;\n            }\n\n            // Update shape radius if changed\n            if (body.shape.type === 0) { // Circle\n                const currentRadius = (body.shape as any).radius;\n                const newRadius = toFixed(bodyData.radius);\n                if (currentRadius !== newRadius) {\n                    (body.shape as any).radius = newRadius;\n                }\n            }\n        }\n\n        // Clean up bodies for destroyed entities\n        for (const [eid, body] of this.entityToBody) {\n            if (this.world.isDestroyed(eid)) {\n                removeBody2D(this.physicsWorld, body);\n                this.entityToBody.delete(eid);\n                this.bodyToEntity.delete(body.id);\n            }\n        }\n    }\n\n    /**\n     * Step physics simulation.\n     */\n    private step(): void {\n        stepWorld2D(this.physicsWorld);\n    }\n\n    /**\n     * Sync physics results back to components (postPhysics).\n     */\n    private syncPhysicsToComponents(): void {\n        for (const [eid, body] of this.entityToBody) {\n            const entity = this.world?.getEntity(eid);\n            if (!entity || entity.destroyed) continue;\n\n            const transform = entity.get(Transform2D);\n            const bodyData = entity.get(Body2D);\n\n            // Sync position and angle from physics\n            transform.x = toFloat(body.position.x);\n            transform.y = toFloat(body.position.y);\n            transform.angle = toFloat(body.angle);\n\n            // Sync velocity\n            bodyData.vx = toFloat(body.linearVelocity.x);\n            bodyData.vy = toFloat(body.linearVelocity.y);\n        }\n    }\n\n    /**\n     * Handle collision between two bodies.\n     */\n    private handleCollision(bodyA: RigidBody2D, bodyB: RigidBody2D): void {\n        const entityA = bodyA.userData as Entity;\n        const entityB = bodyB.userData as Entity;\n\n        if (!entityA || !entityB) return;\n        if (entityA.destroyed || entityB.destroyed) return;\n\n        this.handleCollisionByType(entityA, entityB);\n    }\n\n    /**\n     * Handle collision by entity types. Returns true if a handler was found.\n     * Used by physics world for both regular and sensor collisions.\n     */\n    private handleCollisionByType(entityA: Entity, entityB: Entity): boolean {\n        if (!entityA || !entityB) return false;\n        if (entityA.destroyed || entityB.destroyed) return false;\n\n        // Look up handler by type pair\n        const key = `${entityA.type}:${entityB.type}`;\n        const handler = this.collisionHandlers.get(key);\n\n        if (handler) {\n            handler(entityA, entityB);\n\n            // For same-type collisions, call handler in reverse direction too\n            // This lets handlers assume \"first arg acts on second\" without manual checks\n            if (entityA.type === entityB.type && !entityA.destroyed && !entityB.destroyed) {\n                handler(entityB, entityA);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get body for entity (for advanced use).\n     */\n    getBody(entity: Entity): RigidBody2D | undefined {\n        return this.entityToBody.get(entity.eid);\n    }\n\n    /**\n     * Get entity for body (for advanced use).\n     */\n    getEntityForBody(body: RigidBody2D): Entity | null {\n        const eid = this.bodyToEntity.get(body.id);\n        if (eid === undefined) return null;\n        return this.world?.getEntity(eid) ?? null;\n    }\n\n    /**\n     * Clear all physics state.\n     * Used during snapshot restoration to ensure fresh physics state.\n     */\n    clear(): void {\n        for (const body of this.entityToBody.values()) {\n            removeBody2D(this.physicsWorld, body);\n        }\n        this.entityToBody.clear();\n        this.bodyToEntity.clear();\n\n        // CRITICAL: Reset body ID counter to ensure deterministic body IDs\n        // Without this, recreated bodies would have different IDs than the original,\n        // potentially causing collision order differences and simulation divergence\n        resetBody2DIdCounter();\n    }\n\n    /**\n     * Wake all physics bodies.\n     * Used after snapshot load/send to ensure deterministic state.\n     * Without this, existing clients have sleeping bodies while late joiners\n     * have awake bodies, causing physics divergence.\n     */\n    wakeAllBodies(): void {\n        for (const body of this.physicsWorld.bodies) {\n            body.isSleeping = false;\n            body.sleepFrames = 0;\n        }\n    }\n}\n\n/**\n * Create a Physics2D system.\n */\nexport function createPhysics2DSystem(config: Physics2DSystemConfig = {}): Physics2DSystem {\n    return new Physics2DSystem(config);\n}\n", "/**\n * Physics Module\n *\n * Deterministic 3D physics engine with fixed-point math.\n * All components use 16.16 fixed-point integers for 100% determinism.\n */\n\n// Shapes and AABB\nexport { ShapeType, BoxShape, SphereShape, Shape, createBox, createSphere, AABB, aabbOverlap } from './shapes';\n\n// Collision Layers\nexport { CollisionFilter, Layers, DEFAULT_FILTER, createFilter, shouldCollide, filterCollidingWith, filterExcluding } from './layers';\n\n// Rigid Body\nexport { BodyType, RigidBody, resetBodyIdCounter, getBodyIdCounter, setBodyIdCounter, createBody, setBodyMass, setBodyVelocity, applyImpulse, applyForce } from './rigid-body';\n\n// Collision Detection and Response\nexport { ContactPoint, Contact, computeAABB, detectCollision, resolveCollision } from './collision';\n\n// Physics World\nexport { World, createWorld, addBody, removeBody, isGrounded, stepWorld } from './world';\n\n// Raycasting\nexport { RayHit, raycast } from './raycast';\n\n// State Serialization\nexport { BodyState, WorldState, saveWorldState, loadWorldState } from './state';\n\n// Triggers/Sensors\nexport { TriggerEvent, TriggerState, makeTrigger } from './trigger';\n", "/**\n * Collision Shapes\n *\n * Defines shape types for rigid body collision detection.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, toFixed } from '../../math/fixed';\nimport { Vec3, vec3FromFloats } from '../../math/vec';\n\n// ============================================\n// Shape Types\n// ============================================\n\nexport enum ShapeType {\n    Box = 0,\n    Sphere = 1,\n}\n\nexport interface BoxShape {\n    type: ShapeType.Box;\n    halfExtents: Vec3;  // Half-size in each dimension\n}\n\nexport interface SphereShape {\n    type: ShapeType.Sphere;\n    radius: Fixed;\n}\n\nexport type Shape = BoxShape | SphereShape;\n\nexport function createBox(hx: number, hy: number, hz: number): BoxShape {\n    return { type: ShapeType.Box, halfExtents: vec3FromFloats(hx, hy, hz) };\n}\n\nexport function createSphere(radius: number): SphereShape {\n    return { type: ShapeType.Sphere, radius: toFixed(radius) };\n}\n\n// ============================================\n// AABB (Axis-Aligned Bounding Box)\n// ============================================\n\nexport interface AABB {\n    min: Vec3;\n    max: Vec3;\n}\n\nexport function aabbOverlap(a: AABB, b: AABB): boolean {\n    return a.max.x >= b.min.x && a.min.x <= b.max.x &&\n        a.max.y >= b.min.y && a.min.y <= b.max.y &&\n        a.max.z >= b.min.z && a.min.z <= b.max.z;\n}\n", "/**\n * Collision Layers\n *\n * Controls which bodies can collide with each other using bitmasks.\n * Layer = \"what am I\", Mask = \"what do I collide with\"\n *\n * Shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Collision Filter\n// ============================================\n\nexport interface CollisionFilter {\n    /** Which layer this body belongs to (single bit) */\n    layer: number;\n    /** Which layers this body collides with (bitmask) */\n    mask: number;\n}\n\n// ============================================\n// Default Layers\n// ============================================\n\nexport const Layers = {\n    NONE: 0,\n    DEFAULT: 1 << 0,      // 1\n    PLAYER: 1 << 1,       // 2\n    ENEMY: 1 << 2,        // 4\n    PROJECTILE: 1 << 3,   // 8\n    ITEM: 1 << 4,         // 16\n    TRIGGER: 1 << 5,      // 32\n    WORLD: 1 << 6,        // 64\n    PROP: 1 << 7,         // 128\n    // Layers 8-15 reserved for game-specific use\n    CUSTOM_1: 1 << 8,\n    CUSTOM_2: 1 << 9,\n    CUSTOM_3: 1 << 10,\n    CUSTOM_4: 1 << 11,\n    CUSTOM_5: 1 << 12,\n    CUSTOM_6: 1 << 13,\n    CUSTOM_7: 1 << 14,\n    CUSTOM_8: 1 << 15,\n    ALL: 0xFFFF           // All layers\n} as const;\n\n// ============================================\n// Default Filter\n// ============================================\n\n/**\n * Default collision filter - collides with everything\n */\nexport const DEFAULT_FILTER: CollisionFilter = {\n    layer: Layers.DEFAULT,\n    mask: Layers.ALL\n};\n\n// ============================================\n// Filter Helpers\n// ============================================\n\n/**\n * Create a collision filter\n */\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\n    return { layer, mask };\n}\n\n/**\n * Check if two filters allow collision\n * Both must have the other in their mask\n */\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\n}\n\n/**\n * Create a filter that collides with specific layers\n */\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\n    let mask = 0;\n    for (const l of collidesWithLayers) {\n        mask |= l;\n    }\n    return { layer, mask };\n}\n\n/**\n * Create a filter that collides with everything except specific layers\n */\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\n    let mask = Layers.ALL;\n    for (const l of excludeLayers) {\n        mask &= ~l;\n    }\n    return { layer, mask };\n}\n", "/**\n * Rigid Body\n *\n * Defines rigid body types and operations for physics simulation.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv } from '../../math/fixed';\nimport { Vec3, vec3Zero, vec3FromFloats, vec3Add, vec3Scale, vec3Sub, vec3Cross } from '../../math/vec';\nimport { Quat, quatIdentity } from '../../math/quat';\nimport { Shape, ShapeType, SphereShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);  // No bounce for stable resting\nconst FRICTION_DEFAULT = toFixed(0.5);      // Moderate friction\n\n// ============================================\n// Body Types\n// ============================================\n\nexport enum BodyType {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody {\n    id: number;\n    type: BodyType;\n    shape: Shape;\n\n    // Label for deterministic ordering - MUST be unique and consistent across all clients\n    // Examples: \"ground\", \"box_0\", \"box_1\", \"player_abc123\"\n    label: string;\n\n    // Transform\n    position: Vec3;\n    rotation: Quat;\n\n    // Velocity\n    linearVelocity: Vec3;\n    angularVelocity: Vec3;\n\n    // Mass properties\n    mass: Fixed;           // 0 for static/kinematic\n    invMass: Fixed;        // 1/mass, 0 for static/kinematic\n    inertia: Fixed;        // Moment of inertia (simplified scalar)\n    invInertia: Fixed;     // 1/inertia\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotationX: boolean;\n    lockRotationY: boolean;\n    lockRotationZ: boolean;\n    isTrigger: boolean;  // If true, detects overlap but doesn't apply physics response\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId = 1;\n\nexport function resetBodyIdCounter(): void {\n    nextBodyId = 1;\n}\n\nexport function getBodyIdCounter(): number {\n    return nextBodyId;\n}\n\nexport function setBodyIdCounter(value: number): void {\n    nextBodyId = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody(type: BodyType, shape: Shape, x: number, y: number, z: number, label?: string): RigidBody {\n    const mass = type === BodyType.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType.Dynamic ? FP_ONE : 0;\n\n    // Simplified inertia calculation\n    let inertia = 0;\n    if (type === BodyType.Dynamic) {\n        if (shape.type === ShapeType.Box) {\n            // I = (1/12) * m * (h\u00B2 + d\u00B2) for each axis - use average\n            const h = shape.halfExtents;\n            inertia = fpMul(mass, fpMul(toFixed(1 / 6),\n                fpMul(h.x, h.x) + fpMul(h.y, h.y) + fpMul(h.z, h.z)));\n        } else {\n            // I = (2/5) * m * r\u00B2 for solid sphere\n            const r = (shape as SphereShape).radius;\n            inertia = fpMul(mass, fpMul(toFixed(0.4), fpMul(r, r)));\n        }\n    }\n\n    const bodyLabel = label || 'body_' + nextBodyId;\n    const bodyId = nextBodyId++;\n\n    return {\n        id: bodyId,\n        label: bodyLabel,\n        type,\n        shape,\n        position: vec3FromFloats(x, y, z),\n        rotation: quatIdentity(),\n        linearVelocity: vec3Zero(),\n        angularVelocity: vec3Zero(),\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotationX: false,\n        lockRotationY: false,\n        lockRotationZ: false,\n        isTrigger: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBodyMass(body: RigidBody, mass: number): void {\n    if (body.type !== BodyType.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBodyVelocity(body: RigidBody, vx: number, vy: number, vz: number): void {\n    body.linearVelocity = vec3FromFloats(vx, vy, vz);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse(body: RigidBody, impulse: Vec3, point?: Vec3): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(impulse, body.invMass));\n\n    if (point) {\n        const r = vec3Sub(point, body.position);\n        const torque = vec3Cross(r, impulse);\n        body.angularVelocity = vec3Add(body.angularVelocity, vec3Scale(torque, body.invInertia));\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce(body: RigidBody, force: Vec3, dt: Fixed): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n    const impulse = vec3Scale(force, dt);\n    applyImpulse(body, impulse);\n}\n", "/**\n * Collision Detection and Response\n *\n * Handles narrow-phase collision detection between shapes and\n * impulse-based collision response.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpMin, fpSqrt, fpClamp } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Sub, vec3Add, vec3Scale, vec3Neg, vec3Dot, vec3Cross, vec3LengthSq, vec3Normalize } from '../../math/vec';\nimport { quatRotateVec3, quatConjugate } from '../../math/quat';\nimport { ShapeType, SphereShape, BoxShape, AABB } from './shapes';\nimport { RigidBody, BodyType, applyImpulse } from './rigid-body';\n\n// ============================================\n// Constants\n// ============================================\n\nconst POSITION_CORRECTION = toFixed(0.6);  // Slightly less aggressive correction\nconst SLOP = toFixed(0.05);                 // Penetration allowance to reduce jitter\nconst WAKE_VELOCITY_THRESHOLD = toFixed(1.5);  // Threshold for waking sleeping bodies\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB(body: RigidBody): AABB {\n    const pos = body.position;\n    const shape = body.shape;\n\n    if (shape.type === ShapeType.Sphere) {\n        const r = shape.radius;\n        return {\n            min: { x: pos.x - r, y: pos.y - r, z: pos.z - r },\n            max: { x: pos.x + r, y: pos.y + r, z: pos.z + r }\n        };\n    } else {\n        // For rotated boxes, compute world-space AABB by projecting onto each world axis\n        const h = shape.halfExtents;\n\n        // Get the box axes in world space\n        const axisX = quatRotateVec3(body.rotation, vec3(FP_ONE, 0, 0));\n        const axisY = quatRotateVec3(body.rotation, vec3(0, FP_ONE, 0));\n        const axisZ = quatRotateVec3(body.rotation, vec3(0, 0, FP_ONE));\n\n        // Compute the extent along each world axis\n        const extentX = fpAbs(fpMul(axisX.x, h.x)) + fpAbs(fpMul(axisY.x, h.y)) + fpAbs(fpMul(axisZ.x, h.z));\n        const extentY = fpAbs(fpMul(axisX.y, h.x)) + fpAbs(fpMul(axisY.y, h.y)) + fpAbs(fpMul(axisZ.y, h.z));\n        const extentZ = fpAbs(fpMul(axisX.z, h.x)) + fpAbs(fpMul(axisY.z, h.y)) + fpAbs(fpMul(axisZ.z, h.z));\n\n        return {\n            min: { x: pos.x - extentX, y: pos.y - extentY, z: pos.z - extentZ },\n            max: { x: pos.x + extentX, y: pos.y + extentY, z: pos.z + extentZ }\n        };\n    }\n}\n\n// ============================================\n// Contact Types\n// ============================================\n\nexport interface ContactPoint {\n    point: Vec3;\n    penetration: Fixed;\n}\n\nexport interface Contact {\n    bodyA: RigidBody;\n    bodyB: RigidBody;\n    normal: Vec3;          // Points from B toward A (standard convention)\n    points: ContactPoint[]; // Multiple contact points (contact manifold)\n}\n\n// ============================================\n// Collision Detection Functions\n// ============================================\n\nfunction sphereSphereCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as SphereShape;\n    const shapeB = b.shape as SphereShape;\n\n    const diff = vec3Sub(a.position, b.position);  // Points from B to A\n    const distSq = vec3LengthSq(diff);\n    const minDist = shapeA.radius + shapeB.radius;\n    const minDistSq = fpMul(minDist, minDist);\n\n    if (distSq >= minDistSq) return null;\n\n    const dist = fpSqrt(distSq);\n    const normal = dist > 0 ? vec3Scale(diff, fpDiv(FP_ONE, dist)) : vec3(FP_ONE, 0, 0);\n    const penetration = minDist - dist;\n    const point = vec3Sub(a.position, vec3Scale(normal, shapeA.radius));\n\n    return { bodyA: a, bodyB: b, normal, points: [{ point, penetration }] };\n}\n\nfunction sphereBoxCollision(sphere: RigidBody, box: RigidBody): Contact | null {\n    const sphereShape = sphere.shape as SphereShape;\n    const boxShape = box.shape as BoxShape;\n\n    // Transform sphere center into box's local space (accounting for rotation)\n    const worldDiff = vec3Sub(sphere.position, box.position);\n    const invRotation = quatConjugate(box.rotation);\n    const localSphere = quatRotateVec3(invRotation, worldDiff);\n    const h = boxShape.halfExtents;\n\n    // Find closest point on box to sphere center (in local space)\n    const closestLocal: Vec3 = {\n        x: fpClamp(localSphere.x, -h.x, h.x),\n        y: fpClamp(localSphere.y, -h.y, h.y),\n        z: fpClamp(localSphere.z, -h.z, h.z)\n    };\n\n    const diffLocal = vec3Sub(localSphere, closestLocal);\n    const distSq = vec3LengthSq(diffLocal);\n    const radiusSq = fpMul(sphereShape.radius, sphereShape.radius);\n\n    if (distSq >= radiusSq) return null;\n\n    const dist = fpSqrt(distSq);\n\n    let normalLocal: Vec3;\n    let penetration: Fixed;\n\n    if (dist > 0) {\n        normalLocal = vec3Scale(diffLocal, fpDiv(FP_ONE, dist));\n        penetration = sphereShape.radius - dist;\n    } else {\n        // Sphere center inside box - find shortest axis to push out\n        const dx = h.x - fpAbs(localSphere.x);\n        const dy = h.y - fpAbs(localSphere.y);\n        const dz = h.z - fpAbs(localSphere.z);\n\n        if (dx <= dy && dx <= dz) {\n            normalLocal = localSphere.x >= 0 ? vec3(FP_ONE, 0, 0) : vec3(-FP_ONE, 0, 0);\n            penetration = dx + sphereShape.radius;\n        } else if (dy <= dz) {\n            normalLocal = localSphere.y >= 0 ? vec3(0, FP_ONE, 0) : vec3(0, -FP_ONE, 0);\n            penetration = dy + sphereShape.radius;\n        } else {\n            normalLocal = localSphere.z >= 0 ? vec3(0, 0, FP_ONE) : vec3(0, 0, -FP_ONE);\n            penetration = dz + sphereShape.radius;\n        }\n    }\n\n    // Transform contact point and normal back to world space\n    const worldClosest = vec3Add(box.position, quatRotateVec3(box.rotation, closestLocal));\n    const worldNormal = quatRotateVec3(box.rotation, normalLocal);\n\n    return { bodyA: sphere, bodyB: box, normal: worldNormal, points: [{ point: worldClosest, penetration }] };\n}\n\nfunction boxBoxCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as BoxShape;\n    const shapeB = b.shape as BoxShape;\n    const hA = shapeA.halfExtents;\n    const hB = shapeB.halfExtents;\n\n    // Get rotated axes for both boxes\n    const axesA = [\n        quatRotateVec3(a.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(a.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(a.rotation, vec3(0, 0, FP_ONE))\n    ];\n    const axesB = [\n        quatRotateVec3(b.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(b.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(b.rotation, vec3(0, 0, FP_ONE))\n    ];\n\n    const extentsA = [hA.x, hA.y, hA.z];\n    const extentsB = [hB.x, hB.y, hB.z];\n    const d = vec3Sub(b.position, a.position);\n\n    let minPen = 0x7FFFFFFF as Fixed;\n    let bestNormal = vec3(0, FP_ONE, 0);\n\n    // Project extent onto axis\n    function project(axes: Vec3[], extents: Fixed[], axis: Vec3): Fixed {\n        return fpAbs(fpMul(vec3Dot(axes[0], axis), extents[0])) +\n               fpAbs(fpMul(vec3Dot(axes[1], axis), extents[1])) +\n               fpAbs(fpMul(vec3Dot(axes[2], axis), extents[2]));\n    }\n\n    // Test separation on axis, returns false if separated\n    function testAxis(axis: Vec3): boolean {\n        const lenSq = vec3LengthSq(axis);\n        if (lenSq < toFixed(0.0001)) return true; // Skip degenerate\n\n        const len = fpSqrt(lenSq);\n        const n = vec3Scale(axis, fpDiv(FP_ONE, len));\n\n        const pA = project(axesA, extentsA, n);\n        const pB = project(axesB, extentsB, n);\n        const dist = fpAbs(vec3Dot(d, n));\n        const pen = (pA + pB) - dist;\n\n        if (pen <= 0) return false;\n        if (pen < minPen) {\n            minPen = pen;\n            bestNormal = vec3Dot(d, n) < 0 ? n : vec3Neg(n);\n        }\n        return true;\n    }\n\n    // Test 15 SAT axes\n    for (let i = 0; i < 3; i++) {\n        if (!testAxis(axesA[i])) return null;\n        if (!testAxis(axesB[i])) return null;\n    }\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (!testAxis(vec3Cross(axesA[i], axesB[j]))) return null;\n        }\n    }\n\n    // Generate proper contact manifold based on the type of contact\n    const contactPoints: ContactPoint[] = [];\n\n    // Determine which body's face is the reference (the one whose normal we're using)\n    const volumeA = fpMul(fpMul(hA.x, hA.y), hA.z);\n    const volumeB = fpMul(fpMul(hB.x, hB.y), hB.z);\n\n    // Find all vertices of the incident body (smaller one) that are below the reference face\n    const incidentBody = volumeB <= volumeA ? b : a;\n    const incidentHalf = volumeB <= volumeA ? hB : hA;\n    const referenceBody = volumeB <= volumeA ? a : b;\n\n    // For each vertex of the incident body, project onto reference face and check penetration\n    const signs: [number, number, number][] = [\n        [-1, -1, -1], [-1, -1, 1], [-1, 1, -1], [-1, 1, 1],\n        [1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]\n    ];\n\n    // Calculate reference face plane normal\n    const refFaceNormal = volumeB <= volumeA ? bestNormal : vec3Neg(bestNormal);\n\n    interface VertexContact {\n        point: Vec3;\n        depth: Fixed;\n    }\n    const vertexContacts: VertexContact[] = [];\n\n    const refAxes = volumeB <= volumeA ? axesA : axesB;\n    const refHalf = volumeB <= volumeA ? hA : hB;\n\n    for (const [sx, sy, sz] of signs) {\n        const localV = vec3(\n            fpMul(incidentHalf.x, toFixed(sx)),\n            fpMul(incidentHalf.y, toFixed(sy)),\n            fpMul(incidentHalf.z, toFixed(sz))\n        );\n        const worldV = vec3Add(incidentBody.position, quatRotateVec3(incidentBody.rotation, localV));\n\n        // Calculate how deep this vertex is along the collision normal direction\n        const toVertex = vec3Sub(worldV, referenceBody.position);\n        const normalDist = vec3Dot(toVertex, refFaceNormal);\n\n        // Get the reference body's extent along the normal\n        const refExtent = fpMul(fpAbs(vec3Dot(refAxes[0], refFaceNormal)), refHalf.x) +\n                          fpMul(fpAbs(vec3Dot(refAxes[1], refFaceNormal)), refHalf.y) +\n                          fpMul(fpAbs(vec3Dot(refAxes[2], refFaceNormal)), refHalf.z);\n\n        const depth = normalDist + refExtent;\n\n        if (depth > 0) {\n            vertexContacts.push({ point: worldV, depth });\n        }\n    }\n\n    // Sort by depth and take the deepest vertices (up to 4 for face contact)\n    // Use position as tiebreaker for deterministic stable sort\n    vertexContacts.sort((a, b) => {\n        const depthDiff = b.depth - a.depth;\n        if (depthDiff !== 0) return depthDiff;\n        // Tiebreaker using point position for determinism\n        return (a.point.x - b.point.x) || (a.point.y - b.point.y) || (a.point.z - b.point.z);\n    });\n\n    // Use vertices with similar depth (within threshold of deepest)\n    const DEPTH_THRESHOLD = toFixed(0.05);\n    const maxDepth = vertexContacts.length > 0 ? vertexContacts[0].depth : 0 as Fixed;\n\n    for (const vc of vertexContacts) {\n        if (vc.depth > maxDepth - DEPTH_THRESHOLD) {\n            contactPoints.push({ point: vc.point, penetration: vc.depth });\n        }\n        if (contactPoints.length >= 4) break; // Max 4 contact points\n    }\n\n    // Fallback: use the SAT penetration point\n    if (contactPoints.length === 0) {\n        const midPoint = vec3Scale(vec3Add(a.position, b.position), FP_HALF);\n        contactPoints.push({ point: midPoint, penetration: minPen });\n    }\n\n    return { bodyA: a, bodyB: b, normal: bestNormal, points: contactPoints };\n}\n\nexport function detectCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const typeA = a.shape.type;\n    const typeB = b.shape.type;\n\n    if (typeA === ShapeType.Sphere && typeB === ShapeType.Sphere) {\n        return sphereSphereCollision(a, b);\n    } else if (typeA === ShapeType.Sphere && typeB === ShapeType.Box) {\n        return sphereBoxCollision(a, b);\n    } else if (typeA === ShapeType.Box && typeB === ShapeType.Sphere) {\n        const contact = sphereBoxCollision(b, a);\n        if (contact) {\n            // Swap bodies and flip normal\n            return {\n                bodyA: a,\n                bodyB: b,\n                normal: vec3Neg(contact.normal),\n                points: contact.points\n            };\n        }\n        return null;\n    } else {\n        return boxBoxCollision(a, b);\n    }\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\nexport function resolveCollision(contact: Contact): void {\n    const { bodyA, bodyB, normal, points } = contact;\n\n    // Skip if both are static/kinematic or no contact points\n    if (bodyA.invMass === 0 && bodyB.invMass === 0) return;\n    if (points.length === 0) return;\n\n    // Calculate relative velocity along collision normal to determine wake conditions\n    const relVelForWake = vec3Sub(bodyA.linearVelocity, bodyB.linearVelocity);\n    const impactVelocity = fpAbs(vec3Dot(relVelForWake, normal));\n\n    // Check if this is a resting contact (bodies gently settling, not impacting)\n    const isRestingContact = impactVelocity < WAKE_VELOCITY_THRESHOLD;\n\n    // If one body is sleeping and this is a resting contact, keep it sleeping\n    // Apply position correction only without waking\n    if (isRestingContact && (bodyA.isSleeping || bodyB.isSleeping)) {\n        for (const cp of points) {\n            const penetration = cp.penetration;\n            if (penetration > SLOP) {\n                const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n                if (pureInvMassSum > 0) {\n                    const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n                    const correctionVec = vec3Scale(normal, correction);\n\n                    // Only move non-sleeping bodies\n                    if (bodyA.invMass > 0 && !bodyA.isSleeping) {\n                        bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n                    }\n                    if (bodyB.invMass > 0 && !bodyB.isSleeping) {\n                        bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    const numContacts = points.length;\n    const invNumContacts = fpDiv(FP_ONE, toFixed(numContacts));\n\n    // Restitution (use minimum)\n    const e = fpMin(bodyA.restitution, bodyB.restitution);\n    const frictionCoeff = fpDiv(bodyA.friction + bodyB.friction, toFixed(2));\n\n    // Process each contact point\n    for (const cp of points) {\n        const point = cp.point;\n        const penetration = cp.penetration;\n\n        // Calculate radius vectors from center of mass to contact point\n        const rA = vec3Sub(point, bodyA.position);\n        const rB = vec3Sub(point, bodyB.position);\n\n        // Calculate velocity at contact point (including rotation)\n        const velA = vec3Add(bodyA.linearVelocity, vec3Cross(bodyA.angularVelocity, rA));\n        const velB = vec3Add(bodyB.linearVelocity, vec3Cross(bodyB.angularVelocity, rB));\n        const relVel = vec3Sub(velA, velB);\n\n        const velAlongNormal = vec3Dot(relVel, normal);\n\n        // Only resolve if approaching\n        if (velAlongNormal < 0) {\n            // Calculate impulse magnitude\n            const rACrossN = vec3Cross(rA, normal);\n            const rBCrossN = vec3Cross(rB, normal);\n\n            const angularInertiaA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rACrossN, rACrossN), bodyA.invInertia);\n            const angularInertiaB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rBCrossN, rBCrossN), bodyB.invInertia);\n\n            const invMassSum = bodyA.invMass + bodyB.invMass + angularInertiaA + angularInertiaB;\n            let j = fpMul(-(FP_ONE + e), velAlongNormal);\n            j = fpDiv(j, invMassSum);\n            j = fpMul(j, invNumContacts);  // Distribute across contacts\n\n            const impulse = vec3Scale(normal, j);\n\n            if (bodyA.invMass > 0) {\n                applyImpulse(bodyA, impulse, point);\n            }\n            if (bodyB.invMass > 0) {\n                applyImpulse(bodyB, vec3Neg(impulse), point);\n            }\n\n            // Friction\n            const tangent = vec3Sub(relVel, vec3Scale(normal, velAlongNormal));\n            const tangentLenSq = vec3LengthSq(tangent);\n\n            if (tangentLenSq > toFixed(0.0001)) {\n                const tangentNorm = vec3Normalize(tangent);\n                const rACrossT = vec3Cross(rA, tangentNorm);\n                const rBCrossT = vec3Cross(rB, tangentNorm);\n\n                const angularInertiaTA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rACrossT, rACrossT), bodyA.invInertia);\n                const angularInertiaTB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rBCrossT, rBCrossT), bodyB.invInertia);\n\n                const invMassSumT = bodyA.invMass + bodyB.invMass + angularInertiaTA + angularInertiaTB;\n                const tangentSpeed = fpSqrt(tangentLenSq);\n                let jt = fpDiv(tangentSpeed, invMassSumT);\n                jt = fpMul(jt, invNumContacts);  // Distribute\n\n                const maxFriction = fpMul(fpAbs(j), frictionCoeff);\n                if (jt > maxFriction) jt = maxFriction;\n\n                const frictionImpulse = vec3Scale(tangentNorm, -jt);\n\n                if (bodyA.invMass > 0) {\n                    applyImpulse(bodyA, frictionImpulse, point);\n                }\n                if (bodyB.invMass > 0) {\n                    applyImpulse(bodyB, vec3Neg(frictionImpulse), point);\n                }\n            }\n        }\n\n        // Position correction for this contact\n        if (penetration > SLOP) {\n            const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n            const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n            const scaledCorrection = fpMul(correction, invNumContacts);  // Distribute\n            const correctionVec = vec3Scale(normal, scaledCorrection);\n\n            if (bodyA.invMass > 0) {\n                bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n            }\n            if (bodyB.invMass > 0) {\n                bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n            }\n        }\n    }\n}\n", "/**\n * Trigger System\n *\n * Handles trigger (sensor) bodies that detect overlap without physics response.\n * Generic implementation shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Body Interface (minimal contract)\n// ============================================\n\n/**\n * Minimal interface for a physics body used by triggers.\n * Both RigidBody (3D) and RigidBody2D implement this.\n */\nexport interface TriggerBody {\n    label: string;\n    isTrigger: boolean;\n}\n\n// ============================================\n// Trigger Event\n// ============================================\n\nexport interface TriggerEvent<T extends TriggerBody = TriggerBody> {\n    trigger: T;\n    other: T;\n}\n\ntype TriggerCallback<T extends TriggerBody> = (event: TriggerEvent<T>) => void;\n\n// ============================================\n// Trigger State\n// ============================================\n\nexport class TriggerState<T extends TriggerBody = TriggerBody> {\n    private overlaps = new Map<string, { trigger: T; other: T }>();\n    private enterCallbacks: TriggerCallback<T>[] = [];\n    private stayCallbacks: TriggerCallback<T>[] = [];\n    private exitCallbacks: TriggerCallback<T>[] = [];\n\n    onEnter(cb: TriggerCallback<T>): void { this.enterCallbacks.push(cb); }\n    onStay(cb: TriggerCallback<T>): void { this.stayCallbacks.push(cb); }\n    onExit(cb: TriggerCallback<T>): void { this.exitCallbacks.push(cb); }\n\n    processOverlaps(currentOverlaps: TriggerEvent<T>[]): void {\n        const currentKeys = new Set<string>();\n        const sortedOverlaps = [...currentOverlaps].sort((a, b) => {\n            return this.makeKey(a.trigger, a.other).localeCompare(this.makeKey(b.trigger, b.other));\n        });\n\n        for (const overlap of sortedOverlaps) {\n            const key = this.makeKey(overlap.trigger, overlap.other);\n            currentKeys.add(key);\n\n            if (this.overlaps.has(key)) {\n                for (const cb of this.stayCallbacks) cb(overlap);\n            } else {\n                this.overlaps.set(key, overlap);\n                for (const cb of this.enterCallbacks) cb(overlap);\n            }\n        }\n\n        const sortedExistingKeys = [...this.overlaps.keys()].sort();\n        for (const key of sortedExistingKeys) {\n            if (!currentKeys.has(key)) {\n                const overlap = this.overlaps.get(key)!;\n                this.overlaps.delete(key);\n                for (const cb of this.exitCallbacks) cb(overlap);\n            }\n        }\n    }\n\n    clear(): void {\n        this.overlaps.clear();\n    }\n\n    removeBody(body: T): void {\n        const keysToRemove: string[] = [];\n        for (const [key, overlap] of this.overlaps) {\n            if (overlap.trigger === body || overlap.other === body) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.sort();\n        for (const key of keysToRemove) {\n            const overlap = this.overlaps.get(key)!;\n            this.overlaps.delete(key);\n            for (const cb of this.exitCallbacks) cb(overlap);\n        }\n    }\n\n    getOverlappingBodies(trigger: T): T[] {\n        const bodies: T[] = [];\n        for (const overlap of this.overlaps.values()) {\n            if (overlap.trigger === trigger) {\n                bodies.push(overlap.other);\n            }\n        }\n        return bodies.sort((a, b) => a.label.localeCompare(b.label));\n    }\n\n    isBodyInTrigger(trigger: T, body: T): boolean {\n        return this.overlaps.has(this.makeKey(trigger, body));\n    }\n\n    overlapCount(): number {\n        return this.overlaps.size;\n    }\n\n    saveState(): [string, string][] {\n        const pairs: [string, string][] = [];\n        for (const overlap of this.overlaps.values()) {\n            pairs.push([overlap.trigger.label, overlap.other.label]);\n        }\n        return pairs.sort((a, b) => a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]));\n    }\n\n    private pendingPairs: [string, string][] = [];\n\n    loadState(pairs: [string, string][]): void {\n        this.overlaps.clear();\n        this.pendingPairs = pairs;\n    }\n\n    syncWithWorld(bodies: T[]): void {\n        const bodyByLabel = new Map<string, T>();\n        for (const body of bodies) bodyByLabel.set(body.label, body);\n\n        for (const [triggerLabel, otherLabel] of this.pendingPairs) {\n            const trigger = bodyByLabel.get(triggerLabel);\n            const other = bodyByLabel.get(otherLabel);\n            if (trigger && other) {\n                this.overlaps.set(this.makeKey(trigger, other), { trigger, other });\n            }\n        }\n        this.pendingPairs = [];\n    }\n\n    private makeKey(trigger: T, other: T): string {\n        return `${trigger.label}:${other.label}`;\n    }\n}\n\n// ============================================\n// Helper Function\n// ============================================\n\n/**\n * Mark a body as a trigger (sensor).\n * Works with any body type that has an isTrigger property.\n */\nexport function makeTrigger<T extends TriggerBody>(body: T): T {\n    body.isTrigger = true;\n    return body;\n}\n", "/**\n * Physics World\n *\n * Manages the physics simulation including gravity, collision detection,\n * and integration of velocities and positions.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Clone, vec3Add, vec3Scale, vec3LengthSq } from '../../math/vec';\nimport { quatFromAxisAngle, quatMul, quatNormalize } from '../../math/quat';\nimport { aabbOverlap } from './shapes';\nimport { RigidBody, BodyType } from './rigid-body';\nimport { Contact, computeAABB, detectCollision, resolveCollision } from './collision';\nimport { shouldCollide } from './layers';\nimport { TriggerState, TriggerEvent } from './trigger';\n\n// ============================================\n// Constants\n// ============================================\n\nconst GRAVITY: Vec3 = { x: 0, y: toFixed(-30), z: 0 };  // -30 units/s\u00B2\nconst LINEAR_DAMPING = toFixed(0.1);      // 10% velocity loss per frame\nconst ANGULAR_DAMPING = toFixed(0.1);     // 10% angular velocity loss per frame\nconst SLEEP_THRESHOLD = toFixed(0.12);    // Sleep when nearly stopped\nconst SLEEP_FRAMES_REQUIRED = 20;         // ~0.33 seconds at 60fps before sleeping\nconst CONTACT_SLEEP_BONUS = 10;           // Extra sleep frames when in stable contact\nconst COLLISION_ITERATIONS = 8;           // Multiple iterations for stability\n\n// ============================================\n// World Interface\n// ============================================\n\nexport interface World {\n    bodies: RigidBody[];\n    gravity: Vec3;\n    dt: Fixed;  // Fixed timestep\n    triggers: TriggerState;  // Trigger/sensor event tracking\n    /** Step the physics simulation */\n    step(): Contact[];\n}\n\nexport function createWorld(dt: number = 1 / 60): World {\n    const world: World = {\n        bodies: [],\n        gravity: vec3Clone(GRAVITY),\n        dt: toFixed(dt),\n        triggers: new TriggerState(),\n        step() {\n            return stepWorld(world);\n        }\n    };\n    return world;\n}\n\nexport function addBody(world: World, body: RigidBody): void {\n    world.bodies.push(body);\n}\n\nexport function removeBody(world: World, body: RigidBody): void {\n    const index = world.bodies.indexOf(body);\n    if (index >= 0) {\n        world.bodies.splice(index, 1);\n        // Clean up trigger overlaps involving this body\n        world.triggers.removeBody(body);\n    }\n}\n\n// ============================================\n// Ground Check\n// ============================================\n\n/**\n * Check if a body is grounded (has a surface below it within threshold)\n * @param world The physics world\n * @param body The body to check\n * @param threshold Distance below to check (default 0.15)\n * @returns true if grounded\n */\nexport function isGrounded(world: World, body: RigidBody, threshold: number = 0.15): boolean {\n    const thresholdFP = toFixed(threshold);\n\n    for (const other of world.bodies) {\n        if (other === body) continue;\n\n        // Check if there's collision contact with normal pointing up\n        const contact = detectCollision(body, other);\n        if (contact && contact.normal.y > FP_HALF) {\n            // Normal pointing up means surface is below\n            return true;\n        }\n\n        // Also check slightly below current position\n        const savedY = body.position.y;\n        body.position.y = body.position.y - thresholdFP;\n        const contactBelow = detectCollision(body, other);\n        body.position.y = savedY;\n\n        if (contactBelow && contactBelow.normal.y > FP_HALF) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// ============================================\n// World Step\n// ============================================\n\nexport function stepWorld(world: World): Contact[] {\n    const { gravity, dt, triggers } = world;\n    const contacts: Contact[] = [];\n    const triggerOverlaps: TriggerEvent[] = [];\n\n    // CRITICAL: Sort bodies by label for deterministic collision processing order\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\n\n    // Track which bodies are in stable resting contact (for island sleeping)\n    const restingContactBodies = new Set<RigidBody>();\n    const sleepingContactBodies = new Set<RigidBody>();\n\n    // First pass: identify resting contacts and sleeping contact pairs\n    for (let i = 0; i < bodies.length; i++) {\n        for (let j = i + 1; j < bodies.length; j++) {\n            const a = bodies[i];\n            const b = bodies[j];\n\n            if (a.invMass === 0 && b.invMass === 0) continue;\n            if (!shouldCollide(a.filter, b.filter)) continue;\n\n            const aabbA = computeAABB(a);\n            const aabbB = computeAABB(b);\n            if (!aabbOverlap(aabbA, aabbB)) continue;\n\n            const contact = detectCollision(a, b);\n            if (contact) {\n                if (fpAbs(contact.normal.y) > FP_HALF) {\n                    restingContactBodies.add(a);\n                    restingContactBodies.add(b);\n\n                    if (a.isSleeping && b.type === BodyType.Dynamic) {\n                        const bSpeedSq = vec3LengthSq(b.linearVelocity) + vec3LengthSq(b.angularVelocity);\n                        if (bSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(b);\n                        }\n                    }\n                    if (b.isSleeping && a.type === BodyType.Dynamic) {\n                        const aSpeedSq = vec3LengthSq(a.linearVelocity) + vec3LengthSq(a.angularVelocity);\n                        if (aSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(a);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Integrate velocities (apply gravity)\n    for (const body of bodies) {\n        if (body.type !== BodyType.Dynamic) continue;\n        if (body.isSleeping) continue;\n\n        body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(gravity, dt));\n\n        let linearDamp = FP_ONE - LINEAR_DAMPING;\n        let angularDamp = FP_ONE - ANGULAR_DAMPING;\n\n        if (restingContactBodies.has(body)) {\n            linearDamp = fpMul(linearDamp, toFixed(0.95));\n            angularDamp = fpMul(angularDamp, toFixed(0.9));\n        }\n\n        body.linearVelocity = vec3Scale(body.linearVelocity, linearDamp);\n        body.angularVelocity = vec3Scale(body.angularVelocity, angularDamp);\n    }\n\n    // Multiple collision iterations for stability\n    for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {\n        for (let i = 0; i < bodies.length; i++) {\n            for (let j = i + 1; j < bodies.length; j++) {\n                const a = bodies[i];\n                const b = bodies[j];\n\n                if (a.invMass === 0 && b.invMass === 0) continue;\n                if (!shouldCollide(a.filter, b.filter)) continue;\n\n                const aabbA = computeAABB(a);\n                const aabbB = computeAABB(b);\n                if (!aabbOverlap(aabbA, aabbB)) continue;\n\n                const contact = detectCollision(a, b);\n                if (contact) {\n                    // Check if either body is a trigger\n                    const isTriggerCollision = a.isTrigger || b.isTrigger;\n\n                    if (isTriggerCollision) {\n                        // Record trigger overlap (only on first iteration)\n                        if (iter === 0) {\n                            // Determine which is the trigger\n                            if (a.isTrigger) {\n                                triggerOverlaps.push({ trigger: a, other: b });\n                            }\n                            if (b.isTrigger) {\n                                triggerOverlaps.push({ trigger: b, other: a });\n                            }\n                        }\n                        // Skip physics response for triggers\n                    } else {\n                        // Normal collision - apply physics response\n                        if (iter === 0) contacts.push(contact);\n                        resolveCollision(contact);\n                    }\n                }\n            }\n        }\n    }\n\n    // Process trigger events after collision detection\n    triggers.processOverlaps(triggerOverlaps);\n\n    // Integrate positions\n    for (const body of bodies) {\n        if (body.type === BodyType.Static) continue;\n        if (body.isSleeping) continue;\n\n        // Clamp tiny linear velocities to zero\n        const linearClampThreshold = toFixed(0.05);\n        if (fpAbs(body.linearVelocity.x) < linearClampThreshold) body.linearVelocity.x = 0;\n        if (fpAbs(body.linearVelocity.y) < linearClampThreshold) body.linearVelocity.y = 0;\n        if (fpAbs(body.linearVelocity.z) < linearClampThreshold) body.linearVelocity.z = 0;\n\n        body.position = vec3Add(body.position, vec3Scale(body.linearVelocity, dt));\n\n        // Skip rotation integration if all rotations are locked\n        if (body.lockRotationX && body.lockRotationY && body.lockRotationZ) {\n            continue;\n        }\n\n        // Apply rotation locks\n        let angVelX = body.lockRotationX ? 0 : body.angularVelocity.x;\n        let angVelY = body.lockRotationY ? 0 : body.angularVelocity.y;\n        let angVelZ = body.lockRotationZ ? 0 : body.angularVelocity.z;\n\n        // Clamp tiny angular velocities to zero\n        const angularClampThreshold = toFixed(0.01);\n        if (fpAbs(angVelX) < angularClampThreshold) angVelX = 0;\n        if (fpAbs(angVelY) < angularClampThreshold) angVelY = 0;\n        if (fpAbs(angVelZ) < angularClampThreshold) angVelZ = 0;\n\n        body.angularVelocity.x = angVelX;\n        body.angularVelocity.y = angVelY;\n        body.angularVelocity.z = angVelZ;\n\n        const angVelLengthSq = fpMul(angVelX, angVelX) + fpMul(angVelY, angVelY) + fpMul(angVelZ, angVelZ);\n\n        if (angVelLengthSq > 0) {\n            const angSpeed = fpSqrt(angVelLengthSq);\n            const angle = fpMul(angSpeed, dt);\n            const invSpeed = fpDiv(FP_ONE, angSpeed);\n            const axis = {\n                x: fpMul(angVelX, invSpeed),\n                y: fpMul(angVelY, invSpeed),\n                z: fpMul(angVelZ, invSpeed)\n            };\n            const rotDelta = quatFromAxisAngle(axis, angle);\n            body.rotation = quatNormalize(quatMul(rotDelta, body.rotation));\n        }\n\n        // Sleep detection\n        const speedSq = vec3LengthSq(body.linearVelocity);\n        const angSpeedSq = vec3LengthSq(body.angularVelocity);\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\n\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\n            const sleepIncrement = sleepingContactBodies.has(body) ? (1 + CONTACT_SLEEP_BONUS) : 1;\n            body.sleepFrames += sleepIncrement;\n\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\n                body.isSleeping = true;\n                body.linearVelocity = vec3Zero();\n                body.angularVelocity = vec3Zero();\n            }\n        } else {\n            body.sleepFrames = 0;\n            body.isSleeping = false;\n        }\n    }\n\n    return contacts;\n}\n", "/**\n * Raycasting\n *\n * Ray-body intersection tests for visibility checks,\n * hit detection, and other line-of-sight queries.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Add, vec3Sub, vec3Scale, vec3Dot, vec3Normalize } from '../../math/vec';\nimport { ShapeType, SphereShape, BoxShape } from './shapes';\nimport { RigidBody } from './rigid-body';\nimport { World } from './world';\n\n// ============================================\n// Ray Hit Result\n// ============================================\n\nexport interface RayHit {\n    body: RigidBody;\n    point: Vec3;\n    normal: Vec3;\n    distance: Fixed;\n}\n\n// ============================================\n// Raycast Functions\n// ============================================\n\nexport function raycast(world: World, origin: Vec3, direction: Vec3, maxDistance: Fixed): RayHit | null {\n    const dir = vec3Normalize(direction);\n    let closestHit: RayHit | null = null;\n    let closestDist = maxDistance;\n\n    for (const body of world.bodies) {\n        const hit = raycastBody(body, origin, dir, closestDist);\n        if (hit && hit.distance < closestDist) {\n            closestDist = hit.distance;\n            closestHit = hit;\n        }\n    }\n\n    return closestHit;\n}\n\nfunction raycastBody(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    if (body.shape.type === ShapeType.Sphere) {\n        return raycastSphere(body, origin, dir, maxDist);\n    } else {\n        return raycastBox(body, origin, dir, maxDist);\n    }\n}\n\nfunction raycastSphere(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    const shape = body.shape as SphereShape;\n    const oc = vec3Sub(origin, body.position);\n\n    const a = vec3Dot(dir, dir);\n    const b = fpMul(toFixed(2), vec3Dot(oc, dir));\n    const c = vec3Dot(oc, oc) - fpMul(shape.radius, shape.radius);\n\n    const discriminant = fpMul(b, b) - fpMul(fpMul(toFixed(4), a), c);\n    if (discriminant < 0) return null;\n\n    const sqrtD = fpSqrt(discriminant);\n    let t = fpDiv(-b - sqrtD, fpMul(toFixed(2), a));\n\n    if (t < 0) {\n        t = fpDiv(-b + sqrtD, fpMul(toFixed(2), a));\n        if (t < 0) return null;\n    }\n\n    if (t > maxDist) return null;\n\n    const point = vec3Add(origin, vec3Scale(dir, t));\n    const normal = vec3Normalize(vec3Sub(point, body.position));\n\n    return { body, point, normal, distance: t };\n}\n\nfunction raycastBox(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    const shape = body.shape as BoxShape;\n    const h = shape.halfExtents;\n    const pos = body.position;\n\n    // AABB ray intersection\n    let tMin = -0x7FFFFFFF;\n    let tMax = 0x7FFFFFFF;\n    let normalAxis = 0;\n    let normalSign = 1;\n\n    // X axis\n    {\n        const invD = dir.x !== 0 ? fpDiv(FP_ONE, dir.x) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.x - h.x) - origin.x, invD);\n        let t1 = fpMul((pos.x + h.x) - origin.x, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 0; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    // Y axis\n    {\n        const invD = dir.y !== 0 ? fpDiv(FP_ONE, dir.y) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.y - h.y) - origin.y, invD);\n        let t1 = fpMul((pos.y + h.y) - origin.y, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 1; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    // Z axis\n    {\n        const invD = dir.z !== 0 ? fpDiv(FP_ONE, dir.z) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.z - h.z) - origin.z, invD);\n        let t1 = fpMul((pos.z + h.z) - origin.z, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 2; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    if (tMin < 0 || tMin > maxDist) return null;\n\n    const point = vec3Add(origin, vec3Scale(dir, tMin));\n    const normal = vec3(\n        normalAxis === 0 ? toFixed(normalSign) : 0,\n        normalAxis === 1 ? toFixed(normalSign) : 0,\n        normalAxis === 2 ? toFixed(normalSign) : 0\n    );\n\n    return { body, point, normal, distance: tMin };\n}\n", "/**\n * State Serialization\n *\n * Functions for saving and loading world state for rollback netcode.\n * Uses labels for body matching to ensure determinism across clients.\n */\n\nimport { Fixed } from '../../math/fixed';\nimport { World } from './world';\n\n// ============================================\n// State Interfaces\n// ============================================\n\nexport interface BodyState {\n    id: number;\n    label: string;  // Used for matching bodies across clients with different IDs\n    px: Fixed; py: Fixed; pz: Fixed;\n    qx: Fixed; qy: Fixed; qz: Fixed; qw: Fixed;\n    vx: Fixed; vy: Fixed; vz: Fixed;\n    avx: Fixed; avy: Fixed; avz: Fixed;\n    isSleeping: boolean;\n    sleepFrames: number;\n}\n\nexport interface WorldState {\n    bodies: BodyState[];\n}\n\n// ============================================\n// State Functions\n// ============================================\n\nexport function saveWorldState(world: World): WorldState {\n    return {\n        bodies: world.bodies.map(b => ({\n            id: b.id,\n            label: b.label,\n            px: b.position.x, py: b.position.y, pz: b.position.z,\n            qx: b.rotation.x, qy: b.rotation.y, qz: b.rotation.z, qw: b.rotation.w,\n            vx: b.linearVelocity.x, vy: b.linearVelocity.y, vz: b.linearVelocity.z,\n            avx: b.angularVelocity.x, avy: b.angularVelocity.y, avz: b.angularVelocity.z,\n            isSleeping: b.isSleeping,\n            sleepFrames: b.sleepFrames,\n        }))\n    };\n}\n\nexport function loadWorldState(world: World, state: WorldState): void {\n    // Build set of labels that should exist\n    const snapshotLabels = new Set(state.bodies.map(bs => bs.label));\n\n    // Remove bodies that exist in world but not in snapshot (created after snapshot was taken)\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\n        if (!snapshotLabels.has(world.bodies[i].label)) {\n            world.bodies.splice(i, 1);\n        }\n    }\n\n    // Use label for matching - body IDs may differ across clients\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\n\n    for (const bs of state.bodies) {\n        const body = bodyMap.get(bs.label);\n        if (!body) continue;\n\n        body.position = { x: bs.px, y: bs.py, z: bs.pz };\n        body.rotation = { x: bs.qx, y: bs.qy, z: bs.qz, w: bs.qw };\n        body.linearVelocity = { x: bs.vx, y: bs.vy, z: bs.vz };\n        body.angularVelocity = { x: bs.avx, y: bs.avy, z: bs.avz };\n        body.isSleeping = bs.isSleeping;\n        body.sleepFrames = bs.sleepFrames;\n    }\n}\n", "/**\r\n * Rollback Networking for Deterministic Multiplayer\r\n *\r\n * Implements GGPO-style rollback netcode:\r\n * - Input delay buffer\r\n * - State snapshots for rollback\r\n * - Resimulation when late inputs arrive\r\n * - Input prediction for remote players\r\n *\r\n * Physics-agnostic: the game provides callbacks for state save/load/tick.\r\n * Works with modu-network for transport.\r\n */\r\n\r\n// Debug flag - set to true to enable verbose rollback logging\r\nconst DEBUG_ROLLBACK = false;\r\n\r\n// ============================================\r\n// Input Types\r\n// ============================================\r\n\r\nexport interface PlayerInput {\r\n    frame: number;\r\n    playerId: string;\r\n    data: any;           // Game-specific input data\r\n    predicted: boolean;  // Was this input predicted?\r\n}\r\n\r\nexport interface InputBuffer {\r\n    inputs: Map<number, PlayerInput[]>;  // frame -> inputs for that frame\r\n    lastConfirmedFrame: number;\r\n    lastReceivedFrame: Map<string, number>;  // playerId -> last frame we have confirmed input for\r\n}\r\n\r\n// ============================================\r\n// Snapshot Storage\r\n// ============================================\r\n\r\nexport interface Snapshot {\r\n    frame: number;\r\n    state: any;  // Opaque state - game decides what to save (entities, physics, etc.)\r\n}\r\n\r\n// ============================================\r\n// Rollback Manager\r\n// ============================================\r\n\r\nexport interface RollbackConfig {\r\n    inputDelay: number;        // Frames of local input delay (default: 2)\r\n    maxRollbackFrames: number; // Maximum frames to roll back (default: 8)\r\n    maxPredictionFrames: number; // Maximum frames to predict ahead (default: 8)\r\n    snapshotInterval: number;  // Save snapshot every N frames (default: 1)\r\n}\r\n\r\nexport interface RollbackManager {\r\n    // State\r\n    currentFrame: number;\r\n    localPlayerId: string;\r\n    players: Set<string>;\r\n\r\n    // Configuration\r\n    config: RollbackConfig;\r\n\r\n    // Input management\r\n    inputBuffer: InputBuffer;\r\n    localInputQueue: PlayerInput[];  // Delayed local inputs\r\n\r\n    // Snapshot management\r\n    snapshots: Map<number, Snapshot>;\r\n\r\n    // Callbacks (game provides these)\r\n    /** Save entire state (entities, physics, game data) - returns opaque state */\r\n    saveState: () => any;\r\n    /** Restore entire state */\r\n    loadState: (state: any) => void;\r\n    /** Execute one frame: apply inputs, step physics, update entities */\r\n    tick: (frame: number, inputs: PlayerInput[]) => void;\r\n    /** Compute sync checksum for state verification */\r\n    computeChecksum: () => number;\r\n\r\n    // Rollback tracking\r\n    /** Frame that needs rollback due to prediction mismatch (set by addInputToBuffer) */\r\n    pendingRollbackFrame?: number;\r\n\r\n    // Stats\r\n    rollbackCount: number;\r\n    maxRollbackDepth: number;\r\n    predictionMisses: number;\r\n}\r\n\r\nexport function createRollbackManager(\r\n    localPlayerId: string,\r\n    config: Partial<RollbackConfig> = {}\r\n): RollbackManager {\r\n    const inputDelay = config.inputDelay ?? 2;\r\n\r\n    return {\r\n        currentFrame: 0,\r\n        localPlayerId,\r\n        players: new Set([localPlayerId]),\r\n\r\n        config: {\r\n            inputDelay,\r\n            maxRollbackFrames: config.maxRollbackFrames ?? 8,\r\n            maxPredictionFrames: config.maxPredictionFrames ?? 8,\r\n            snapshotInterval: config.snapshotInterval ?? 1,\r\n        },\r\n\r\n        inputBuffer: {\r\n            inputs: new Map(),\r\n            lastConfirmedFrame: -1,\r\n            // Initialize lastReceivedFrame for local player\r\n            // This prevents confirmedFrame from being stuck at -1\r\n            lastReceivedFrame: new Map([[localPlayerId, 0]]),\r\n        },\r\n\r\n        localInputQueue: [],\r\n\r\n        snapshots: new Map(),\r\n\r\n        // These must be set by the game\r\n        saveState: () => ({}),\r\n        loadState: () => { },\r\n        tick: () => { },\r\n        computeChecksum: () => 0,\r\n\r\n        rollbackCount: 0,\r\n        maxRollbackDepth: 0,\r\n        predictionMisses: 0,\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Player Management\r\n// ============================================\r\n\r\nexport function addPlayer(manager: RollbackManager, playerId: string): void {\r\n    manager.players.add(playerId);\r\n    manager.inputBuffer.lastReceivedFrame.set(playerId, -1);\r\n}\r\n\r\n/**\r\n * Add a player who joins mid-game at a specific frame.\r\n * This properly initializes lastReceivedFrame and updates lastConfirmedFrame\r\n * to prevent the confirmation logic from getting stuck on frames before\r\n * the player joined (where they have no inputs).\r\n */\r\nexport function addPlayerAtFrame(manager: RollbackManager, playerId: string, joinFrame: number): void {\r\n    manager.players.add(playerId);\r\n    manager.inputBuffer.lastReceivedFrame.set(playerId, joinFrame);\r\n\r\n    // Update lastConfirmedFrame to skip frames before this player joined\r\n    // Otherwise updateConfirmedFrame will fail because the new player\r\n    // has no inputs for frames before their join\r\n    if (joinFrame - 1 > manager.inputBuffer.lastConfirmedFrame) {\r\n        manager.inputBuffer.lastConfirmedFrame = joinFrame - 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Clear snapshots older than a given frame.\r\n * Use this when adding a new player dynamically - it prevents rollback to\r\n * frames before the player's body existed in the physics world.\r\n *\r\n * Without this, a rollback to a snapshot without the player's body would cause\r\n * desync because the re-simulation would not include that player's physics.\r\n */\r\nexport function clearSnapshotsBefore(manager: RollbackManager, frame: number): void {\r\n    for (const snapshotFrame of manager.snapshots.keys()) {\r\n        if (snapshotFrame < frame) {\r\n            manager.snapshots.delete(snapshotFrame);\r\n        }\r\n    }\r\n    // Also clear inputs before this frame to prevent rollback triggering\r\n    for (const inputFrame of manager.inputBuffer.inputs.keys()) {\r\n        if (inputFrame < frame) {\r\n            manager.inputBuffer.inputs.delete(inputFrame);\r\n        }\r\n    }\r\n}\r\n\r\nexport function removePlayer(manager: RollbackManager, playerId: string): void {\r\n    manager.players.delete(playerId);\r\n    manager.inputBuffer.lastReceivedFrame.delete(playerId);\r\n}\r\n\r\n// ============================================\r\n// Input Management\r\n// ============================================\r\n\r\n/** Add local input (will be delayed by inputDelay frames) */\r\nexport function addLocalInput(manager: RollbackManager, data: any): void {\r\n    const { currentFrame, config, localPlayerId, inputBuffer } = manager;\r\n    const targetFrame = currentFrame + config.inputDelay;\r\n\r\n    // Add CONFIRMED input for the target frame (when input will be \"official\")\r\n    const input: PlayerInput = {\r\n        frame: targetFrame,\r\n        playerId: localPlayerId,\r\n        data,\r\n        predicted: false,\r\n    };\r\n\r\n    manager.localInputQueue.push(input);\r\n    addInputToBuffer(manager, input);\r\n\r\n    // Update lastReceivedFrame for local player\r\n    // This is critical for confirmedFrame calculation\r\n    const lastReceived = inputBuffer.lastReceivedFrame.get(localPlayerId) ?? -1;\r\n    if (targetFrame > lastReceived) {\r\n        inputBuffer.lastReceivedFrame.set(localPlayerId, targetFrame);\r\n    }\r\n\r\n    // KEY FOR ZERO PERCEIVED LATENCY:\r\n    // Also add PREDICTIONS for frames between current and target.\r\n    // This gives immediate local response while maintaining network sync.\r\n    //\r\n    // For LOCAL player predictions:\r\n    // - We MUST update existing predictions with the latest input data\r\n    // - When we send input for frame N+delay, remote clients backfill frames N to N+delay-1\r\n    // - If we don't update our own predictions, we desync because remote has new data, we have old\r\n    //\r\n    // For REMOTE player predictions (handled in addRemoteInput):\r\n    // - Only add if no prediction exists, to avoid overwriting with outdated data\r\n    for (let f = currentFrame; f < targetFrame; f++) {\r\n        const frameInputs = inputBuffer.inputs.get(f);\r\n        const existingInput = frameInputs?.find(i => i.playerId === localPlayerId);\r\n\r\n        // For local player: always update predictions with latest input\r\n        // (Remote players receive this same data via backfill in addRemoteInput)\r\n        if (!existingInput) {\r\n            // No input exists - add new prediction\r\n            const prediction: PlayerInput = {\r\n                frame: f,\r\n                playerId: localPlayerId,\r\n                data,\r\n                predicted: true,\r\n            };\r\n            addInputToBuffer(manager, prediction);\r\n        } else if (existingInput.predicted) {\r\n            // Existing prediction - update with latest data\r\n            existingInput.data = data;\r\n        } else if (f === currentFrame) {\r\n            // CRITICAL FIX: For the CURRENT frame, also update confirmed inputs!\r\n            // The \"confirmed\" input was scheduled from a previous frame (currentFrame - inputDelay).\r\n            // But the player's CURRENT input (what they're pressing NOW) should take precedence\r\n            // for the frame we're about to simulate. This gives zero-latency local response.\r\n            // Without this, old scheduled inputs would override the player's current intent.\r\n            existingInput.data = data;\r\n        }\r\n        // For future confirmed inputs (f > currentFrame), don't touch - they're properly scheduled\r\n    }\r\n}\r\n\r\n/** Add remote input received from network */\r\nexport function addRemoteInput(manager: RollbackManager, frame: number, playerId: string, data: any): void {\r\n    const { config, inputBuffer, currentFrame } = manager;\r\n\r\n    const input: PlayerInput = {\r\n        frame,\r\n        playerId,\r\n        data,\r\n        predicted: false,\r\n    };\r\n\r\n    addInputToBuffer(manager, input);\r\n\r\n    // CRITICAL FOR ZERO-LATENCY SYNC:\r\n    // When remote player sent input for frame F, they ALSO predicted the same input\r\n    // for frames (F - inputDelay) to (F - 1) via addLocalInput's zero-latency feature.\r\n    // We need to match this by adding predictions here, which will trigger rollback\r\n    // if our existing predictions were different.\r\n    //\r\n    // This ensures: when remote player pressed W at frame 100 (confirmed at 104),\r\n    // we also add W predictions for frames 100-103, which triggers rollback if\r\n    // we predicted differently.\r\n    const predictionStartFrame = Math.max(0, frame - config.inputDelay);\r\n    const predictionEndFrame = frame; // exclusive\r\n\r\n    for (let f = predictionStartFrame; f < predictionEndFrame; f++) {\r\n        // Backfill frames that are either:\r\n        // 1. In the past (already simulated) - need rollback\r\n        // 2. In the near future (within inputDelay) - will be simulated soon with wrong prediction\r\n        // Only skip frames that are too old to rollback\r\n        const isPastFrame = f <= currentFrame;\r\n        const isFutureButSoon = f > currentFrame && f < currentFrame + config.inputDelay;\r\n        const isTooOld = f < currentFrame - config.maxRollbackFrames;\r\n\r\n        if ((isPastFrame || isFutureButSoon) && !isTooOld) {\r\n            const frameInputs = inputBuffer.inputs.get(f);\r\n\r\n            // Check for existing confirmed input\r\n            const existingConfirmed = frameInputs?.find(i => i.playerId === playerId && !i.predicted);\r\n            if (existingConfirmed) {\r\n                // CRITICAL FIX: For the CURRENT frame, update confirmed inputs with newer data!\r\n                // The existing confirmed was scheduled from inputDelay frames ago.\r\n                // The new backfill represents the player's actual input for this frame.\r\n                // Without this, old scheduled inputs override the player's current intent.\r\n                if (f === currentFrame) {\r\n                    existingConfirmed.data = data;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // Add as CONFIRMED input (predicted: false)\r\n            // The remote player used this input for their local prediction, so it's authoritative.\r\n            // addInputToBuffer will handle checking for prediction mismatch and setting needsRollback.\r\n            const backfilledInput: PlayerInput = {\r\n                frame: f,\r\n                playerId,\r\n                data,\r\n                predicted: false,\r\n            };\r\n\r\n            addInputToBuffer(manager, backfilledInput);\r\n        }\r\n    }\r\n\r\n    // Update last received frame for this player\r\n    const lastReceived = inputBuffer.lastReceivedFrame.get(playerId) ?? -1;\r\n    if (frame > lastReceived) {\r\n        inputBuffer.lastReceivedFrame.set(playerId, frame);\r\n    }\r\n}\r\n\r\nfunction addInputToBuffer(manager: RollbackManager, input: PlayerInput): void {\r\n    const { inputBuffer } = manager;\r\n\r\n    if (!inputBuffer.inputs.has(input.frame)) {\r\n        inputBuffer.inputs.set(input.frame, []);\r\n    }\r\n\r\n    const frameInputs = inputBuffer.inputs.get(input.frame)!;\r\n\r\n    // Replace any existing input from this player for this frame\r\n    const existingIdx = frameInputs.findIndex(i => i.playerId === input.playerId);\r\n    if (existingIdx >= 0) {\r\n        const existing = frameInputs[existingIdx];\r\n        // Check if this was a prediction that's now confirmed\r\n        if (existing.predicted && !input.predicted) {\r\n            // Check if prediction was correct (compare only discrete inputs, not continuous values like yaw)\r\n            if (inputsDifferSignificantly(existing.data, input.data)) {\r\n                manager.predictionMisses++;\r\n                // Store the earliest frame needing rollback directly on manager\r\n                // This ensures we don't miss it even if the frame is outside the scan window\r\n                const pendingRollback = manager.pendingRollbackFrame;\r\n                if (pendingRollback === undefined || input.frame < pendingRollback) {\r\n                    manager.pendingRollbackFrame = input.frame;\r\n                }\r\n                if (DEBUG_ROLLBACK) {\r\n                    console.log(`[MISMATCH] frame=${input.frame} player=${input.playerId} predicted=${JSON.stringify(existing.data)} actual=${JSON.stringify(input.data)}`);\r\n                }\r\n            }\r\n        }\r\n        frameInputs[existingIdx] = input;\r\n    } else {\r\n        frameInputs.push(input);\r\n    }\r\n}\r\n\r\n/** Compare inputs, ignoring continuously-changing values like yaw/pitch */\r\nfunction inputsDifferSignificantly(a: any, b: any): boolean {\r\n    if (!a && !b) return false;\r\n    if (!a || !b) return true;\r\n\r\n    // Compare ALL discrete inputs - any boolean or action key\r\n    // Continuous values to ignore: yaw, pitch, shootDirX/Y/Z, rotX/Y/Z, lookX/Y\r\n    // yawFp is the fixed-point version of yaw used in the browser demo\r\n    const continuousKeys = new Set([\r\n        'yaw', 'yawFp', 'pitch', 'pitchFp', 'roll', 'rollFp',\r\n        'shootDirX', 'shootDirY', 'shootDirZ',\r\n        'lookX', 'lookY',\r\n        'rotX', 'rotY', 'rotZ',\r\n        'mouseX', 'mouseY',\r\n        'aimX', 'aimY', 'aimZ'\r\n    ]);\r\n\r\n    // Compare all keys in both objects\r\n    const allKeys = new Set([...Object.keys(a || {}), ...Object.keys(b || {})]);\r\n\r\n    for (const key of allKeys) {\r\n        // Skip continuous values\r\n        if (continuousKeys.has(key)) continue;\r\n\r\n        // Compare the values\r\n        if (a[key] !== b[key]) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Get inputs for a specific frame, predicting if necessary */\r\nexport function getInputsForFrame(manager: RollbackManager, frame: number): PlayerInput[] {\r\n    const { inputBuffer, players, localPlayerId } = manager;\r\n    const inputs: PlayerInput[] = [];\r\n\r\n    // CRITICAL: Sort players for deterministic iteration order\r\n    // Without this, Set insertion order differs per client, causing simulation divergence\r\n    const sortedPlayers = Array.from(players).sort();\r\n\r\n    for (const playerId of sortedPlayers) {\r\n        const frameInputs = inputBuffer.inputs.get(frame);\r\n\r\n        // 1. First check for confirmed input\r\n        const confirmed = frameInputs?.find(i => i.playerId === playerId && !i.predicted);\r\n        if (confirmed) {\r\n            inputs.push(confirmed);\r\n            continue;\r\n        }\r\n\r\n        // 2. Then check for EXISTING prediction (from addLocalInput's zero-latency prediction)\r\n        // This is CRITICAL for immediate local response - addLocalInput adds predictions\r\n        // for frames currentFrame to currentFrame+inputDelay-1, so we must USE them here\r\n        const existingPrediction = frameInputs?.find(i => i.playerId === playerId && i.predicted);\r\n        if (existingPrediction) {\r\n            inputs.push(existingPrediction);\r\n            continue;\r\n        }\r\n\r\n        // 3. Only create new prediction from history if nothing exists\r\n        const predicted = predictInput(manager, frame, playerId);\r\n        inputs.push(predicted);\r\n        addInputToBuffer(manager, predicted);\r\n    }\r\n\r\n    return inputs;\r\n}\r\n\r\n/** Predict input for a player based on their last known input */\r\nfunction predictInput(manager: RollbackManager, frame: number, playerId: string): PlayerInput {\r\n    const { inputBuffer } = manager;\r\n\r\n    // Find the most recent confirmed input from this player\r\n    let lastInput: PlayerInput | null = null;\r\n\r\n    for (let f = frame - 1; f >= Math.max(0, frame - 60); f--) {\r\n        const frameInputs = inputBuffer.inputs.get(f);\r\n        const input = frameInputs?.find(i => i.playerId === playerId && !i.predicted);\r\n        if (input) {\r\n            lastInput = input;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Predict: repeat last input, or use neutral defaults if no input exists\r\n    // CRITICAL: Default to neutral state (no movement, no actions) rather than empty object\r\n    // Empty object causes issues because fields like yawFp would be missing\r\n    const predictedData = lastInput ? { ...lastInput.data } : {\r\n        w: false, a: false, s: false, d: false, jump: false, yawFp: 0\r\n    };\r\n\r\n    return {\r\n        frame,\r\n        playerId,\r\n        data: predictedData,\r\n        predicted: true,\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Snapshot Management\r\n// ============================================\r\n\r\nexport function saveSnapshot(manager: RollbackManager): void {\r\n    const { currentFrame, config, snapshots } = manager;\r\n\r\n    // Only save on interval\r\n    if (currentFrame % config.snapshotInterval !== 0) return;\r\n\r\n    const snapshot: Snapshot = {\r\n        frame: currentFrame,\r\n        state: manager.saveState(),\r\n    };\r\n\r\n    snapshots.set(currentFrame, snapshot);\r\n\r\n    // Clean up old snapshots (keep last maxRollbackFrames + some buffer)\r\n    const keepFrom = currentFrame - config.maxRollbackFrames - 10;\r\n    for (const frame of snapshots.keys()) {\r\n        if (frame < keepFrom) {\r\n            snapshots.delete(frame);\r\n        }\r\n    }\r\n}\r\n\r\nexport function loadSnapshot(manager: RollbackManager, frame: number): boolean {\r\n    const snapshot = manager.snapshots.get(frame);\r\n    if (!snapshot) return false;\r\n\r\n    manager.loadState(snapshot.state);\r\n    return true;\r\n}\r\n\r\n// ============================================\r\n// Rollback Logic\r\n// ============================================\r\n\r\n/** Check if rollback is needed and return the frame to rollback to */\r\nexport function checkRollback(manager: RollbackManager): number | null {\r\n    const { currentFrame, config } = manager;\r\n\r\n    // Check if there's a pending rollback frame stored by addInputToBuffer\r\n    const pendingRollback = manager.pendingRollbackFrame;\r\n    if (pendingRollback !== undefined) {\r\n        // Clear the pending rollback\r\n        manager.pendingRollbackFrame = undefined;\r\n\r\n        // Only rollback if within the max rollback window\r\n        if (currentFrame - pendingRollback <= config.maxRollbackFrames) {\r\n            return pendingRollback;\r\n        } else if (DEBUG_ROLLBACK) {\r\n            console.warn(`[ROLLBACK_MISSED] frame=${pendingRollback} is too old (current=${currentFrame}, max=${config.maxRollbackFrames})`);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/** Perform rollback and resimulation */\r\nexport function performRollback(\r\n    manager: RollbackManager,\r\n    toFrame: number\r\n): void {\r\n    const { currentFrame } = manager;\r\n\r\n    // Find nearest snapshot at or before toFrame\r\n    let snapshotFrame = toFrame;\r\n    while (snapshotFrame >= 0 && !manager.snapshots.has(snapshotFrame)) {\r\n        snapshotFrame--;\r\n    }\r\n\r\n    if (snapshotFrame < 0) {\r\n        if (DEBUG_ROLLBACK) console.warn('[ROLLBACK] No snapshot found for rollback');\r\n        return;\r\n    }\r\n\r\n    // Load snapshot\r\n    if (!loadSnapshot(manager, snapshotFrame)) {\r\n        if (DEBUG_ROLLBACK) console.warn('[ROLLBACK] Failed to load snapshot');\r\n        return;\r\n    }\r\n\r\n    manager.rollbackCount++;\r\n    const rollbackDepth = currentFrame - snapshotFrame;\r\n    if (rollbackDepth > manager.maxRollbackDepth) {\r\n        manager.maxRollbackDepth = rollbackDepth;\r\n    }\r\n\r\n    if (DEBUG_ROLLBACK) {\r\n        console.log(`[ROLLBACK] Rolling back from ${currentFrame} to ${snapshotFrame} (${rollbackDepth} frames), available snapshots: ${[...manager.snapshots.keys()].sort((a,b)=>a-b).join(',')}`);\r\n    }\r\n\r\n    // Resimulate from snapshot to current frame\r\n    for (let frame = snapshotFrame; frame < currentFrame; frame++) {\r\n        manager.currentFrame = frame;\r\n\r\n        // Save snapshot BEFORE tick\r\n        saveSnapshot(manager);\r\n\r\n        // Get inputs for this frame (now with confirmed inputs)\r\n        const inputs = getInputsForFrame(manager, frame);\r\n\r\n        // Execute frame (game applies inputs and steps physics)\r\n        manager.tick(frame, inputs);\r\n\r\n        manager.currentFrame = frame + 1;\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Frame Advance\r\n// ============================================\r\n\r\n/** Advance simulation by one frame */\r\nexport function advanceFrame(\r\n    manager: RollbackManager\r\n): { inputs: PlayerInput[]; didRollback: boolean } {\r\n    let didRollback = false;\r\n\r\n    // Check if we need to rollback\r\n    const rollbackTo = checkRollback(manager);\r\n    if (rollbackTo !== null && rollbackTo < manager.currentFrame) {\r\n        performRollback(manager, rollbackTo);\r\n        didRollback = true;\r\n    }\r\n\r\n    // Save snapshot before advancing\r\n    saveSnapshot(manager);\r\n\r\n    // Get inputs for current frame\r\n    const inputs = getInputsForFrame(manager, manager.currentFrame);\r\n\r\n    // Execute frame (game applies inputs and steps physics)\r\n    manager.tick(manager.currentFrame, inputs);\r\n\r\n    // Advance frame counter\r\n    manager.currentFrame++;\r\n\r\n    // Update last confirmed frame\r\n    updateConfirmedFrame(manager);\r\n\r\n    // Clean up old inputs\r\n    cleanupInputs(manager);\r\n\r\n    return { inputs, didRollback };\r\n}\r\n\r\nfunction updateConfirmedFrame(manager: RollbackManager): void {\r\n    const { inputBuffer, players, currentFrame, config } = manager;\r\n\r\n    // Start from the next unconfirmed frame\r\n    // Skip very early frames that won't have inputs due to inputDelay\r\n    const startFrame = Math.max(\r\n        inputBuffer.lastConfirmedFrame + 1,\r\n        config.inputDelay  // First frame that could possibly have inputs\r\n    );\r\n\r\n    // DETERMINISM: Sort players for consistent iteration order\r\n    const sortedPlayers = Array.from(players).sort();\r\n\r\n    // Find the latest frame where all players have confirmed inputs\r\n    for (let frame = startFrame; frame < currentFrame; frame++) {\r\n        const frameInputs = inputBuffer.inputs.get(frame);\r\n        if (!frameInputs) {\r\n            // No inputs for this frame yet, can't confirm further\r\n            break;\r\n        }\r\n\r\n        let allConfirmed = true;\r\n        for (const playerId of sortedPlayers) {\r\n            const input = frameInputs.find(i => i.playerId === playerId && !i.predicted);\r\n            if (!input) {\r\n                allConfirmed = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (allConfirmed) {\r\n            inputBuffer.lastConfirmedFrame = frame;\r\n        } else {\r\n            // Can't confirm this frame, stop checking\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nfunction cleanupInputs(manager: RollbackManager): void {\r\n    const { inputBuffer, config, currentFrame } = manager;\r\n\r\n    // Keep inputs for potential rollback\r\n    const keepFrom = currentFrame - config.maxRollbackFrames - 10;\r\n\r\n    for (const frame of inputBuffer.inputs.keys()) {\r\n        if (frame < keepFrom) {\r\n            inputBuffer.inputs.delete(frame);\r\n        }\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Network Integration\r\n// ============================================\r\n\r\n/** Get local inputs that need to be sent to network */\r\nexport function getInputsToSend(manager: RollbackManager): PlayerInput[] {\r\n    // Return inputs from local queue that are ready to send\r\n    const ready = manager.localInputQueue.filter(i => i.frame <= manager.currentFrame + manager.config.inputDelay);\r\n\r\n    // Remove sent inputs from queue\r\n    manager.localInputQueue = manager.localInputQueue.filter(i => i.frame > manager.currentFrame + manager.config.inputDelay);\r\n\r\n    return ready;\r\n}\r\n\r\n/** Get sync state for network (frame + checksum) */\r\nexport function getSyncState(manager: RollbackManager): { frame: number; checksum: number } {\r\n    return {\r\n        frame: manager.currentFrame,\r\n        checksum: manager.computeChecksum()\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Debugging\r\n// ============================================\r\n\r\nexport function getRollbackStats(manager: RollbackManager): {\r\n    currentFrame: number;\r\n    confirmedFrame: number;\r\n    rollbackCount: number;\r\n    maxRollbackDepth: number;\r\n    predictionMisses: number;\r\n    snapshotCount: number;\r\n    inputBufferSize: number;\r\n} {\r\n    return {\r\n        currentFrame: manager.currentFrame,\r\n        confirmedFrame: manager.inputBuffer.lastConfirmedFrame,\r\n        rollbackCount: manager.rollbackCount,\r\n        maxRollbackDepth: manager.maxRollbackDepth,\r\n        predictionMisses: manager.predictionMisses,\r\n        snapshotCount: manager.snapshots.size,\r\n        inputBufferSize: manager.inputBuffer.inputs.size,\r\n    };\r\n}\r\n"],
  "mappings": "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;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;A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",
  "names": ["buffer", "def", "syncFieldsSet", "vec2", "vec2Add", "vec2Clone", "vec2Cross", "vec2Dot", "vec2LengthSq", "vec2Scale", "vec2Sub", "vec2Zero", "Shape2DType", "BodyType2D", "vec2Zero", "vec2", "vec2Clone", "vec2Add", "vec2Sub", "vec2Scale", "vec2Dot", "vec2LengthSq", "vec2Cross", "vec2Add", "vec2Scale", "vec2LengthSq", "vec2Zero", "FP_ONE_TWELFTH", "DEFAULT_FILTER", "Layers", "TriggerState", "createFilter", "filterCollidingWith", "filterExcluding", "makeTrigger", "shouldCollide", "ShapeType", "Layers", "DEFAULT_FILTER", "createFilter", "shouldCollide", "filterCollidingWith", "filterExcluding", "RESTITUTION_DEFAULT", "FRICTION_DEFAULT", "BodyType", "DEFAULT_FILTER", "a", "b", "TriggerState", "makeTrigger", "LINEAR_DAMPING", "ANGULAR_DAMPING", "SLEEP_THRESHOLD", "SLEEP_FRAMES_REQUIRED", "TriggerState", "shouldCollide"]
}
