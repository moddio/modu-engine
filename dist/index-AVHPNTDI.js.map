{
  "version": 3,
  "sources": ["../src/math/fixed.ts", "../src/math/vec.ts", "../src/math/quat.ts", "../src/math/random.ts", "../src/core/constants.ts", "../src/core/component.ts", "../src/core/entity-id.ts", "../src/components/index.ts", "../src/core/entity.ts", "../src/core/query.ts", "../src/core/system.ts", "../src/core/snapshot.ts", "../src/core/string-registry.ts", "../src/hash/xxhash.ts", "../src/core/world.ts", "../src/codec/index.ts", "../src/codec/binary.ts", "../src/sync/state-delta.ts", "../src/sync/partition.ts", "../src/game.ts", "../src/plugins/simple-2d-renderer.ts", "../src/plugins/input-plugin.ts", "../src/plugins/camera-system.ts", "../src/plugins/determinism-guard.ts", "../src/version.ts", "../src/plugins/debug-ui.ts", "../src/plugins/physics2d/index.ts", "../src/plugins/physics2d/shapes.ts", "../src/plugins/physics2d/layers.ts", "../src/plugins/physics2d/rigid-body.ts", "../src/plugins/physics2d/collision.ts", "../src/plugins/physics2d/spatial-hash.ts", "../src/plugins/physics2d/world.ts", "../src/plugins/physics2d/quad-tree.ts", "../src/plugins/physics2d/trigger.ts", "../src/plugins/physics2d/system.ts", "../src/plugins/physics3d/index.ts", "../src/plugins/physics3d/shapes.ts", "../src/plugins/physics3d/layers.ts", "../src/plugins/physics3d/rigid-body.ts", "../src/plugins/physics3d/collision.ts", "../src/plugins/physics3d/trigger.ts", "../src/plugins/physics3d/world.ts", "../src/plugins/physics3d/raycast.ts", "../src/plugins/physics3d/state.ts"],
  "sourcesContent": ["/**\n * Fixed-Point Math Library for Deterministic Physics\n *\n * Uses 32-bit integers with 16.16 fixed-point format:\n * - 16 bits for integer part (-32768 to 32767)\n * - 16 bits for fractional part (precision ~0.000015)\n *\n * All operations are 100% deterministic across platforms.\n */\n\n// Fixed-point constants\nexport const FP_SHIFT = 16;\nexport const FP_ONE = 1 << FP_SHIFT;  // 65536\nexport const FP_HALF = FP_ONE >> 1;    // 32768\nexport const FP_PI = 205887;           // PI * 65536\nexport const FP_2PI = 411775;          // 2*PI * 65536\nexport const FP_HALF_PI = 102944;      // PI/2 * 65536\n\n// Type alias for fixed-point numbers (just integers)\nexport type Fixed = number;\n\n// ============================================\n// Basic Fixed-Point Operations\n// ============================================\n\n/** Convert float to fixed-point */\nexport function toFixed(f: number): Fixed {\n    return Math.round(f * FP_ONE);\n}\n\n/** Convert fixed-point to float (for rendering only) */\nexport function toFloat(fp: Fixed): number {\n    return fp / FP_ONE;\n}\n\n/** Fixed-point multiplication */\nexport function fpMul(a: Fixed, b: Fixed): Fixed {\n    // Use BigInt for intermediate to avoid overflow\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\n    // (e.g., distance calculations on a 1400x900 canvas can overflow)\n    // JavaScript numbers can safely represent integers up to 2^53\n    return Number((BigInt(a) * BigInt(b)) >> BigInt(FP_SHIFT));\n}\n\n/** Fixed-point division */\nexport function fpDiv(a: Fixed, b: Fixed): Fixed {\n    if (b === 0) return a >= 0 ? 0x7FFFFFFF : -0x7FFFFFFF;\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\n    return Number((BigInt(a) << BigInt(FP_SHIFT)) / BigInt(b));\n}\n\n/** Fixed-point absolute value */\nexport function fpAbs(a: Fixed): Fixed {\n    return a < 0 ? -a : a;\n}\n\n/** Fixed-point sign */\nexport function fpSign(a: Fixed): Fixed {\n    return a > 0 ? FP_ONE : a < 0 ? -FP_ONE : 0;\n}\n\n/** Fixed-point min */\nexport function fpMin(a: Fixed, b: Fixed): Fixed {\n    return a < b ? a : b;\n}\n\n/** Fixed-point max */\nexport function fpMax(a: Fixed, b: Fixed): Fixed {\n    return a > b ? a : b;\n}\n\n/** Fixed-point clamp */\nexport function fpClamp(v: Fixed, min: Fixed, max: Fixed): Fixed {\n    return v < min ? min : v > max ? max : v;\n}\n\n/** Fixed-point floor */\nexport function fpFloor(a: Fixed): Fixed {\n    return a & ~(FP_ONE - 1);\n}\n\n/** Fixed-point ceil */\nexport function fpCeil(a: Fixed): Fixed {\n    return (a + FP_ONE - 1) & ~(FP_ONE - 1);\n}\n\n// ============================================\n// Square Root (using Newton-Raphson)\n// ============================================\n\n/** Fixed-point square root using Newton-Raphson iteration */\nexport function fpSqrt(a: Fixed): Fixed {\n    if (a <= 0) return 0;\n\n    // For 16.16 fixed-point: if a = v * 65536, we want sqrt(v) * 65536\n    // sqrt(a) would give sqrt(v) * 256, which is 256x too small!\n    // Solution: compute sqrt(a * 65536) = sqrt(a) * 256 = sqrt(v) * 65536\n    const scaled = BigInt(a) * BigInt(FP_ONE);\n    if (scaled <= 0n) return 0;\n\n    // Better initial guess using bit length\n    let bitLen = 0n;\n    let temp = scaled;\n    while (temp > 0n) {\n        bitLen++;\n        temp >>= 1n;\n    }\n\n    let x = 1n << (bitLen >> 1n);\n    if (x === 0n) x = 1n;\n\n    // Newton-Raphson with proper convergence check\n    let prevX = 0n;\n    for (let i = 0; i < 30; i++) {\n        const xNew = (x + scaled / x) >> 1n;\n        // Check for true convergence (oscillating between x and x+1)\n        if (xNew === x || xNew === prevX) break;\n        prevX = x;\n        x = xNew;\n    }\n\n    // Final adjustment: ensure x*x <= scaled < (x+1)*(x+1)\n    while (x * x > scaled) x--;\n    while ((x + 1n) * (x + 1n) <= scaled) x++;\n\n    return Number(x);\n}\n\n/**\n * Deterministic square root (float API).\n * Takes a float, returns a float, but uses fixed-point internally for determinism.\n *\n * @example\n * const dist = dSqrt(dx * dx + dy * dy);  // Deterministic!\n */\nexport function dSqrt(x: number): number {\n    return toFloat(fpSqrt(toFixed(x)));\n}\n\n// ============================================\n// Trigonometry (Lookup Tables)\n// ============================================\n\n// Sine lookup table (257 entries for 0 to PI/2, inclusive)\n// PRE-COMPUTED for cross-platform determinism - DO NOT use Math.sin() at runtime!\n// Math.sin() produces different results across browsers/CPUs, breaking determinism.\nconst SIN_TABLE_SIZE = 256;\nconst SIN_TABLE: Fixed[] = [\n    0, 402, 804, 1206, 1608, 2010, 2412, 2814, 3216, 3617, 4019, 4420, 4821, 5222, 5623, 6023,\n    6424, 6824, 7224, 7623, 8022, 8421, 8820, 9218, 9616, 10014, 10411, 10808, 11204, 11600, 11996, 12391,\n    12785, 13180, 13573, 13966, 14359, 14751, 15143, 15534, 15924, 16314, 16703, 17091, 17479, 17867, 18253, 18639,\n    19024, 19409, 19792, 20175, 20557, 20939, 21320, 21699, 22078, 22457, 22834, 23210, 23586, 23961, 24335, 24708,\n    25080, 25451, 25821, 26190, 26558, 26925, 27291, 27656, 28020, 28383, 28745, 29106, 29466, 29824, 30182, 30538,\n    30893, 31248, 31600, 31952, 32303, 32652, 33000, 33347, 33692, 34037, 34380, 34721, 35062, 35401, 35738, 36075,\n    36410, 36744, 37076, 37407, 37736, 38064, 38391, 38716, 39040, 39362, 39683, 40002, 40320, 40636, 40951, 41264,\n    41576, 41886, 42194, 42501, 42806, 43110, 43412, 43713, 44011, 44308, 44604, 44898, 45190, 45480, 45769, 46056,\n    46341, 46624, 46906, 47186, 47464, 47741, 48015, 48288, 48559, 48828, 49095, 49361, 49624, 49886, 50146, 50404,\n    50660, 50914, 51166, 51417, 51665, 51911, 52156, 52398, 52639, 52878, 53114, 53349, 53581, 53812, 54040, 54267,\n    54491, 54714, 54934, 55152, 55368, 55582, 55794, 56004, 56212, 56418, 56621, 56823, 57022, 57219, 57414, 57607,\n    57798, 57986, 58172, 58356, 58538, 58718, 58896, 59071, 59244, 59415, 59583, 59750, 59914, 60075, 60235, 60392,\n    60547, 60700, 60851, 60999, 61145, 61288, 61429, 61568, 61705, 61839, 61971, 62101, 62228, 62353, 62476, 62596,\n    62714, 62830, 62943, 63054, 63162, 63268, 63372, 63473, 63572, 63668, 63763, 63854, 63944, 64031, 64115, 64197,\n    64277, 64354, 64429, 64501, 64571, 64639, 64704, 64766, 64827, 64884, 64940, 64993, 65043, 65091, 65137, 65180,\n    65220, 65259, 65294, 65328, 65358, 65387, 65413, 65436, 65457, 65476, 65492, 65505, 65516, 65525, 65531, 65535,\n    65536  // sin(PI/2) = 1.0 = FP_ONE\n];\n\n// Pre-computed constant: (SIN_TABLE_SIZE * 2 / PI) in fixed-point\n// Used to map angles to table indices. Pre-computed to avoid Math.PI at runtime.\nconst FP_ANGLE_TO_INDEX = 10680707;  // = round(162.9746617261 * 65536)\n\n/** Fixed-point sine using lookup table with linear interpolation */\nexport function fpSin(angle: Fixed): Fixed {\n    // Normalize angle to 0 to 2PI using modulo (avoids infinite loops)\n    // First handle negative angles\n    if (angle < 0) {\n        const periods = ((-angle / FP_2PI) | 0) + 1;\n        angle += periods * FP_2PI;\n    }\n    // Then reduce to 0..2PI range\n    if (angle >= FP_2PI) {\n        angle = angle % FP_2PI;\n    }\n\n    // Determine quadrant\n    let quadrant = 0;\n    if (angle >= FP_PI) {\n        angle -= FP_PI;\n        quadrant = 2;\n    }\n    if (angle >= FP_HALF_PI) {\n        angle = FP_PI - angle;\n        quadrant += 1;\n    }\n\n    // Map angle to table index (0 to 256)\n    const indexFp = fpMul(angle, FP_ANGLE_TO_INDEX);\n    const index = indexFp >> FP_SHIFT;\n    const frac = indexFp & (FP_ONE - 1);\n\n    // Linear interpolation with safe bounds clamping\n    const clampedIndex = index < 0 ? 0 : (index > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : index);\n    const nextIndex = index + 1;\n    const clampedIndexNext = nextIndex < 0 ? 0 : (nextIndex > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : nextIndex);\n    const a = SIN_TABLE[clampedIndex] ?? 0;\n    const b = SIN_TABLE[clampedIndexNext] ?? FP_ONE;\n    let result = a + fpMul(b - a, frac);\n\n    // Apply quadrant sign\n    if (quadrant >= 2) result = -result;\n\n    return result;\n}\n\n/** Fixed-point cosine */\nexport function fpCos(angle: Fixed): Fixed {\n    return fpSin(angle + FP_HALF_PI);\n}\n\n/** Fixed-point atan2 using CORDIC-style approximation */\nexport function fpAtan2(y: Fixed, x: Fixed): Fixed {\n    if (x === 0 && y === 0) return 0;\n\n    const absX = fpAbs(x);\n    const absY = fpAbs(y);\n\n    // Use approximation: atan(y/x) = (PI/4) * (y/x) for |y/x| <= 1\n    let angle: Fixed;\n    if (absX >= absY) {\n        const ratio = fpDiv(absY, absX);\n        // atan approximation for small angles\n        angle = fpMul(ratio, 51472); // PI/4 * 65536 = 51472\n    } else {\n        const ratio = fpDiv(absX, absY);\n        angle = FP_HALF_PI - fpMul(ratio, 51472);\n    }\n\n    // Adjust for quadrant\n    if (x < 0) angle = FP_PI - angle;\n    if (y < 0) angle = -angle;\n\n    return angle;\n}\n", "/**\n * Fixed-Point Vector Types\n *\n * 2D and 3D vectors using fixed-point arithmetic for deterministic physics.\n */\n\nimport { Fixed, FP_ONE, toFixed, toFloat, fpMul, fpDiv, fpSqrt } from './fixed';\n\n// ============================================\n// 2D Vector (Fixed-Point)\n// ============================================\n\nexport interface Vec2 {\n    x: Fixed;\n    y: Fixed;\n}\n\nexport function vec2(x: number, y: number): Vec2 {\n    return { x: toFixed(x), y: toFixed(y) };\n}\n\nexport function vec2Zero(): Vec2 {\n    return { x: 0, y: 0 };\n}\n\nexport function vec2FromFixed(x: Fixed, y: Fixed): Vec2 {\n    return { x, y };\n}\n\nexport function vec2Clone(v: Vec2): Vec2 {\n    return { x: v.x, y: v.y };\n}\n\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\n    return { x: a.x + b.x, y: a.y + b.y };\n}\n\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\n\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\n}\n\nexport function vec2Neg(v: Vec2): Vec2 {\n    return { x: -v.x, y: -v.y };\n}\n\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\n    return fpMul(a.x, b.x) + fpMul(a.y, b.y);\n}\n\n/** 2D cross product (returns z component of 3D cross) */\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\n    return fpMul(a.x, b.y) - fpMul(a.y, b.x);\n}\n\nexport function vec2LengthSq(v: Vec2): Fixed {\n    return fpMul(v.x, v.x) + fpMul(v.y, v.y);\n}\n\nexport function vec2Length(v: Vec2): Fixed {\n    return fpSqrt(vec2LengthSq(v));\n}\n\nexport function vec2Normalize(v: Vec2): Vec2 {\n    const len = vec2Length(v);\n    if (len === 0) return vec2Zero();\n    return { x: fpDiv(v.x, len), y: fpDiv(v.y, len) };\n}\n\nexport function vec2Lerp(a: Vec2, b: Vec2, t: Fixed): Vec2 {\n    const oneMinusT = FP_ONE - t;\n    return {\n        x: fpMul(a.x, oneMinusT) + fpMul(b.x, t),\n        y: fpMul(a.y, oneMinusT) + fpMul(b.y, t)\n    };\n}\n\nexport function vec2Distance(a: Vec2, b: Vec2): Fixed {\n    return vec2Length(vec2Sub(b, a));\n}\n\nexport function vec2DistanceSq(a: Vec2, b: Vec2): Fixed {\n    return vec2LengthSq(vec2Sub(b, a));\n}\n\n// ============================================\n// 3D Vector (Fixed-Point)\n// ============================================\n\nexport interface Vec3 {\n    x: Fixed;\n    y: Fixed;\n    z: Fixed;\n}\n\nexport function vec3(x: Fixed, y: Fixed, z: Fixed): Vec3 {\n    return { x, y, z };\n}\n\nexport function vec3Zero(): Vec3 {\n    return { x: 0, y: 0, z: 0 };\n}\n\nexport function vec3FromFloats(x: number, y: number, z: number): Vec3 {\n    return { x: toFixed(x), y: toFixed(y), z: toFixed(z) };\n}\n\nexport function vec3ToFloats(v: Vec3): { x: number; y: number; z: number } {\n    return { x: toFloat(v.x), y: toFloat(v.y), z: toFloat(v.z) };\n}\n\nexport function vec3Clone(v: Vec3): Vec3 {\n    return { x: v.x, y: v.y, z: v.z };\n}\n\nexport function vec3Add(a: Vec3, b: Vec3): Vec3 {\n    return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\n}\n\nexport function vec3Sub(a: Vec3, b: Vec3): Vec3 {\n    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\n}\n\nexport function vec3Scale(v: Vec3, s: Fixed): Vec3 {\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s), z: fpMul(v.z, s) };\n}\n\nexport function vec3Neg(v: Vec3): Vec3 {\n    return { x: -v.x, y: -v.y, z: -v.z };\n}\n\nexport function vec3Dot(a: Vec3, b: Vec3): Fixed {\n    return fpMul(a.x, b.x) + fpMul(a.y, b.y) + fpMul(a.z, b.z);\n}\n\nexport function vec3Cross(a: Vec3, b: Vec3): Vec3 {\n    return {\n        x: fpMul(a.y, b.z) - fpMul(a.z, b.y),\n        y: fpMul(a.z, b.x) - fpMul(a.x, b.z),\n        z: fpMul(a.x, b.y) - fpMul(a.y, b.x)\n    };\n}\n\nexport function vec3LengthSq(v: Vec3): Fixed {\n    return fpMul(v.x, v.x) + fpMul(v.y, v.y) + fpMul(v.z, v.z);\n}\n\nexport function vec3Length(v: Vec3): Fixed {\n    return fpSqrt(vec3LengthSq(v));\n}\n\nexport function vec3Normalize(v: Vec3): Vec3 {\n    const len = vec3Length(v);\n    if (len === 0) return vec3Zero();\n    return { x: fpDiv(v.x, len), y: fpDiv(v.y, len), z: fpDiv(v.z, len) };\n}\n\nexport function vec3Lerp(a: Vec3, b: Vec3, t: Fixed): Vec3 {\n    const oneMinusT = FP_ONE - t;\n    return {\n        x: fpMul(a.x, oneMinusT) + fpMul(b.x, t),\n        y: fpMul(a.y, oneMinusT) + fpMul(b.y, t),\n        z: fpMul(a.z, oneMinusT) + fpMul(b.z, t)\n    };\n}\n\nexport function vec3Distance(a: Vec3, b: Vec3): Fixed {\n    return vec3Length(vec3Sub(b, a));\n}\n\nexport function vec3DistanceSq(a: Vec3, b: Vec3): Fixed {\n    return vec3LengthSq(vec3Sub(b, a));\n}\n", "/**\n * Fixed-Point Quaternion Operations\n *\n * Quaternion math for 3D rotations using fixed-point arithmetic.\n */\n\nimport { Fixed, FP_ONE, fpMul, fpDiv, fpSqrt, fpSin, fpCos } from './fixed';\nimport { Vec3, vec3, vec3Normalize, vec3Cross, vec3Add, vec3Scale } from './vec';\n\n// ============================================\n// Quaternion (Fixed-Point)\n// ============================================\n\nexport interface Quat {\n    x: Fixed;\n    y: Fixed;\n    z: Fixed;\n    w: Fixed;\n}\n\nexport function quatIdentity(): Quat {\n    return { x: 0, y: 0, z: 0, w: FP_ONE };\n}\n\nexport function quatFromAxisAngle(axis: Vec3, angle: Fixed): Quat {\n    const halfAngle = angle >> 1;\n    const s = fpSin(halfAngle);\n    const c = fpCos(halfAngle);\n    const normAxis = vec3Normalize(axis);\n    return {\n        x: fpMul(normAxis.x, s),\n        y: fpMul(normAxis.y, s),\n        z: fpMul(normAxis.z, s),\n        w: c\n    };\n}\n\nexport function quatFromEulerY(yaw: Fixed): Quat {\n    const halfAngle = yaw >> 1;\n    return {\n        x: 0,\n        y: fpSin(halfAngle),\n        z: 0,\n        w: fpCos(halfAngle)\n    };\n}\n\nexport function quatMul(a: Quat, b: Quat): Quat {\n    return {\n        x: fpMul(a.w, b.x) + fpMul(a.x, b.w) + fpMul(a.y, b.z) - fpMul(a.z, b.y),\n        y: fpMul(a.w, b.y) - fpMul(a.x, b.z) + fpMul(a.y, b.w) + fpMul(a.z, b.x),\n        z: fpMul(a.w, b.z) + fpMul(a.x, b.y) - fpMul(a.y, b.x) + fpMul(a.z, b.w),\n        w: fpMul(a.w, b.w) - fpMul(a.x, b.x) - fpMul(a.y, b.y) - fpMul(a.z, b.z)\n    };\n}\n\nexport function quatRotateVec3(q: Quat, v: Vec3): Vec3 {\n    // q * v * q^-1 (optimized)\n    const qv = vec3(q.x, q.y, q.z);\n    const uv = vec3Cross(qv, v);\n    const uuv = vec3Cross(qv, uv);\n    return vec3Add(v, vec3Add(vec3Scale(uv, q.w << 1), vec3Scale(uuv, FP_ONE << 1)));\n}\n\nexport function quatNormalize(q: Quat): Quat {\n    const lenSq = fpMul(q.x, q.x) + fpMul(q.y, q.y) + fpMul(q.z, q.z) + fpMul(q.w, q.w);\n    const len = fpSqrt(lenSq);\n    if (len === 0) return quatIdentity();\n    return {\n        x: fpDiv(q.x, len),\n        y: fpDiv(q.y, len),\n        z: fpDiv(q.z, len),\n        w: fpDiv(q.w, len)\n    };\n}\n\n/** Quaternion conjugate (inverse for unit quaternions) */\nexport function quatConjugate(q: Quat): Quat {\n    return { x: -q.x as Fixed, y: -q.y as Fixed, z: -q.z as Fixed, w: q.w };\n}\n\n/** Clone a quaternion */\nexport function quatClone(q: Quat): Quat {\n    return { x: q.x, y: q.y, z: q.z, w: q.w };\n}\n", "/**\n * Deterministic Random\n *\n * Simple, deterministic random function. Same seed = same sequence.\n * Automatically overrides Math.random() on import for full determinism.\n */\n\n// ============================================\n// Internal State\n// ============================================\n\nlet s0 = 1;\nlet s1 = 2;\n\n// ============================================\n// Core Random Function\n// ============================================\n\nfunction next(): number {\n    let x = s0;\n    const y = s1;\n    s0 = y;\n    x ^= (x << 23) >>> 0;\n    x ^= x >>> 17;\n    x ^= y;\n    x ^= y >>> 26;\n    s1 = x >>> 0;\n    return (s0 + s1) >>> 0;\n}\n\n// ============================================\n// Public API\n// ============================================\n\n/**\n * Set the random seed (internal use).\n */\nfunction setSeed(seed: number): void {\n    seed = seed >>> 0;\n    if (seed === 0) seed = 1;\n\n    // Mix the seed into two state values\n    let s = seed;\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\n    s0 = ((s >>> 16) ^ s) >>> 0;\n\n    s = (seed * 0x9e3779b9) >>> 0;\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\n    s1 = ((s >>> 16) ^ s) >>> 0;\n\n    if (s0 === 0 && s1 === 0) s0 = 1;\n}\n\n/**\n * Get random float between 0 (inclusive) and 1 (exclusive).\n * Works like Math.random() but deterministic.\n */\nexport function dRandom(): number {\n    return next() / 0x100000000;\n}\n\n// ============================================\n// State Save/Load (for rollback)\n// ============================================\n\nexport interface RandomState {\n    s0: number;\n    s1: number;\n}\n\nexport function saveRandomState(): RandomState {\n    return { s0, s1 };\n}\n\nexport function loadRandomState(state: RandomState): void {\n    s0 = state.s0;\n    s1 = state.s1;\n}\n\n// Initialize with default seed\nsetSeed(1);\n", "/**\n * ECS Constants\n *\n * Core constants for the Entity-Component-System architecture.\n */\n\n/**\n * Maximum number of concurrent entities.\n *\n * This is a hard limit due to TypedArray storage. Exceeding this will\n * throw an error. For most games, 10,000 is far more than needed.\n *\n * Memory usage per component field: MAX_ENTITIES \u00D7 4 bytes = 40 KB\n * With 10 components \u00D7 5 fields average = 2 MB total\n */\nexport const MAX_ENTITIES = 10_000;\n\n/**\n * Entity ID format: [12 bits generation][20 bits index]\n * - Generation: Prevents ABA problem when IDs are recycled\n * - Index: Direct array index for O(1) component access\n */\nexport const GENERATION_BITS = 12;\nexport const INDEX_BITS = 20;\nexport const INDEX_MASK = (1 << INDEX_BITS) - 1;\nexport const MAX_GENERATION = (1 << GENERATION_BITS) - 1;\n\n/**\n * System execution phases (in order)\n */\nexport const SYSTEM_PHASES = [\n    'input',\n    'update',\n    'prePhysics',\n    'physics',\n    'postPhysics',\n    'render'\n] as const;\n\nexport type SystemPhase = typeof SYSTEM_PHASES[number];\n", "/**\n * Component System\n *\n * Components are pure data containers. This module handles:\n * - Component type definitions with schemas\n * - Type inference from default values\n * - SoA (Structure of Arrays) storage allocation\n * - Pre-generated accessor class creation\n */\n\nimport { MAX_ENTITIES } from './constants';\nimport { toFixed, toFloat } from '../math';\n\n/**\n * Supported field types for components.\n * - i32: 32-bit integer (default for numbers, uses fixed-point for physics)\n * - u8: 8-bit unsigned (for flags, enums)\n * - bool: boolean (stored as u8)\n * - f32: 32-bit float (ONLY for render-only data, NON-DETERMINISTIC)\n */\nexport type FieldType = 'i32' | 'u8' | 'bool' | 'f32';\n\nexport interface FieldDefinition {\n    type: FieldType;\n    default: number | boolean;\n}\n\nexport interface ComponentSchema {\n    [fieldName: string]: FieldDefinition;\n}\n\n/**\n * Component storage using Structure of Arrays (SoA) pattern.\n * Each field is stored in a separate TypedArray for cache efficiency.\n */\nexport interface ComponentStorage {\n    /** Bitmask tracking which entities have this component */\n    mask: Uint32Array;\n\n    /** Field arrays indexed by entity index */\n    fields: Record<string, Int32Array | Uint8Array | Float32Array>;\n\n    /** Schema defining field types */\n    schema: ComponentSchema;\n}\n\n/**\n * Options for defining a component.\n */\nexport interface ComponentOptions {\n    /**\n     * Whether this component should be synchronized across the network.\n     * When false, the component is excluded from:\n     * - Network snapshots (not sent to other clients)\n     * - State hash computation (doesn't affect determinism checks)\n     * - Rollback state (not saved/restored during rollback)\n     *\n     * Use sync: false for client-only state like cameras, UI, local effects.\n     * @default true\n     */\n    sync?: boolean;\n}\n\n/**\n * Component type definition.\n */\nexport interface ComponentType<T extends Record<string, any> = any> {\n    readonly name: string;\n    readonly schema: ComponentSchema;\n    readonly storage: ComponentStorage;\n    readonly AccessorClass: new (index: number) => T;\n    readonly fieldNames: string[];\n    /** Whether this component is synchronized across network. Default: true */\n    readonly sync: boolean;\n}\n\n/**\n * Infer field definition from a default value.\n * ALL numbers default to i32 for determinism.\n * f32 requires explicit declaration and logs a warning.\n */\nexport function inferFieldDef(value: any): FieldDefinition {\n    // Explicit type definition\n    if (typeof value === 'object' && value !== null && 'type' in value) {\n        const def = value as { type: FieldType; default?: number | boolean };\n\n        if (def.type === 'f32') {\n            console.warn(\n                `Component field uses f32 which is NON-DETERMINISTIC. ` +\n                `Only use for render-only data, never for synced state.`\n            );\n        }\n\n        return {\n            type: def.type,\n            default: def.default ?? (def.type === 'bool' ? false : 0)\n        };\n    }\n\n    // Boolean inference\n    if (typeof value === 'boolean') {\n        return { type: 'bool', default: value };\n    }\n\n    // Number inference - ALL default to i32 for determinism\n    if (typeof value === 'number') {\n        return { type: 'i32', default: value };\n    }\n\n    // Null/undefined treated as i32 with 0 default\n    if (value === null || value === undefined) {\n        return { type: 'i32', default: 0 };\n    }\n\n    throw new Error(\n        `Unsupported field type: ${typeof value}. ` +\n        `Components can only contain numbers and booleans. ` +\n        `Use game.internString() for string values.`\n    );\n}\n\n/**\n * Create TypedArray for a field type.\n */\nfunction createFieldArray(type: FieldType): Int32Array | Uint8Array | Float32Array {\n    switch (type) {\n        case 'i32':\n            return new Int32Array(MAX_ENTITIES);\n        case 'u8':\n        case 'bool':\n            return new Uint8Array(MAX_ENTITIES);\n        case 'f32':\n            return new Float32Array(MAX_ENTITIES);\n        default:\n            throw new Error(`Unknown field type: ${type}`);\n    }\n}\n\n/**\n * Create SoA storage for a component schema.\n */\nexport function createComponentStorage(schema: ComponentSchema): ComponentStorage {\n    const fields: Record<string, Int32Array | Uint8Array | Float32Array> = {};\n\n    for (const [name, def] of Object.entries(schema)) {\n        fields[name] = createFieldArray(def.type);\n    }\n\n    return {\n        mask: new Uint32Array(Math.ceil(MAX_ENTITIES / 32)),\n        fields,\n        schema\n    };\n}\n\n/**\n * Generate an accessor class for a component type.\n * Uses Object.defineProperty for optimal V8 performance (not Proxy).\n */\nexport function generateAccessorClass<T>(\n    name: string,\n    schema: ComponentSchema,\n    storage: ComponentStorage\n): new (index: number) => T {\n    // Create a class dynamically\n    const AccessorClass = function(this: any, index: number) {\n        this._index = index;\n    } as any;\n\n    AccessorClass.prototype = {};\n\n    // Add getter/setter for each field\n    for (const [fieldName, fieldDef] of Object.entries(schema)) {\n        const fieldArray = storage.fields[fieldName];\n        const isFixedPoint = fieldDef.type === 'i32';\n        const isBool = fieldDef.type === 'bool';\n\n        Object.defineProperty(AccessorClass.prototype, fieldName, {\n            get: function(this: { _index: number }) {\n                const value = fieldArray[this._index];\n                if (isBool) return value !== 0;\n                if (isFixedPoint) return toFloat(value as number);\n                return value;\n            },\n            set: function(this: { _index: number }, value: any) {\n                if (isBool) {\n                    fieldArray[this._index] = value ? 1 : 0;\n                } else if (isFixedPoint) {\n                    fieldArray[this._index] = toFixed(value);\n                } else {\n                    fieldArray[this._index] = value;\n                }\n            },\n            enumerable: true,\n            configurable: false\n        });\n    }\n\n    // Add _index property definition\n    Object.defineProperty(AccessorClass.prototype, '_index', {\n        value: 0,\n        writable: true,\n        enumerable: false,\n        configurable: false\n    });\n\n    return AccessorClass as new (index: number) => T;\n}\n\n/**\n * Component registry - stores all defined components.\n */\nconst componentRegistry = new Map<string, ComponentType>();\n\n/**\n * Define a new component type.\n *\n * @param name Unique component name\n * @param defaults Default values (type inferred from values)\n * @param options Optional configuration (sync, etc.)\n * @returns ComponentType for use in entity definitions\n *\n * @example\n * const Health = defineComponent('health', { current: 100, max: 100 });\n * const Position = defineComponent('position', { x: 0, y: 0 });\n *\n * // Client-only component (not synced)\n * const Camera2D = defineComponent('camera2d', { zoom: 1, targetZoom: 1 }, { sync: false });\n */\nexport function defineComponent<T extends Record<string, any>>(\n    name: string,\n    defaults: T,\n    options?: ComponentOptions\n): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\n    if (componentRegistry.has(name)) {\n        throw new Error(`Component '${name}' is already defined`);\n    }\n\n    // Build schema from defaults\n    const schema: ComponentSchema = {};\n    for (const [fieldName, defaultValue] of Object.entries(defaults)) {\n        schema[fieldName] = inferFieldDef(defaultValue);\n    }\n\n    // Create storage\n    const storage = createComponentStorage(schema);\n\n    // Generate accessor class\n    const AccessorClass = generateAccessorClass<any>(name, schema, storage);\n\n    const componentType: ComponentType = {\n        name,\n        schema,\n        storage,\n        AccessorClass,\n        fieldNames: Object.keys(schema),\n        sync: options?.sync !== false // Default to true\n    };\n\n    componentRegistry.set(name, componentType);\n\n    return componentType as any;\n}\n\n/**\n * Get a component type by name.\n */\nexport function getComponentType(name: string): ComponentType | undefined {\n    return componentRegistry.get(name);\n}\n\n/**\n * Check if entity has component (via bitmask).\n */\nexport function hasComponent(storage: ComponentStorage, index: number): boolean {\n    const word = index >>> 5;\n    const bit = 1 << (index & 31);\n    return (storage.mask[word] & bit) !== 0;\n}\n\n/**\n * Add component to entity (set bit in mask).\n */\nexport function addComponentToEntity(storage: ComponentStorage, index: number): void {\n    const word = index >>> 5;\n    const bit = 1 << (index & 31);\n    storage.mask[word] |= bit;\n}\n\n/**\n * Remove component from entity (clear bit in mask).\n */\nexport function removeComponentFromEntity(storage: ComponentStorage, index: number): void {\n    const word = index >>> 5;\n    const bit = 1 << (index & 31);\n    storage.mask[word] &= ~bit;\n}\n\n/**\n * Initialize component fields to defaults for an entity.\n */\nexport function initializeComponentDefaults(storage: ComponentStorage, index: number): void {\n    for (const [fieldName, fieldDef] of Object.entries(storage.schema)) {\n        const arr = storage.fields[fieldName];\n        if (fieldDef.type === 'i32') {\n            arr[index] = toFixed(fieldDef.default as number);\n        } else if (fieldDef.type === 'bool') {\n            arr[index] = fieldDef.default ? 1 : 0;\n        } else {\n            arr[index] = fieldDef.default as number;\n        }\n    }\n}\n\n/**\n * Clear all component registrations (for testing).\n */\nexport function clearComponentRegistry(): void {\n    componentRegistry.clear();\n}\n\n/**\n * Get all registered components.\n */\nexport function getAllComponents(): Map<string, ComponentType> {\n    return componentRegistry;\n}\n", "/**\n * Entity ID Allocator\n *\n * Manages entity ID allocation with generation counters for ABA safety.\n * Entity ID format: [12 bits generation][20 bits index]\n */\n\nimport {\n    MAX_ENTITIES,\n    INDEX_MASK,\n    INDEX_BITS,\n    MAX_GENERATION,\n    GENERATION_BITS\n} from './constants';\n\nexport interface EntityIdAllocatorState {\n    nextIndex: number;\n    freeList: number[];\n    generations: number[];\n}\n\nexport class EntityIdAllocator {\n    /** Generation counter for each entity slot */\n    private generations: Uint16Array;\n\n    /** Free list of available indices (sorted ascending for determinism) */\n    private freeList: number[] = [];\n\n    /** Next index to allocate if free list is empty */\n    private nextIndex: number = 0;\n\n    constructor() {\n        this.generations = new Uint16Array(MAX_ENTITIES);\n    }\n\n    /**\n     * Allocate a new entity ID.\n     * Returns entity ID with generation encoded.\n     */\n    allocate(): number {\n        let index: number;\n\n        if (this.freeList.length > 0) {\n            // Always take the LOWEST available index for determinism\n            index = this.freeList.shift()!;\n        } else {\n            if (this.nextIndex >= MAX_ENTITIES) {\n                throw new Error(\n                    `Entity limit exceeded (MAX_ENTITIES=${MAX_ENTITIES}). ` +\n                    `Consider destroying unused entities or increasing the limit.`\n                );\n            }\n            index = this.nextIndex++;\n        }\n\n        const generation = this.generations[index];\n        return (generation << INDEX_BITS) | index;\n    }\n\n    /**\n     * Free an entity ID, returning it to the pool.\n     * Increments generation to invalidate stale references.\n     */\n    free(eid: number): void {\n        const index = eid & INDEX_MASK;\n\n        // Increment generation (wrap at max)\n        this.generations[index] = ((this.generations[index] + 1) & MAX_GENERATION) as number;\n\n        // Binary search insert to maintain sorted order (deterministic)\n        const insertIdx = this.findInsertIndex(index);\n        this.freeList.splice(insertIdx, 0, index);\n    }\n\n    /**\n     * Check if an entity ID is still valid (generation matches).\n     */\n    isValid(eid: number): boolean {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n        return index < this.nextIndex && this.generations[index] === generation;\n    }\n\n    /**\n     * Get the index portion of an entity ID.\n     */\n    getIndex(eid: number): number {\n        return eid & INDEX_MASK;\n    }\n\n    /**\n     * Get the generation portion of an entity ID.\n     */\n    getGeneration(eid: number): number {\n        return eid >>> INDEX_BITS;\n    }\n\n    /**\n     * Get current state for snapshotting.\n     */\n    getState(): EntityIdAllocatorState {\n        return {\n            nextIndex: this.nextIndex,\n            freeList: [...this.freeList],\n            generations: Array.from(this.generations.slice(0, this.nextIndex))\n        };\n    }\n\n    /**\n     * Restore state from snapshot.\n     */\n    setState(state: EntityIdAllocatorState): void {\n        this.nextIndex = state.nextIndex;\n        this.freeList = [...state.freeList];\n\n        // Restore generations\n        for (let i = 0; i < state.generations.length; i++) {\n            this.generations[i] = state.generations[i];\n        }\n    }\n\n    /**\n     * Reset allocator to initial state.\n     */\n    reset(): void {\n        this.nextIndex = 0;\n        this.freeList = [];\n        this.generations.fill(0);\n    }\n\n    /**\n     * Get number of active entities.\n     */\n    getActiveCount(): number {\n        return this.nextIndex - this.freeList.length;\n    }\n\n    /**\n     * Binary search to find insert position for sorted free list.\n     */\n    /**\n     * Get next ID that will be allocated (for snapshots).\n     */\n    getNextId(): number {\n        return this.nextIndex;\n    }\n\n    /**\n     * Set next ID (for snapshot restore).\n     */\n    setNextId(id: number): void {\n        this.nextIndex = id;\n    }\n\n    /**\n     * Allocate a specific entity ID (for snapshot restore).\n     * This bypasses normal allocation and marks the specific eid as used.\n     * Returns the requested eid.\n     */\n    allocateSpecific(eid: number): number {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n\n        // Extend nextIndex if needed\n        if (index >= this.nextIndex) {\n            this.nextIndex = index + 1;\n        }\n\n        // Remove from free list if present\n        const freeIdx = this.freeList.indexOf(index);\n        if (freeIdx !== -1) {\n            this.freeList.splice(freeIdx, 1);\n        }\n\n        // Set the generation\n        this.generations[index] = generation;\n\n        return eid;\n    }\n\n    private findInsertIndex(index: number): number {\n        let lo = 0;\n        let hi = this.freeList.length;\n\n        while (lo < hi) {\n            const mid = (lo + hi) >>> 1;\n            if (this.freeList[mid] < index) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n}\n", "/**\n * Standard ECS Components\n *\n * Built-in components for common game functionality.\n * All numeric values use fixed-point (i32) for determinism.\n */\n\nimport { defineComponent, ComponentType } from '../core/component';\n\n/**\n * Transform2D - Position and rotation.\n */\nexport const Transform2D = defineComponent('Transform2D', {\n    x: 0,\n    y: 0,\n    angle: 0\n});\n\n/**\n * Body2D - Physics body properties.\n */\nexport const Body2D = defineComponent('Body2D', {\n    // Velocity\n    vx: 0,\n    vy: 0,\n\n    // Angular velocity\n    angularVelocity: 0,\n\n    // Force accumulator (added to velocity each frame, then cleared)\n    forceX: 0,\n    forceY: 0,\n\n    // Impulse accumulator (added to velocity once, then cleared)\n    impulseX: 0,\n    impulseY: 0,\n\n    // Size (use width/height OR radius)\n    width: 0,\n    height: 0,\n    radius: 0,\n\n    // Physics properties\n    mass: 1,\n    restitution: 0,    // Bounciness (0-1)\n    friction: 0,\n\n    // Body type: 0=dynamic, 1=static, 2=kinematic\n    bodyType: 0,\n\n    // Shape type: 0=rect, 1=circle\n    shapeType: 1,\n\n    // Is sensor (no collision response, just events)\n    damping: 0,\n    isSensor: false\n});\n\n/**\n * Player - Marks an entity as player-controlled.\n * This is the ownership component - attach to any entity a player controls.\n * clientId is stored as interned string ID (integer).\n */\nexport const Player = defineComponent('Player', {\n    clientId: 0    // Interned clientId string\n});\n\n/**\n * Sprite - Visual rendering component.\n *\n * Can render either:\n * - Simple shapes (circle, rect) with color\n * - Image sprites (via spriteId)\n */\nexport const Sprite = defineComponent('Sprite', {\n    // Shape type: 0=rect, 1=circle, 2=image\n    shape: 1,  // Default circle\n\n    // Size (for shapes)\n    width: 0,\n    height: 0,\n    radius: 10,\n\n    // Color (interned string ID, e.g., '#ff0000')\n    color: 0,\n\n    // Image sprite ID (interned string, for shape=SPRITE_IMAGE)\n    spriteId: 0,\n\n    // Render offset from transform position\n    offsetX: 0,\n    offsetY: 0,\n\n    // Scale\n    scaleX: 1,\n    scaleY: 1,\n\n    // Layer for z-ordering (higher = in front)\n    layer: 0,\n\n    // Visibility\n    visible: true\n});\n\n// Sprite shape constants (reuse SHAPE_RECT, SHAPE_CIRCLE, add SPRITE_IMAGE)\nexport const SPRITE_IMAGE = 2;\n\n/**\n * Camera2D - 2D camera for viewport control.\n *\n * This is a client-only component (sync: false) - each client manages\n * their own camera independently. The camera is not included in:\n * - Network snapshots\n * - State hash computation\n * - Rollback state\n *\n * @example\n * // Define camera entity\n * game.defineEntity('camera')\n *     .with(Camera2D)\n *     .register();\n *\n * // Spawn and use camera\n * const cam = game.spawn('camera');\n * const camera = cam.get(Camera2D);\n * camera.x = player.x;\n * camera.y = player.y;\n * camera.zoom = 1.5;\n */\nexport const Camera2D = defineComponent('Camera2D', {\n    // Position (world coordinates the camera is centered on)\n    x: 0,\n    y: 0,\n\n    // Zoom level (1 = normal, >1 = zoomed in, <1 = zoomed out)\n    zoom: 1,\n\n    // Target zoom for smooth transitions\n    targetZoom: 1,\n\n    // Smoothing factor for position interpolation (0-1, higher = snappier)\n    smoothing: 0.1,\n\n    // Optional: follow entity ID (0 = no target)\n    followEntity: 0,\n\n    // Viewport bounds (set by renderer)\n    viewportWidth: 0,\n    viewportHeight: 0\n}, { sync: false });\n\n// Re-export types for convenience\nexport type Transform2DData = {\n    x: number;\n    y: number;\n    angle: number;\n};\n\nexport type Body2DData = {\n    vx: number;\n    vy: number;\n    angularVelocity: number;\n    forceX: number;\n    forceY: number;\n    impulseX: number;\n    impulseY: number;\n    width: number;\n    height: number;\n    radius: number;\n    mass: number;\n    restitution: number;\n    friction: number;\n    bodyType: number;\n    shapeType: number;\n    isSensor: boolean;\n};\n\nexport type PlayerType = {\n    clientId: number;\n};\n\n// Body type constants\nexport const BODY_DYNAMIC = 0;\nexport const BODY_STATIC = 1;\nexport const BODY_KINEMATIC = 2;\n\n// Shape type constants\nexport const SHAPE_RECT = 0;\nexport const SHAPE_CIRCLE = 1;\n\nexport type Camera2DData = {\n    x: number;\n    y: number;\n    zoom: number;\n    targetZoom: number;\n    smoothing: number;\n    followEntity: number;\n    viewportWidth: number;\n    viewportHeight: number;\n};\n", "/**\n * Entity Wrapper\n *\n * Provides an ergonomic API for entity access while using SoA storage internally.\n * Entity wrappers are pooled and reused to minimize allocations.\n */\n\nimport {\n    ComponentType,\n    hasComponent,\n    addComponentToEntity,\n    removeComponentFromEntity,\n    initializeComponentDefaults\n} from './component';\nimport { INDEX_MASK } from './constants';\nimport { toFixed, toFloat, fpMul, fpDiv, fpSqrt, FP_ONE } from '../math';\nimport { Transform2D, Body2D } from '../components';\n\n/**\n * Render-only state (client-only, never serialized).\n */\nexport interface RenderState {\n    /** Previous tick X position (for interpolation) */\n    prevX: number;\n    /** Previous tick Y position */\n    prevY: number;\n    /** Interpolated X (computed each render) */\n    interpX: number;\n    /** Interpolated Y */\n    interpY: number;\n    /** Screen X after camera transform */\n    screenX: number;\n    /** Screen Y after camera transform */\n    screenY: number;\n    /** Whether entity is visible */\n    visible: boolean;\n    /** Custom render properties */\n    [key: string]: any;\n}\n\n/**\n * Restore callback type - called after snapshot load to reconstruct derived fields.\n */\nexport type EntityRestoreCallback = (entity: Entity, game: any) => void;\n\n/**\n * Entity definition for spawning.\n */\nexport interface EntityDefinition {\n    name: string;\n    components: Array<{\n        type: ComponentType;\n        defaults?: Record<string, any>;\n    }>;\n    /** Optional: fields to sync in snapshots. If not set, all fields are synced. */\n    syncFields?: string[];\n    /** Optional: callback to reconstruct non-synced fields after snapshot load. */\n    onRestore?: EntityRestoreCallback;\n}\n\n/**\n * Entity wrapper - provides ergonomic access to SoA-stored entity data.\n */\nexport class Entity {\n    /** Entity ID (includes generation) */\n    eid: number = -1;\n\n    /** Entity type name */\n    type: string = '';\n\n    /** Whether entity is destroyed */\n    destroyed: boolean = false;\n\n    /** Render-only state (client-only, never serialized) */\n    render: RenderState = {\n        prevX: 0,\n        prevY: 0,\n        interpX: 0,\n        interpY: 0,\n        screenX: 0,\n        screenY: 0,\n        visible: true\n    };\n\n    /** Component types this entity has */\n    private _components: ComponentType[] = [];\n\n    /** Cached accessor instances */\n    private _accessors: Map<ComponentType, any> = new Map();\n\n    /** Reference to world for operations */\n    private _world: EntityWorld | null = null;\n\n    /** Current frame's input data (set during tick) */\n    private _inputData: Record<string, any> | null = null;\n\n    /**\n     * Get component accessor.\n     * Returns typed accessor for reading/writing component data.\n     */\n    get<T extends Record<string, any>>(component: ComponentType<T>): T {\n        const index = this.eid & INDEX_MASK;\n\n        // Check if entity has this component\n        if (!hasComponent(component.storage, index)) {\n            throw new Error(\n                `Entity ${this.eid} (type: ${this.type}) does not have component '${component.name}'`\n            );\n        }\n\n        // Get or create accessor\n        let accessor = this._accessors.get(component);\n        if (!accessor) {\n            accessor = new component.AccessorClass(index);\n            this._accessors.set(component, accessor);\n        } else {\n            // Update index in case wrapper was reused\n            accessor._index = index;\n        }\n\n        return accessor;\n    }\n\n    /**\n     * Check if entity has a component.\n     */\n    has(component: ComponentType): boolean {\n        return hasComponent(component.storage, this.eid & INDEX_MASK);\n    }\n\n    /**\n     * Add a component to this entity at runtime.\n     */\n    addComponent<T extends Record<string, any>>(component: ComponentType<T>, data?: Partial<T>): T {\n        const index = this.eid & INDEX_MASK;\n\n        if (hasComponent(component.storage, index)) {\n            throw new Error(\n                `Entity ${this.eid} already has component '${component.name}'`\n            );\n        }\n\n        // Add to storage\n        addComponentToEntity(component.storage, index);\n        initializeComponentDefaults(component.storage, index);\n\n        // Track component\n        this._components.push(component);\n\n        // Update query indices\n        if (this._world) {\n            this._world.queryEngine.addComponent(this.eid, component);\n        }\n\n        // Get accessor and apply data\n        const accessor = this.get(component);\n        if (data) {\n            for (const [key, value] of Object.entries(data)) {\n                (accessor as any)[key] = value;\n            }\n        }\n\n        return accessor;\n    }\n\n    /**\n     * Remove a component from this entity at runtime.\n     */\n    removeComponent(component: ComponentType): void {\n        const index = this.eid & INDEX_MASK;\n\n        if (!hasComponent(component.storage, index)) {\n            throw new Error(\n                `Entity ${this.eid} does not have component '${component.name}'`\n            );\n        }\n\n        // Remove from storage\n        removeComponentFromEntity(component.storage, index);\n\n        // Remove from tracking\n        const idx = this._components.indexOf(component);\n        if (idx !== -1) {\n            this._components.splice(idx, 1);\n        }\n\n        // Update query indices\n        if (this._world) {\n            this._world.queryEngine.removeComponent(this.eid, component);\n        }\n\n        // Clear cached accessor\n        this._accessors.delete(component);\n    }\n\n    /**\n     * Destroy this entity.\n     */\n    destroy(): void {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        if (this._world) {\n            this._world.destroyEntity(this);\n        }\n    }\n\n    /**\n     * Get all components on this entity.\n     */\n    getComponents(): ComponentType[] {\n        return [...this._components];\n    }\n\n    /**\n     * Get current frame's input data.\n     * Returns null if no input was received this tick.\n     */\n    get input(): Record<string, any> | null {\n        return this._inputData;\n    }\n\n    /**\n     * Set input data for this tick (called by World).\n     */\n    _setInputData(data: Record<string, any> | null): void {\n        this._inputData = data;\n    }\n\n    /**\n     * Save current position to render.prev* for interpolation.\n     * Should be called in prePhysics phase before physics updates position.\n     */\n    _savePreviousState(): void {\n        // Look for common position components (Body2D, Transform, etc.)\n        // Store current position as previous for interpolation\n        for (const component of this._components) {\n            const index = this.eid & INDEX_MASK;\n\n            // Check for x/y fields in component\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\n                const xArr = component.storage.fields['x'];\n                const yArr = component.storage.fields['y'];\n\n                // Convert from fixed-point to float for render state\n                this.render.prevX = toFloat(xArr[index]);\n                this.render.prevY = toFloat(yArr[index]);\n                return; // Found position component, done\n            }\n        }\n    }\n\n    /**\n     * Calculate interpolated position for rendering.\n     * @param alpha Interpolation factor (0-1) between previous and current state\n     */\n    interpolate(alpha: number): void {\n        // Get current position\n        for (const component of this._components) {\n            const index = this.eid & INDEX_MASK;\n\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\n                const currentX = toFloat(component.storage.fields['x'][index]);\n                const currentY = toFloat(component.storage.fields['y'][index]);\n\n                // Linear interpolation between previous and current\n                this.render.interpX = this.render.prevX + (currentX - this.render.prevX) * alpha;\n                this.render.interpY = this.render.prevY + (currentY - this.render.prevY) * alpha;\n                return;\n            }\n        }\n    }\n\n    /**\n     * Initialize entity (called by world).\n     */\n    _init(\n        eid: number,\n        type: string,\n        components: ComponentType[],\n        world: EntityWorld\n    ): void {\n        this.eid = eid;\n        this.type = type;\n        this.destroyed = false;\n        this._components = components;\n        this._world = world;\n        this._accessors.clear();\n\n        // Reset render state\n        this.render.prevX = 0;\n        this.render.prevY = 0;\n        this.render.interpX = 0;\n        this.render.interpY = 0;\n        this.render.screenX = 0;\n        this.render.screenY = 0;\n        this.render.visible = true;\n\n        // Clear input data\n        this._inputData = null;\n    }\n\n    /**\n     * Clean up entity (called when returned to pool).\n     */\n    _cleanup(): void {\n        this._world = null;\n        this._components = [];\n        this._accessors.clear();\n        this._inputData = null;\n    }\n\n    // ==========================================\n    // Movement Helpers (Deterministic)\n    // ==========================================\n\n    /**\n     * Set velocity toward a target point.\n     * Uses fixed-point math internally for determinism.\n     *\n     * @param target Target position {x, y}\n     * @param speed Speed in units per second\n     */\n    moveTowards(target: { x: number; y: number }, speed: number): void {\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\n\n        const transform = this.get(Transform2D);\n        const body = this.get(Body2D);\n\n        // All math in fixed-point for determinism\n        const dx = toFixed(target.x) - toFixed(transform.x);\n        const dy = toFixed(target.y) - toFixed(transform.y);\n\n        // Distance squared (avoid sqrt if possible)\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\n        if (distSq === 0) {\n            body.vx = 0;\n            body.vy = 0;\n            return;\n        }\n\n        // Distance\n        const dist = fpSqrt(distSq);\n\n        // Normalize and scale by speed (speed is in units/sec, physics expects units/sec)\n        const speedFp = toFixed(speed * 60); // Convert to units per tick at 60fps base\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\n    }\n\n\n    /**\n     * Move towards target, stopping when within stopRadius.\n     *\n     * @param target Target position {x, y}\n     * @param speed Speed in units per second\n     * @param stopRadius Radius within which to stop moving\n     */\n    moveTowardsWithStop(target: { x: number; y: number }, speed: number, stopRadius: number): void {\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\n\n        const transform = this.get(Transform2D);\n        const body = this.get(Body2D);\n\n        // All math in fixed-point for determinism\n        const dx = toFixed(target.x) - toFixed(transform.x);\n        const dy = toFixed(target.y) - toFixed(transform.y);\n\n        // Distance squared\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\n        const stopRadiusFp = toFixed(stopRadius);\n        const stopRadiusSq = fpMul(stopRadiusFp, stopRadiusFp);\n\n        // Stop if within stopRadius\n        if (distSq <= stopRadiusSq) {\n            body.vx = 0;\n            body.vy = 0;\n            return;\n        }\n\n        // Distance\n        const dist = fpSqrt(distSq);\n\n        // Normalize and scale by speed\n        const speedFp = toFixed(speed * 60);\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\n    }\n\n    /**\n     * Stop all movement.\n     */\n    stop(): void {\n        if (!this.has(Body2D)) return;\n        const body = this.get(Body2D);\n        body.vx = 0;\n        body.vy = 0;\n    }\n\n    /**\n     * Set velocity directly.\n     *\n     * @param vx X velocity\n     * @param vy Y velocity\n     */\n    setVelocity(vx: number, vy: number): void {\n        if (!this.has(Body2D)) return;\n        const body = this.get(Body2D);\n        body.vx = vx;\n        body.vy = vy;\n    }\n\n    /**\n     * Get distance to a point (deterministic).\n     */\n    distanceTo(target: { x: number; y: number }): number {\n        if (!this.has(Transform2D)) return 0;\n\n        const transform = this.get(Transform2D);\n        const dx = toFixed(target.x) - toFixed(transform.x);\n        const dy = toFixed(target.y) - toFixed(transform.y);\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\n\n        return toFloat(fpSqrt(distSq));\n    }\n\n    /**\n     * Check if within distance of a point (deterministic).\n     */\n    isWithin(target: { x: number; y: number }, distance: number): boolean {\n        if (!this.has(Transform2D)) return false;\n\n        const transform = this.get(Transform2D);\n        const dx = toFixed(target.x) - toFixed(transform.x);\n        const dy = toFixed(target.y) - toFixed(transform.y);\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\n        const distFp = toFixed(distance);\n        const distSqThreshold = fpMul(distFp, distFp);\n\n        return distSq <= distSqThreshold;\n    }\n}\n\n/**\n * Forward declaration for EntityWorld (actual implementation in world.ts).\n */\nexport interface EntityWorld {\n    queryEngine: {\n        addComponent(eid: number, component: ComponentType): void;\n        removeComponent(eid: number, component: ComponentType): void;\n    };\n    destroyEntity(entity: Entity): void;\n}\n\n/**\n * Entity pool for reusing entity wrappers.\n */\nexport class EntityPool {\n    private pool: Entity[] = [];\n    private active: Map<number, Entity> = new Map();\n\n    /**\n     * Get or create an entity wrapper.\n     */\n    acquire(eid: number): Entity {\n        // Check if already have wrapper for this eid\n        let entity = this.active.get(eid);\n        if (entity) {\n            return entity;\n        }\n\n        // Get from pool or create new\n        entity = this.pool.pop() || new Entity();\n        this.active.set(eid, entity);\n\n        return entity;\n    }\n\n    /**\n     * Return entity wrapper to pool.\n     */\n    release(eid: number): void {\n        const entity = this.active.get(eid);\n        if (entity) {\n            entity._cleanup();\n            this.active.delete(eid);\n            this.pool.push(entity);\n        }\n    }\n\n    /**\n     * Get entity by eid if it exists.\n     */\n    get(eid: number): Entity | undefined {\n        return this.active.get(eid);\n    }\n\n    /**\n     * Check if entity exists.\n     */\n    has(eid: number): boolean {\n        return this.active.has(eid);\n    }\n\n    /**\n     * Clear all entities.\n     */\n    clear(): void {\n        for (const entity of this.active.values()) {\n            entity._cleanup();\n            this.pool.push(entity);\n        }\n        this.active.clear();\n    }\n\n    /**\n     * Get count of active entities.\n     */\n    get size(): number {\n        return this.active.size;\n    }\n}\n", "/**\n * Query Engine\n *\n * Efficient entity queries with caching and iterator support.\n * Queries return iterators with snapshot semantics for safe mutation.\n */\n\nimport { ComponentType, hasComponent } from './component';\nimport { INDEX_MASK } from './constants';\n\n/**\n * Entity-like interface for query results.\n * Actual Entity class will implement this.\n */\nexport interface QueryableEntity {\n    readonly eid: number;\n    readonly type: string;\n    readonly destroyed: boolean;\n}\n\n/**\n * Function to get entity wrapper by eid.\n */\nexport type EntityGetter = (eid: number) => QueryableEntity | null;\n\n/**\n * Function to check if entity is destroyed.\n */\nexport type DestroyedChecker = (eid: number) => boolean;\n\n/**\n * Query iterator with snapshot semantics.\n * Captures eid list at creation time for safe iteration during mutation.\n */\nexport class QueryIterator<T extends QueryableEntity> implements Iterable<T> {\n    private eids: number[];\n    private index: number = 0;\n    private getEntity: EntityGetter;\n    private isDestroyed: DestroyedChecker;\n\n    constructor(\n        matchingEids: number[],\n        getEntity: EntityGetter,\n        isDestroyed: DestroyedChecker\n    ) {\n        // Copy eids at creation time - safe from mutation\n        this.eids = matchingEids.slice();\n        this.getEntity = getEntity;\n        this.isDestroyed = isDestroyed;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        this.index = 0;\n        return {\n            next: (): IteratorResult<T> => {\n                while (this.index < this.eids.length) {\n                    const eid = this.eids[this.index++];\n\n                    // Skip destroyed entities\n                    if (this.isDestroyed(eid)) continue;\n\n                    const entity = this.getEntity(eid);\n                    if (entity) {\n                        return { done: false, value: entity as T };\n                    }\n                }\n                return { done: true, value: undefined as any };\n            }\n        };\n    }\n\n    /**\n     * Convert to array (allocates).\n     */\n    toArray(): T[] {\n        const result: T[] = [];\n        for (const entity of this) {\n            result.push(entity);\n        }\n        return result;\n    }\n\n    /**\n     * Get first matching entity.\n     */\n    first(): T | null {\n        for (const entity of this) {\n            return entity;\n        }\n        return null;\n    }\n\n    /**\n     * Find entity matching predicate.\n     */\n    find(predicate: (entity: T) => boolean): T | null {\n        for (const entity of this) {\n            if (predicate(entity)) {\n                return entity;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Count entities without allocating array.\n     */\n    count(): number {\n        let count = 0;\n        for (const _ of this) {\n            count++;\n        }\n        return count;\n    }\n}\n\n/**\n * Query engine - manages entity indices and cached queries.\n */\nexport class QueryEngine {\n    /** Type index: entity type -> set of eids */\n    private typeIndex: Map<string, Set<number>> = new Map();\n\n    /** Component index: component -> set of eids */\n    private componentIndex: Map<ComponentType, Set<number>> = new Map();\n\n    /** Client ID index: clientId -> eid (O(1) lookup) */\n    private clientIdIndex: Map<number, number> = new Map();\n\n    /** Entity getter function */\n    private getEntity: EntityGetter;\n\n    /** Destroyed checker function */\n    private isDestroyed: DestroyedChecker;\n\n    constructor(getEntity: EntityGetter, isDestroyed: DestroyedChecker) {\n        this.getEntity = getEntity;\n        this.isDestroyed = isDestroyed;\n    }\n\n    /**\n     * Register an entity in the indices.\n     */\n    addEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\n        // Add to type index\n        let typeSet = this.typeIndex.get(type);\n        if (!typeSet) {\n            typeSet = new Set();\n            this.typeIndex.set(type, typeSet);\n        }\n        typeSet.add(eid);\n\n        // Add to component indices\n        for (const component of components) {\n            let compSet = this.componentIndex.get(component);\n            if (!compSet) {\n                compSet = new Set();\n                this.componentIndex.set(component, compSet);\n            }\n            compSet.add(eid);\n        }\n\n        // Add to clientId index if provided\n        if (clientId !== undefined) {\n            this.clientIdIndex.set(clientId, eid);\n        }\n    }\n\n    /**\n     * Remove an entity from all indices.\n     */\n    removeEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\n        // Remove from type index\n        this.typeIndex.get(type)?.delete(eid);\n\n        // Remove from component indices\n        for (const component of components) {\n            this.componentIndex.get(component)?.delete(eid);\n        }\n\n        // Remove from clientId index\n        if (clientId !== undefined) {\n            const indexedEid = this.clientIdIndex.get(clientId);\n            if (indexedEid === eid) {\n                this.clientIdIndex.delete(clientId);\n            }\n        }\n    }\n\n    /**\n     * Add component to an existing entity.\n     */\n    addComponent(eid: number, component: ComponentType): void {\n        let compSet = this.componentIndex.get(component);\n        if (!compSet) {\n            compSet = new Set();\n            this.componentIndex.set(component, compSet);\n        }\n        compSet.add(eid);\n    }\n\n    /**\n     * Remove component from an existing entity.\n     */\n    removeComponent(eid: number, component: ComponentType): void {\n        this.componentIndex.get(component)?.delete(eid);\n    }\n\n    /**\n     * Update clientId mapping for an entity.\n     */\n    setClientId(eid: number, clientId: number): void {\n        this.clientIdIndex.set(clientId, eid);\n    }\n\n    /**\n     * Remove clientId mapping.\n     */\n    removeClientId(clientId: number): void {\n        this.clientIdIndex.delete(clientId);\n    }\n\n    /**\n     * Query by entity type.\n     */\n    byType<T extends QueryableEntity>(type: string): QueryIterator<T> {\n        const typeSet = this.typeIndex.get(type);\n        const eids = typeSet ? this.sortedEids(typeSet) : [];\n        return new QueryIterator<T>(eids, this.getEntity, this.isDestroyed);\n    }\n\n    /**\n     * Query by component(s) - entities must have ALL specified components.\n     */\n    byComponents<T extends QueryableEntity>(...components: ComponentType[]): QueryIterator<T> {\n        if (components.length === 0) {\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\n        }\n\n        // Start with the smallest set for efficiency\n        let smallestSet: Set<number> | undefined;\n        let smallestSize = Infinity;\n\n        for (const component of components) {\n            const compSet = this.componentIndex.get(component);\n            if (!compSet || compSet.size === 0) {\n                // One component has no entities, result is empty\n                return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\n            }\n            if (compSet.size < smallestSize) {\n                smallestSize = compSet.size;\n                smallestSet = compSet;\n            }\n        }\n\n        if (!smallestSet) {\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\n        }\n\n        // Filter to entities that have ALL components\n        const result: number[] = [];\n        for (const eid of smallestSet) {\n            let hasAll = true;\n            for (const component of components) {\n                if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\n                    hasAll = false;\n                    break;\n                }\n            }\n            if (hasAll) {\n                result.push(eid);\n            }\n        }\n\n        // Sort by eid for deterministic order\n        result.sort((a, b) => a - b);\n\n        return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\n    }\n\n    /**\n     * Query by type or component.\n     */\n    query<T extends QueryableEntity>(\n        typeOrComponent: string | ComponentType,\n        ...moreComponents: ComponentType[]\n    ): QueryIterator<T> {\n        if (typeof typeOrComponent === 'string') {\n            // Query by type\n            if (moreComponents.length > 0) {\n                // Type + components: filter type results by components\n                const typeSet = this.typeIndex.get(typeOrComponent);\n                if (!typeSet || typeSet.size === 0) {\n                    return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\n                }\n\n                const result: number[] = [];\n                for (const eid of typeSet) {\n                    let hasAll = true;\n                    for (const component of moreComponents) {\n                        if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\n                            hasAll = false;\n                            break;\n                        }\n                    }\n                    if (hasAll) {\n                        result.push(eid);\n                    }\n                }\n\n                result.sort((a, b) => a - b);\n                return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\n            }\n\n            return this.byType<T>(typeOrComponent);\n        }\n\n        // Query by component(s)\n        return this.byComponents<T>(typeOrComponent, ...moreComponents);\n    }\n\n    /**\n     * O(1) lookup by clientId.\n     */\n    getByClientId(clientId: number): number | undefined {\n        return this.clientIdIndex.get(clientId);\n    }\n\n    /**\n     * Get all entity IDs (sorted for determinism).\n     */\n    getAllEids(): number[] {\n        const allEids = new Set<number>();\n\n        for (const typeSet of this.typeIndex.values()) {\n            for (const eid of typeSet) {\n                allEids.add(eid);\n            }\n        }\n\n        return Array.from(allEids).sort((a, b) => a - b);\n    }\n\n    /**\n     * Clear all indices (for reset).\n     */\n    clear(): void {\n        this.typeIndex.clear();\n        this.componentIndex.clear();\n        this.clientIdIndex.clear();\n    }\n\n    /**\n     * Get sorted eids from a set (for deterministic iteration).\n     */\n    private sortedEids(set: Set<number>): number[] {\n        return Array.from(set).sort((a, b) => a - b);\n    }\n}\n", "/**\n * System Scheduler\n *\n * Manages system registration and execution in ordered phases.\n * Systems are functions that operate on entities with specific components.\n */\n\nimport { SystemPhase, SYSTEM_PHASES } from './constants';\n\nexport interface SystemOptions {\n    /** Execution phase (default: 'update') */\n    phase?: SystemPhase;\n\n    /** Only run on client (e.g., rendering) */\n    client?: boolean;\n\n    /** Only run on server */\n    server?: boolean;\n\n    /** Execution order within phase (lower = earlier) */\n    order?: number;\n}\n\nexport type SystemFn = () => void;\n\ninterface SystemEntry {\n    fn: SystemFn;\n    options: SystemOptions;\n    order: number;\n}\n\n/**\n * System scheduler - manages system registration and execution.\n */\nexport class SystemScheduler {\n    /** Systems organized by phase */\n    private systems: Map<SystemPhase, SystemEntry[]> = new Map();\n\n    /** Whether we're running on client or server */\n    private isClient: boolean = true;\n\n    /** System ID counter for ordering */\n    private nextSystemId: number = 0;\n\n    constructor() {\n        // Initialize all phases\n        for (const phase of SYSTEM_PHASES) {\n            this.systems.set(phase, []);\n        }\n    }\n\n    /**\n     * Set whether this scheduler is running on client or server.\n     */\n    setIsClient(isClient: boolean): void {\n        this.isClient = isClient;\n    }\n\n    /**\n     * Add a system to the scheduler.\n     *\n     * @param fn System function to execute\n     * @param options System options (phase, client/server, order)\n     * @returns Function to remove the system\n     */\n    add(fn: SystemFn, options: SystemOptions = {}): () => void {\n        const phase = options.phase || 'update';\n        const systems = this.systems.get(phase);\n\n        if (!systems) {\n            throw new Error(`Unknown system phase: ${phase}`);\n        }\n\n        const entry: SystemEntry = {\n            fn,\n            options,\n            order: options.order ?? this.nextSystemId++\n        };\n\n        systems.push(entry);\n\n        // Sort by order\n        systems.sort((a, b) => a.order - b.order);\n\n        // Return removal function\n        return () => this.remove(fn);\n    }\n\n    /**\n     * Remove a system from the scheduler.\n     */\n    remove(fn: SystemFn): boolean {\n        for (const systems of this.systems.values()) {\n            const index = systems.findIndex(s => s.fn === fn);\n            if (index !== -1) {\n                systems.splice(index, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Run all systems in a specific phase.\n     */\n    runPhase(phase: SystemPhase): void {\n        const systems = this.systems.get(phase);\n        if (!systems) return;\n\n        for (const system of systems) {\n            // Skip client-only systems on server\n            if (system.options.client && !this.isClient) continue;\n\n            // Skip server-only systems on client\n            if (system.options.server && this.isClient) continue;\n\n            // Execute system\n            try {\n                const result = system.fn() as unknown;\n\n                // Check for accidental async systems\n                if (result && typeof result === 'object' && 'then' in result) {\n                    throw new Error(\n                        `System returned a Promise. Async systems are not allowed ` +\n                        `as they break determinism. Remove 'await' from your system.`\n                    );\n                }\n            } catch (error) {\n                console.error(`Error in system during '${phase}' phase:`, error);\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * Run all phases in order (except render if not client).\n     */\n    runAll(): void {\n        for (const phase of SYSTEM_PHASES) {\n            // Skip render phase on server\n            if (phase === 'render' && !this.isClient) continue;\n\n            this.runPhase(phase);\n        }\n    }\n\n    /**\n     * Get count of systems in each phase (for debugging).\n     */\n    getSystemCounts(): Record<SystemPhase, number> {\n        const counts: Partial<Record<SystemPhase, number>> = {};\n        for (const [phase, systems] of this.systems) {\n            counts[phase] = systems.length;\n        }\n        return counts as Record<SystemPhase, number>;\n    }\n\n    /**\n     * Clear all systems (for testing).\n     */\n    clear(): void {\n        for (const systems of this.systems.values()) {\n            systems.length = 0;\n        }\n        this.nextSystemId = 0;\n    }\n}\n", "/**\n * Sparse Snapshot System\n *\n * Efficient snapshot encoding using entity bitmaps.\n * Only active entities are stored, not MAX_ENTITIES slots.\n */\n\nimport { MAX_ENTITIES, INDEX_MASK } from './constants';\nimport { ComponentType, getAllComponents } from './component';\nimport { EntityIdAllocatorState } from './entity-id';\n\n/**\n * Sparse snapshot format.\n * Much smaller than full snapshot when entity count << MAX_ENTITIES.\n */\nexport interface SparseSnapshot {\n    /** Frame number */\n    frame: number;\n\n    /** Sequence number (for network ordering) */\n    seq: number;\n\n    /** Entity metadata (type, clientId) indexed by position in packed arrays */\n    entityMeta: EntityMeta[];\n\n    /** Packed component data for each component type */\n    componentData: Map<string, ArrayBuffer>;\n\n    /** Entity count (for quick reference) */\n    entityCount: number;\n\n    /** Allocator state for deterministic ID recycling */\n    allocator: EntityIdAllocatorState;\n\n    /** String registry for late joiners */\n    strings: {\n        tables: Record<string, Record<string, number>>;\n        nextIds: Record<string, number>;\n    };\n\n    /** RNG state */\n    rng?: { s0: number; s1: number };\n}\n\n/**\n * Entity metadata stored per-entity in snapshot.\n */\nexport interface EntityMeta {\n    eid: number;\n    type: string;\n    clientId?: number;\n}\n\n/**\n * Sparse snapshot encoder/decoder.\n */\nexport class SparseSnapshotCodec {\n    /**\n     * Encode world state to sparse snapshot.\n     */\n    encode(\n        activeEids: number[],\n        getEntityType: (eid: number) => string,\n        getEntityClientId: (eid: number) => number | undefined,\n        getComponentsForEntity: (eid: number) => ComponentType[],\n        allocatorState: EntityIdAllocatorState,\n        stringsState: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> },\n        frame: number = 0,\n        seq: number = 0,\n        rng?: { s0: number; s1: number }\n    ): SparseSnapshot {\n        const entityMeta: EntityMeta[] = [];\n\n        // Sort eids for deterministic order\n        const sortedEids = [...activeEids].sort((a, b) => a - b);\n\n        for (const eid of sortedEids) {\n            entityMeta.push({\n                eid,\n                type: getEntityType(eid),\n                clientId: getEntityClientId(eid)\n            });\n        }\n\n        // Pack component data\n        const componentData = new Map<string, ArrayBuffer>();\n        const allComponents = getAllComponents();\n\n        for (const [name, component] of allComponents) {\n            // Skip components that are not synced (client-only state)\n            if (!component.sync) continue;\n\n            const fieldCount = component.fieldNames.length;\n            if (fieldCount === 0) continue;\n\n            // Calculate buffer size\n            let totalSize = 0;\n            for (const fieldName of component.fieldNames) {\n                const arr = component.storage.fields[fieldName];\n                totalSize += sortedEids.length * arr.BYTES_PER_ELEMENT;\n            }\n\n            const buffer = new ArrayBuffer(totalSize);\n            let offset = 0;\n\n            // Pack each field's data for active entities only\n            for (const fieldName of component.fieldNames) {\n                const sourceArr = component.storage.fields[fieldName];\n                const bytesPerElement = sourceArr.BYTES_PER_ELEMENT;\n\n                // Create view into packed buffer\n                const packedArr = new (sourceArr.constructor as any)(\n                    buffer,\n                    offset,\n                    sortedEids.length\n                );\n\n                // Copy only active entity data\n                for (let i = 0; i < sortedEids.length; i++) {\n                    const index = sortedEids[i] & INDEX_MASK;\n                    packedArr[i] = sourceArr[index];\n                }\n\n                offset += sortedEids.length * bytesPerElement;\n            }\n\n            componentData.set(name, buffer);\n        }\n\n        return {\n            frame,\n            seq,\n            entityMeta,\n            componentData,\n            entityCount: sortedEids.length,\n            allocator: allocatorState,\n            strings: stringsState,\n            rng\n        };\n    }\n\n    /**\n     * Decode sparse snapshot back to world state.\n     */\n    decode(\n        snapshot: SparseSnapshot,\n        clearWorld: () => void,\n        setAllocatorState: (state: EntityIdAllocatorState) => void,\n        setStringsState: (state: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> }) => void,\n        createEntity: (eid: number, type: string, clientId?: number) => void,\n        setRng?: (rng: { s0: number; s1: number }) => void\n    ): void {\n        // Clear existing state\n        clearWorld();\n\n        // Restore allocator state\n        setAllocatorState(snapshot.allocator);\n\n        // Restore strings\n        setStringsState(snapshot.strings);\n\n        // Restore RNG if provided\n        if (snapshot.rng && setRng) {\n            setRng(snapshot.rng);\n        }\n\n        // Get component types\n        const allComponents = getAllComponents();\n\n        // Unpack entities from metadata\n        for (let i = 0; i < snapshot.entityMeta.length; i++) {\n            const meta = snapshot.entityMeta[i];\n            createEntity(meta.eid, meta.type, meta.clientId);\n        }\n\n        // Unpack component data\n        for (const [name, buffer] of snapshot.componentData) {\n            const component = allComponents.get(name);\n            if (!component) continue;\n\n            let offset = 0;\n\n            for (const fieldName of component.fieldNames) {\n                const targetArr = component.storage.fields[fieldName];\n                const bytesPerElement = targetArr.BYTES_PER_ELEMENT;\n\n                // Create view into packed buffer\n                const packedArr = new (targetArr.constructor as any)(\n                    buffer,\n                    offset,\n                    snapshot.entityCount\n                );\n\n                // Unpack to entity indices\n                for (let i = 0; i < snapshot.entityMeta.length; i++) {\n                    const index = snapshot.entityMeta[i].eid & INDEX_MASK;\n                    targetArr[index] = packedArr[i];\n                }\n\n                offset += snapshot.entityCount * bytesPerElement;\n            }\n        }\n    }\n\n    /**\n     * Calculate snapshot size in bytes.\n     */\n    getSize(snapshot: SparseSnapshot): number {\n        let size = 0;\n\n        // Entity metadata (rough estimate)\n        size += snapshot.entityMeta.length * 32; // ~32 bytes per entity meta\n\n        // Component data\n        for (const buffer of snapshot.componentData.values()) {\n            size += buffer.byteLength;\n        }\n\n        // Allocator state\n        size += snapshot.allocator.freeList.length * 4;\n        size += snapshot.allocator.generations.length * 2;\n\n        return size;\n    }\n\n    /**\n     * Serialize snapshot to binary for network transfer.\n     */\n    toBinary(snapshot: SparseSnapshot): ArrayBuffer {\n        // Calculate total size\n        const metaJson = JSON.stringify({\n            frame: snapshot.frame,\n            seq: snapshot.seq,\n            entityMeta: snapshot.entityMeta,\n            allocator: snapshot.allocator,\n            strings: snapshot.strings,\n            rng: snapshot.rng,\n            componentNames: Array.from(snapshot.componentData.keys())\n        });\n\n        const metaBytes = new TextEncoder().encode(metaJson);\n        const metaLength = metaBytes.length;\n\n        // Calculate component data size\n        let componentDataSize = 0;\n        for (const buffer of snapshot.componentData.values()) {\n            componentDataSize += buffer.byteLength;\n        }\n\n        // Total: 4 (meta length) + meta + component data\n        const totalSize = 4 + metaLength + componentDataSize;\n\n        const buffer = new ArrayBuffer(totalSize);\n        const view = new DataView(buffer);\n        let offset = 0;\n\n        // Write meta length and data\n        view.setUint32(offset, metaLength, true);\n        offset += 4;\n        new Uint8Array(buffer, offset, metaLength).set(metaBytes);\n        offset += metaLength;\n\n        // Write component data\n        for (const compBuffer of snapshot.componentData.values()) {\n            new Uint8Array(buffer, offset, compBuffer.byteLength).set(\n                new Uint8Array(compBuffer)\n            );\n            offset += compBuffer.byteLength;\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Deserialize snapshot from binary.\n     */\n    fromBinary(buffer: ArrayBuffer): SparseSnapshot {\n        const view = new DataView(buffer);\n        let offset = 0;\n\n        // Read meta\n        const metaLength = view.getUint32(offset, true);\n        offset += 4;\n        const metaBytes = new Uint8Array(buffer, offset, metaLength);\n        const metaJson = new TextDecoder().decode(metaBytes);\n        const meta = JSON.parse(metaJson);\n        offset += metaLength;\n\n        // Read component data\n        const componentData = new Map<string, ArrayBuffer>();\n        const allComponents = getAllComponents();\n\n        for (const name of meta.componentNames) {\n            const component = allComponents.get(name);\n            if (!component) continue;\n\n            // Calculate size for this component\n            let compSize = 0;\n            for (const fieldName of component.fieldNames) {\n                const arr = component.storage.fields[fieldName];\n                compSize += meta.entityMeta.length * arr.BYTES_PER_ELEMENT;\n            }\n\n            const compBuffer = buffer.slice(offset, offset + compSize);\n            componentData.set(name, compBuffer);\n            offset += compSize;\n        }\n\n        return {\n            frame: meta.frame,\n            seq: meta.seq,\n            entityMeta: meta.entityMeta,\n            componentData,\n            entityCount: meta.entityMeta.length,\n            allocator: meta.allocator,\n            strings: meta.strings,\n            rng: meta.rng\n        };\n    }\n}\n\n/**\n * Rollback buffer - stores snapshots for rewinding state.\n */\nexport class RollbackBuffer {\n    private snapshots: Map<number, SparseSnapshot> = new Map();\n    private codec: SparseSnapshotCodec = new SparseSnapshotCodec();\n\n    constructor(private maxFrames: number = 60) {}\n\n    /**\n     * Save a snapshot for a frame.\n     */\n    save(frame: number, snapshot: SparseSnapshot): void {\n        this.snapshots.set(frame, snapshot);\n\n        // Prune old snapshots (keep exactly maxFrames snapshots)\n        const minFrame = frame - this.maxFrames + 1;\n        for (const f of this.snapshots.keys()) {\n            if (f < minFrame) {\n                this.snapshots.delete(f);\n            }\n        }\n    }\n\n    /**\n     * Get snapshot for a frame.\n     */\n    get(frame: number): SparseSnapshot | undefined {\n        return this.snapshots.get(frame);\n    }\n\n    /**\n     * Check if snapshot exists for frame.\n     */\n    has(frame: number): boolean {\n        return this.snapshots.has(frame);\n    }\n\n    /**\n     * Get oldest available frame.\n     */\n    getOldestFrame(): number | undefined {\n        let oldest: number | undefined;\n        for (const frame of this.snapshots.keys()) {\n            if (oldest === undefined || frame < oldest) {\n                oldest = frame;\n            }\n        }\n        return oldest;\n    }\n\n    /**\n     * Get newest available frame.\n     */\n    getNewestFrame(): number | undefined {\n        let newest: number | undefined;\n        for (const frame of this.snapshots.keys()) {\n            if (newest === undefined || frame > newest) {\n                newest = frame;\n            }\n        }\n        return newest;\n    }\n\n    /**\n     * Clear all snapshots.\n     */\n    clear(): void {\n        this.snapshots.clear();\n    }\n\n    /**\n     * Get number of stored snapshots.\n     */\n    get size(): number {\n        return this.snapshots.size;\n    }\n}\n", "/**\n * String Registry - Deterministic string interning\n *\n * Converts strings to integer IDs for efficient storage and comparison.\n * Used for entity types, colors, sprite IDs, etc.\n *\n * DETERMINISM: ID allocation order must be identical across all clients.\n * Strings are assigned IDs in order of first intern() call.\n */\n\nexport interface StringRegistryState {\n    tables: Record<string, Record<string, number>>;\n    nextIds: Record<string, number>;\n}\n\n/**\n * String registry for interning strings.\n *\n * Provides bidirectional mapping between strings and integer IDs,\n * organized by namespace (e.g., 'color', 'sprite', 'entityType').\n */\nexport class StringRegistry {\n    private stringToId: Map<string, Map<string, number>> = new Map();\n    private idToString: Map<string, Map<number, string>> = new Map();\n    private nextId: Map<string, number> = new Map();\n\n    /**\n     * Intern a string, get back an integer ID.\n     * If the string was already interned, returns the existing ID.\n     *\n     * @param namespace - Category for the string (e.g., 'color', 'sprite')\n     * @param str - The string to intern\n     * @returns Integer ID for the string\n     */\n    intern(namespace: string, str: string): number {\n        let nsMap = this.stringToId.get(namespace);\n        if (!nsMap) {\n            nsMap = new Map();\n            this.stringToId.set(namespace, nsMap);\n        }\n\n        const existing = nsMap.get(str);\n        if (existing !== undefined) return existing;\n\n        const id = this.nextId.get(namespace) ?? 1;\n        this.nextId.set(namespace, id + 1);\n\n        nsMap.set(str, id);\n\n        let idMap = this.idToString.get(namespace);\n        if (!idMap) {\n            idMap = new Map();\n            this.idToString.set(namespace, idMap);\n        }\n        idMap.set(id, str);\n\n        return id;\n    }\n\n    /**\n     * Look up string by ID.\n     *\n     * @param namespace - Category for the string\n     * @param id - Integer ID to look up\n     * @returns The original string, or null if not found\n     */\n    getString(namespace: string, id: number): string | null {\n        return this.idToString.get(namespace)?.get(id) ?? null;\n    }\n\n    /**\n     * Get state for snapshotting.\n     * Returns a serializable representation of all interned strings.\n     */\n    getState(): StringRegistryState {\n        const tables: Record<string, Record<string, number>> = {};\n        const nextIds: Record<string, number> = {};\n\n        for (const [ns, nsMap] of this.stringToId) {\n            tables[ns] = Object.fromEntries(nsMap);\n            nextIds[ns] = this.nextId.get(ns) ?? 1;\n        }\n\n        return { tables, nextIds };\n    }\n\n    /**\n     * Restore state from snapshot.\n     * Replaces all current data with the snapshot state.\n     */\n    setState(state: StringRegistryState): void {\n        this.stringToId.clear();\n        this.idToString.clear();\n        this.nextId.clear();\n\n        for (const [ns, table] of Object.entries(state.tables)) {\n            const nsMap = new Map(Object.entries(table));\n            this.stringToId.set(ns, nsMap);\n\n            const idMap = new Map<number, string>();\n            for (const [str, id] of nsMap) {\n                idMap.set(id, str);\n            }\n            this.idToString.set(ns, idMap);\n\n            this.nextId.set(ns, state.nextIds[ns] ?? 1);\n        }\n    }\n\n    /**\n     * Clear all data.\n     */\n    clear(): void {\n        this.stringToId.clear();\n        this.idToString.clear();\n        this.nextId.clear();\n    }\n}\n", "/**\n * xxHash32 - Fast non-cryptographic hash function\n * Pure JavaScript implementation for determinism across platforms\n *\n * Based on the xxHash specification: https://github.com/Cyan4973/xxHash\n */\n\n// xxHash32 prime constants\nconst PRIME32_1 = 0x9E3779B1 >>> 0;\nconst PRIME32_2 = 0x85EBCA77 >>> 0;\nconst PRIME32_3 = 0xC2B2AE3D >>> 0;\nconst PRIME32_4 = 0x27D4EB2F >>> 0;\nconst PRIME32_5 = 0x165667B1 >>> 0;\n\n/**\n * 32-bit unsigned addition with overflow handling\n */\nfunction add32(a: number, b: number): number {\n  return ((a >>> 0) + (b >>> 0)) >>> 0;\n}\n\n/**\n * 32-bit unsigned multiplication (lower 32 bits of result)\n */\nfunction mul32(a: number, b: number): number {\n  const al = a & 0xFFFF;\n  const ah = a >>> 16;\n  const bl = b & 0xFFFF;\n  const bh = b >>> 16;\n\n  const ll = al * bl;\n  const lh = al * bh;\n  const hl = ah * bl;\n\n  return ((ll + ((lh + hl) << 16)) >>> 0);\n}\n\n/**\n * 32-bit left rotation\n */\nfunction rotl32(value: number, count: number): number {\n  return ((value << count) | (value >>> (32 - count))) >>> 0;\n}\n\n/**\n * Read 32-bit little-endian value from byte array\n */\nfunction readU32LE(data: Uint8Array, offset: number): number {\n  return (data[offset] |\n          (data[offset + 1] << 8) |\n          (data[offset + 2] << 16) |\n          (data[offset + 3] << 24)) >>> 0;\n}\n\n/**\n * xxHash32 round function\n */\nfunction round(acc: number, input: number): number {\n  acc = add32(acc, mul32(input, PRIME32_2));\n  acc = rotl32(acc, 13);\n  acc = mul32(acc, PRIME32_1);\n  return acc;\n}\n\n/**\n * Compute xxHash32 of a byte array\n * @param data Input byte array\n * @param seed Optional seed value (default: 0)\n * @returns 4-byte unsigned integer hash\n */\nexport function xxhash32(data: Uint8Array, seed: number = 0): number {\n  seed = seed >>> 0;\n  const len = data.length;\n  let h32: number;\n  let i = 0;\n\n  if (len >= 16) {\n    // Initialize 4 accumulators\n    let v1 = add32(add32(seed, PRIME32_1), PRIME32_2);\n    let v2 = add32(seed, PRIME32_2);\n    let v3 = seed;\n    let v4 = (seed - PRIME32_1) >>> 0;\n\n    // Process 16-byte blocks\n    const limit = len - 16;\n    do {\n      v1 = round(v1, readU32LE(data, i)); i += 4;\n      v2 = round(v2, readU32LE(data, i)); i += 4;\n      v3 = round(v3, readU32LE(data, i)); i += 4;\n      v4 = round(v4, readU32LE(data, i)); i += 4;\n    } while (i <= limit);\n\n    // Merge accumulators\n    h32 = rotl32(v1, 1) + rotl32(v2, 7) + rotl32(v3, 12) + rotl32(v4, 18);\n    h32 = h32 >>> 0;\n  } else {\n    h32 = add32(seed, PRIME32_5);\n  }\n\n  h32 = add32(h32, len);\n\n  // Process remaining 4-byte chunks\n  while (i + 4 <= len) {\n    h32 = add32(h32, mul32(readU32LE(data, i), PRIME32_3));\n    h32 = mul32(rotl32(h32, 17), PRIME32_4);\n    i += 4;\n  }\n\n  // Process remaining bytes\n  while (i < len) {\n    h32 = add32(h32, mul32(data[i], PRIME32_5));\n    h32 = mul32(rotl32(h32, 11), PRIME32_1);\n    i++;\n  }\n\n  // Final avalanche\n  h32 ^= h32 >>> 15;\n  h32 = mul32(h32, PRIME32_2);\n  h32 ^= h32 >>> 13;\n  h32 = mul32(h32, PRIME32_3);\n  h32 ^= h32 >>> 16;\n\n  return h32 >>> 0;\n}\n\n/**\n * Compute xxHash32 of a string (UTF-8 encoded)\n * @param str Input string\n * @param seed Optional seed value (default: 0)\n * @returns 4-byte unsigned integer hash\n */\nexport function xxhash32String(str: string, seed: number = 0): number {\n  const encoder = new TextEncoder();\n  return xxhash32(encoder.encode(str), seed);\n}\n\n/**\n * Incrementally compute xxHash32 by combining with new data\n * Useful for hashing multiple fields into one hash\n * @param existingHash The current hash value\n * @param newValue New 32-bit value to incorporate\n * @returns Combined hash\n */\nexport function xxhash32Combine(existingHash: number, newValue: number): number {\n  let h = add32(existingHash, mul32(newValue >>> 0, PRIME32_3));\n  h = mul32(rotl32(h, 17), PRIME32_4);\n  h ^= h >>> 15;\n  h = mul32(h, PRIME32_2);\n  h ^= h >>> 13;\n  h = mul32(h, PRIME32_3);\n  h ^= h >>> 16;\n  return h >>> 0;\n}\n", "/**\n * ECS World\n *\n * Main entry point for the ECS system. Manages:\n * - Entity definitions and spawning\n * - Component management\n * - Query engine\n * - System scheduler\n * - String interning\n */\n\nimport { EntityIdAllocator, EntityIdAllocatorState } from './entity-id';\nimport { SparseSnapshot, SparseSnapshotCodec } from './snapshot';\nimport {\n    ComponentType,\n    defineComponent as defineComponentInternal,\n    hasComponent,\n    addComponentToEntity,\n    initializeComponentDefaults,\n    removeComponentFromEntity,\n    clearComponentRegistry,\n    getAllComponents\n} from './component';\nimport { QueryEngine, QueryIterator } from './query';\nimport { SystemScheduler, SystemFn, SystemOptions } from './system';\nimport { Entity, EntityPool, EntityDefinition, RenderState } from './entity';\nimport { INDEX_MASK } from './constants';\nimport { toFixed, saveRandomState, loadRandomState } from '../math';\nimport { StringRegistry } from './string-registry';\nimport { xxhash32Combine } from '../hash/xxhash';\n\n/**\n * Entity definition builder.\n */\nexport class EntityBuilder {\n    private components: Array<{\n        type: ComponentType;\n        defaults?: Record<string, any>;\n    }> = [];\n\n    private registered: boolean = false;\n    private _syncFields?: string[];\n    private _onRestore?: (entity: Entity, game: any) => void;\n\n    constructor(\n        private world: World,\n        private name: string\n    ) {}\n\n    /**\n     * Add a component to this entity definition.\n     */\n    with<T extends Record<string, any>>(\n        component: ComponentType<T>,\n        defaults?: Partial<T>\n    ): EntityBuilder {\n        this.components.push({\n            type: component,\n            defaults: defaults as Record<string, any>\n        });\n\n        // Register immediately (idempotent - just overwrites with latest)\n        this.register();\n\n        return this;\n    }\n\n    /**\n     * Set sync fields for this entity (internal - use GameEntityBuilder.syncOnly()).\n     */\n    _setSyncFields(fields: string[]): void {\n        this._syncFields = fields;\n    }\n\n    /**\n     * Set restore callback for this entity (internal - use GameEntityBuilder.onRestore()).\n     */\n    _setOnRestore(callback: (entity: Entity, game: any) => void): void {\n        this._onRestore = callback;\n    }\n\n    /**\n     * Finalize entity definition.\n     */\n    private register(): void {\n        this.world._registerEntityDef({\n            name: this.name,\n            components: this.components,\n            syncFields: this._syncFields,\n            onRestore: this._onRestore\n        });\n    }\n\n    /**\n     * Force immediate registration (for sync usage).\n     */\n    _ensureRegistered(): void {\n        if (!this.registered) {\n            this.registered = true;\n        }\n        this.register();\n    }\n\n    /**\n     * Get the entity definition (for internal use).\n     */\n    _getDefinition(): EntityDefinition {\n        return {\n            name: this.name,\n            components: this.components,\n            syncFields: this._syncFields,\n            onRestore: this._onRestore\n        };\n    }\n}\n\n/**\n * ECS World - main container for all ECS state.\n */\n/** Bit marker for local-only (syncNone) entity IDs - distinguishes from synced entities */\nexport const LOCAL_ENTITY_BIT = 0x40000000;\n\nexport class World {\n    /** Entity ID allocator (for synced entities) */\n    readonly idAllocator: EntityIdAllocator;\n\n    /** Entity ID allocator for local-only (syncNone) entities - separate to avoid allocator divergence */\n    readonly localIdAllocator: EntityIdAllocator;\n\n    /** Query engine */\n    readonly queryEngine: QueryEngine;\n\n    /** System scheduler */\n    readonly scheduler: SystemScheduler;\n\n    /** Entity pool */\n    readonly entityPool: EntityPool;\n\n    /** String registry */\n    readonly strings: StringRegistry;\n\n    /** Entity definitions */\n    private entityDefs: Map<string, EntityDefinition> = new Map();\n\n    /** Active entity eids */\n    private activeEntities: Set<number> = new Set();\n\n    /** Entity type by eid */\n    private entityTypes: Map<number, string> = new Map();\n\n    /** Entity components by eid */\n    private entityComponents: Map<number, ComponentType[]> = new Map();\n\n    /** Client ID by eid */\n    private entityClientIds: Map<number, number> = new Map();\n\n    /** Input registry: clientId \u2192 input data */\n    private inputRegistry: Map<number, any> = new Map();\n\n    /** Whether running on client */\n    private _isClient: boolean = true;\n\n    constructor() {\n        this.idAllocator = new EntityIdAllocator();\n        this.localIdAllocator = new EntityIdAllocator();  // Separate allocator for syncNone entities\n        this.entityPool = new EntityPool();\n        this.strings = new StringRegistry();\n\n        // Create query engine with callbacks\n        this.queryEngine = new QueryEngine(\n            (eid) => this.getEntity(eid),\n            (eid) => this.isDestroyed(eid)\n        );\n\n        this.scheduler = new SystemScheduler();\n\n        // Register interpolation state saving in prePhysics phase\n        this.addSystem(() => this.saveInterpolationState(), { phase: 'prePhysics', order: -1000 });\n    }\n\n    /**\n     * Set whether running on client.\n     */\n    setIsClient(isClient: boolean): void {\n        this._isClient = isClient;\n        this.scheduler.setIsClient(isClient);\n    }\n\n    /**\n     * Check if running on client.\n     */\n    get isClient(): boolean {\n        return this._isClient;\n    }\n\n    // ==========================================\n    // Component API\n    // ==========================================\n\n    /**\n     * Define a new component type.\n     */\n    defineComponent<T extends Record<string, any>>(\n        name: string,\n        defaults: T\n    ): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\n        return defineComponentInternal(name, defaults);\n    }\n\n    // ==========================================\n    // Entity Definition API\n    // ==========================================\n\n    /**\n     * Define a new entity type.\n     */\n    defineEntity(name: string): EntityBuilder {\n        const builder = new EntityBuilder(this, name);\n        // Auto-register when builder methods are done\n        // We need to defer this, so we'll register on first spawn or explicitly\n        return builder;\n    }\n\n    /**\n     * Register an entity definition (internal).\n     */\n    _registerEntityDef(def: EntityDefinition): void {\n        this.entityDefs.set(def.name, def);\n    }\n\n    /**\n     * Get entity definition by type name.\n     */\n    getEntityDef(typeName: string): EntityDefinition | undefined {\n        return this.entityDefs.get(typeName);\n    }\n\n    // ==========================================\n    // Entity Spawning/Destruction\n    // ==========================================\n\n    /**\n     * Spawn a new entity.\n     */\n    spawn(\n        typeOrBuilder: string | EntityBuilder,\n        props: Record<string, any> = {}\n    ): Entity {\n        // Handle EntityBuilder\n        let typeName: string;\n        if (typeof typeOrBuilder === 'string') {\n            typeName = typeOrBuilder;\n        } else {\n            const def = typeOrBuilder._getDefinition();\n            this._registerEntityDef(def);\n            typeName = def.name;\n        }\n\n        // Get entity definition\n        const def = this.entityDefs.get(typeName);\n        if (!def) {\n            throw new Error(`Unknown entity type: '${typeName}'`);\n        }\n\n        // Check if this is a syncNone (local-only) entity\n        const isSyncNone = def.syncFields && def.syncFields.length === 0;\n\n        // Allocate entity ID - use separate allocator for syncNone to avoid state divergence\n        let eid: number;\n        if (isSyncNone) {\n            // Local-only entities use localIdAllocator with high bit marker\n            const localEid = this.localIdAllocator.allocate();\n            eid = localEid | LOCAL_ENTITY_BIT;  // Mark as local entity\n        } else {\n            // Synced entities use main allocator\n            eid = this.idAllocator.allocate();\n        }\n        const index = eid & INDEX_MASK;\n\n        // Get entity wrapper\n        const entity = this.entityPool.acquire(eid);\n\n        // Track entity\n        this.activeEntities.add(eid);\n        this.entityTypes.set(eid, typeName);\n\n        // Initialize components\n        const componentTypes: ComponentType[] = [];\n        for (const compDef of def.components) {\n            const component = compDef.type;\n            componentTypes.push(component);\n\n            // Add to storage\n            addComponentToEntity(component.storage, index);\n            initializeComponentDefaults(component.storage, index);\n\n            // Apply definition defaults\n            if (compDef.defaults) {\n                for (const [key, value] of Object.entries(compDef.defaults)) {\n                    const arr = component.storage.fields[key];\n                    if (arr) {\n                        const fieldDef = component.storage.schema[key];\n                        if (fieldDef.type === 'i32') {\n                            arr[index] = toFixed(value as number);\n                        } else if (fieldDef.type === 'bool') {\n                            arr[index] = value ? 1 : 0;\n                        } else {\n                            arr[index] = value;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Apply spawn props (route to components)\n        let clientId: number | undefined;\n        for (const [key, value] of Object.entries(props)) {\n            if (key === 'clientId') {\n                clientId = value as number;\n                this.entityClientIds.set(eid, clientId);\n            }\n\n            // Route to first component that has this field\n            for (const component of componentTypes) {\n                if (key in component.storage.schema) {\n                    const arr = component.storage.fields[key];\n                    const fieldDef = component.storage.schema[key];\n                    if (fieldDef.type === 'i32') {\n                        arr[index] = toFixed(value as number);\n                    } else if (fieldDef.type === 'bool') {\n                        arr[index] = value ? 1 : 0;\n                    } else {\n                        arr[index] = value;\n                    }\n                    break; // Route to first matching component\n                }\n            }\n        }\n\n        // Store components\n        this.entityComponents.set(eid, componentTypes);\n\n        // Initialize entity wrapper\n        entity._init(eid, typeName, componentTypes, this);\n\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\n        // Use raw props values (before fixed-point conversion) for render coordinates\n        if (props.x !== undefined || props.y !== undefined) {\n            const spawnX = props.x ?? 0;\n            const spawnY = props.y ?? 0;\n            entity.render.prevX = spawnX;\n            entity.render.prevY = spawnY;\n            entity.render.interpX = spawnX;\n            entity.render.interpY = spawnY;\n        }\n\n        // Register in query engine\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\n\n        return entity;\n    }\n\n    /**\n     * Spawn an entity with a specific eid (for snapshot restore).\n     * This is used when restoring entities to preserve their original IDs.\n     */\n    spawnWithId(typeOrBuilder: string | EntityBuilder, targetEid: number, props: Record<string, any> = {}): Entity {\n        let typeName: string;\n        if (typeof typeOrBuilder === 'string') {\n            typeName = typeOrBuilder;\n        } else {\n            const def = typeOrBuilder._getDefinition();\n            this._registerEntityDef(def);\n            typeName = def.name;\n        }\n\n        // Get entity definition\n        const def = this.entityDefs.get(typeName);\n        if (!def) {\n            throw new Error(`Unknown entity type: '${typeName}'`);\n        }\n\n        // Allocate specific entity ID\n        const eid = this.idAllocator.allocateSpecific(targetEid);\n        const index = eid & INDEX_MASK;\n\n        // Get entity wrapper\n        const entity = this.entityPool.acquire(eid);\n\n        // Track entity\n        this.activeEntities.add(eid);\n        this.entityTypes.set(eid, typeName);\n\n        // Initialize components\n        const componentTypes: ComponentType[] = [];\n        for (const compDef of def.components) {\n            const component = compDef.type;\n            componentTypes.push(component);\n\n            // Add to storage\n            addComponentToEntity(component.storage, index);\n            initializeComponentDefaults(component.storage, index);\n\n            // Apply definition defaults\n            if (compDef.defaults) {\n                for (const [key, value] of Object.entries(compDef.defaults)) {\n                    const arr = component.storage.fields[key];\n                    if (arr) {\n                        const fieldDef = component.storage.schema[key];\n                        if (fieldDef.type === 'i32') {\n                            arr[index] = toFixed(value as number);\n                        } else if (fieldDef.type === 'bool') {\n                            arr[index] = value ? 1 : 0;\n                        } else {\n                            arr[index] = value;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Apply spawn props (route to components)\n        let clientId: number | undefined;\n        for (const [key, value] of Object.entries(props)) {\n            if (key === 'clientId') {\n                clientId = value as number;\n                this.entityClientIds.set(eid, clientId);\n            }\n\n            // Route to first component that has this field\n            for (const compDef of def.components) {\n                const arr = compDef.type.storage.fields[key];\n                if (arr) {\n                    const fieldDef = compDef.type.storage.schema[key];\n                    if (fieldDef.type === 'i32') {\n                        arr[index] = toFixed(value as number);\n                    } else if (fieldDef.type === 'bool') {\n                        arr[index] = value ? 1 : 0;\n                    } else {\n                        arr[index] = value;\n                    }\n                    break; // Route to first matching component\n                }\n            }\n        }\n\n        // Store components\n        this.entityComponents.set(eid, componentTypes);\n\n        // Initialize entity wrapper\n        entity._init(eid, typeName, componentTypes, this);\n\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\n        // Use raw props values (before fixed-point conversion) for render coordinates\n        if (props.x !== undefined || props.y !== undefined) {\n            const spawnX = props.x ?? 0;\n            const spawnY = props.y ?? 0;\n            entity.render.prevX = spawnX;\n            entity.render.prevY = spawnY;\n            entity.render.interpX = spawnX;\n            entity.render.interpY = spawnY;\n        }\n\n        // Register in query engine\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\n\n        return entity;\n    }\n\n    /**\n     * Destroy an entity.\n     */\n    destroyEntity(entity: Entity): void {\n        const eid = entity.eid;\n\n        if (!this.activeEntities.has(eid)) {\n            return; // Already destroyed\n        }\n\n        const typeName = this.entityTypes.get(eid) || '';\n        const components = this.entityComponents.get(eid) || [];\n        const clientId = this.entityClientIds.get(eid);\n        const index = eid & INDEX_MASK;\n\n        // Remove from component storage\n        for (const component of components) {\n            removeComponentFromEntity(component.storage, index);\n        }\n\n        // Remove from query engine\n        this.queryEngine.removeEntity(eid, typeName, components, clientId);\n\n        // Clean up tracking\n        this.activeEntities.delete(eid);\n        this.entityTypes.delete(eid);\n        this.entityComponents.delete(eid);\n        this.entityClientIds.delete(eid);\n\n        // Return entity wrapper to pool\n        this.entityPool.release(eid);\n\n        // Free entity ID to the correct allocator\n        if (eid & LOCAL_ENTITY_BIT) {\n            // Local entity - strip the marker bit and free to localIdAllocator\n            this.localIdAllocator.free(eid & ~LOCAL_ENTITY_BIT);\n        } else {\n            // Synced entity - free to main allocator\n            this.idAllocator.free(eid);\n        }\n    }\n\n    /**\n     * Get entity by eid.\n     */\n    getEntity(eid: number): Entity | null {\n        if (!this.activeEntities.has(eid)) {\n            return null;\n        }\n\n        const entity = this.entityPool.get(eid);\n        if (entity && !entity.destroyed) {\n            return entity;\n        }\n\n        return null;\n    }\n\n    /**\n     * Check if entity is destroyed.\n     */\n    isDestroyed(eid: number): boolean {\n        return !this.activeEntities.has(eid);\n    }\n\n    /**\n     * Get entity by clientId (O(1) lookup).\n     */\n    getEntityByClientId(clientId: number): Entity | null {\n        const eid = this.queryEngine.getByClientId(clientId);\n        if (eid === undefined) return null;\n        return this.getEntity(eid);\n    }\n\n    /**\n     * Set clientId for an entity (for snapshot restore).\n     * Updates both entityClientIds map and queryEngine index.\n     */\n    setEntityClientId(eid: number, clientId: number): void {\n        this.entityClientIds.set(eid, clientId);\n        this.queryEngine.setClientId(eid, clientId);\n    }\n\n    // ==========================================\n    // Query API\n    // ==========================================\n\n    /**\n     * Query entities by type or component.\n     */\n    query(\n        typeOrComponent: string | ComponentType,\n        ...moreComponents: ComponentType[]\n    ): QueryIterator<Entity> {\n        return this.queryEngine.query(typeOrComponent, ...moreComponents);\n    }\n\n    /**\n     * Get all active entities.\n     */\n    getAllEntities(): Entity[] {\n        const result: Entity[] = [];\n        // Sort eids for determinism\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\n        for (const eid of sortedEids) {\n            const entity = this.entityPool.get(eid);\n            if (entity) {\n                result.push(entity);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get all active entity IDs.\n     */\n    getAllEntityIds(): number[] {\n        return Array.from(this.activeEntities).sort((a, b) => a - b);\n    }\n\n    // ==========================================\n    // System API\n    // ==========================================\n\n    /**\n     * Add a system.\n     */\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\n        return this.scheduler.add(fn, options);\n    }\n\n    /**\n     * Run all systems.\n     */\n    runSystems(): void {\n        this.scheduler.runAll();\n    }\n\n    // ==========================================\n    // String Interning API\n    // ==========================================\n\n    /**\n     * Intern a string, get back an integer ID.\n     */\n    internString(namespace: string, str: string): number {\n        return this.strings.intern(namespace, str);\n    }\n\n    /**\n     * Look up string by ID.\n     */\n    getString(namespace: string, id: number): string | null {\n        return this.strings.getString(namespace, id);\n    }\n\n    // ==========================================\n    // Input Registry\n    // ==========================================\n\n    /**\n     * Set input data for a client.\n     */\n    setInput(clientId: number, data: any): void {\n        this.inputRegistry.set(clientId, data);\n        // Also set on entity if it exists\n        const entity = this.getEntityByClientId(clientId);\n        if (entity) {\n            entity._setInputData(data);\n        }\n    }\n\n    /**\n     * Get input data for a client.\n     */\n    getInput(clientId: number): any {\n        return this.inputRegistry.get(clientId);\n    }\n\n    /**\n     * Clear all input data (call at end of tick).\n     */\n    clearInputs(): void {\n        this.inputRegistry.clear();\n    }\n\n    /**\n     * Get input state for snapshot.\n     * Returns a map of clientId -> input data.\n     */\n    getInputState(): Record<number, any> {\n        const state: Record<number, any> = {};\n        for (const [clientId, data] of this.inputRegistry) {\n            state[clientId] = data;\n        }\n        return state;\n    }\n\n    /**\n     * Set input state from snapshot.\n     * Restores the input registry and entity input caches.\n     */\n    setInputState(state: Record<number, any>): void {\n        this.inputRegistry.clear();\n        for (const [clientIdStr, data] of Object.entries(state)) {\n            const clientId = parseInt(clientIdStr, 10);\n            this.inputRegistry.set(clientId, data);\n            // Also set on entity if it exists\n            const entity = this.getEntityByClientId(clientId);\n            if (entity) {\n                entity._setInputData(data);\n            }\n        }\n    }\n\n\n    // ==========================================\n    // State Management\n    // ==========================================\n\n    /**\n     * Get full world state for snapshotting.\n     */\n    getState(): WorldState {\n        const entities: EntityState[] = [];\n\n        for (const eid of this.activeEntities) {\n            const typeName = this.entityTypes.get(eid)!;\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            const componentData: Record<string, Record<string, number>> = {};\n\n            for (const component of components) {\n                const data: Record<string, number> = {};\n                for (const [fieldName, arr] of Object.entries(component.storage.fields)) {\n                    data[fieldName] = arr[index];\n                }\n                componentData[component.name] = data;\n            }\n\n            entities.push({\n                eid,\n                type: typeName,\n                components: componentData,\n                clientId: this.entityClientIds.get(eid)\n            });\n        }\n\n        return {\n            entities,\n            allocator: this.idAllocator.getState(),\n            strings: this.strings.getState()\n        };\n    }\n\n    /**\n     * Restore world state from snapshot.\n     */\n    setState(state: WorldState): void {\n        // Clear current state\n        this.clear();\n\n        // Restore allocator\n        this.idAllocator.setState(state.allocator);\n\n        // Restore strings\n        this.strings.setState(state.strings);\n\n        // Restore entities\n        for (const entityState of state.entities) {\n            const def = this.entityDefs.get(entityState.type);\n            if (!def) {\n                console.warn(`Unknown entity type in snapshot: ${entityState.type}`);\n                continue;\n            }\n\n            const eid = entityState.eid;\n            const index = eid & INDEX_MASK;\n\n            // Get entity wrapper\n            const entity = this.entityPool.acquire(eid);\n\n            // Track entity\n            this.activeEntities.add(eid);\n            this.entityTypes.set(eid, entityState.type);\n\n            if (entityState.clientId !== undefined) {\n                this.entityClientIds.set(eid, entityState.clientId);\n            }\n\n            // Restore components\n            const componentTypes: ComponentType[] = [];\n            for (const compDef of def.components) {\n                const component = compDef.type;\n                componentTypes.push(component);\n\n                addComponentToEntity(component.storage, index);\n\n                // Restore component data\n                const savedData = entityState.components[component.name];\n                if (savedData) {\n                    for (const [fieldName, value] of Object.entries(savedData)) {\n                        const arr = component.storage.fields[fieldName];\n                        if (arr) {\n                            arr[index] = value;\n                        }\n                    }\n                }\n            }\n\n            this.entityComponents.set(eid, componentTypes);\n\n            // Initialize entity wrapper\n            entity._init(eid, entityState.type, componentTypes, this);\n\n            // Register in query engine\n            this.queryEngine.addEntity(eid, entityState.type, componentTypes, entityState.clientId);\n        }\n    }\n\n    /**\n     * Clear all world state.\n     */\n    clear(): void {\n        // Release all entities\n        for (const eid of this.activeEntities) {\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            for (const component of components) {\n                removeComponentFromEntity(component.storage, index);\n            }\n\n            this.entityPool.release(eid);\n        }\n\n        // Clear tracking\n        this.activeEntities.clear();\n        this.entityTypes.clear();\n        this.entityComponents.clear();\n        this.entityClientIds.clear();\n\n        // Clear indices\n        this.queryEngine.clear();\n\n        // Reset allocators\n        this.idAllocator.reset();\n        this.localIdAllocator.reset();\n\n        // Clear strings\n        this.strings.clear();\n    }\n\n    /**\n     * Reset world (keeps definitions, clears entities).\n     */\n    reset(): void {\n        this.clear();\n    }\n\n    /**\n     * Get entity count.\n     */\n    get entityCount(): number {\n        return this.activeEntities.size;\n    }\n\n    // ==========================================\n    // Sparse Snapshot API (Efficient)\n    // ==========================================\n\n    /** Snapshot codec */\n    private snapshotCodec: SparseSnapshotCodec = new SparseSnapshotCodec();\n\n    /** Current frame number */\n    frame: number = 0;\n\n    /** Current sequence number */\n    seq: number = 0;\n\n    /** RNG state (for determinism) - deprecated, now uses global random state */\n    rngState?: { s0: number; s1: number };\n\n    /**\n     * Get sparse snapshot (efficient format).\n     */\n    getSparseSnapshot(): SparseSnapshot {\n        return this.snapshotCodec.encode(\n            Array.from(this.activeEntities),\n            (eid) => this.entityTypes.get(eid) || '',\n            (eid) => this.entityClientIds.get(eid),\n            (eid) => this.entityComponents.get(eid) || [],\n            this.idAllocator.getState(),\n            this.strings.getState(),\n            this.frame,\n            this.seq,\n            saveRandomState() // CRITICAL: Save actual RNG state for deterministic rollback\n        );\n    }\n\n    /**\n     * Load sparse snapshot (efficient format).\n     */\n    loadSparseSnapshot(snapshot: SparseSnapshot): void {\n        // Save visual positions BEFORE clearing entities\n        const savedVisualPositions = new Map<number, { x: number; y: number }>();\n        for (const eid of this.activeEntities) {\n            const entity = this.entityPool.get(eid);\n            if (entity) {\n                savedVisualPositions.set(eid, {\n                    x: entity.render.interpX,\n                    y: entity.render.interpY\n                });\n            }\n        }\n\n        this.snapshotCodec.decode(\n            snapshot,\n            () => this.clearForSnapshot(),\n            (state) => this.idAllocator.setState(state),\n            (state) => this.strings.setState(state),\n            (eid, type, clientId) => this.createEntityFromSnapshot(eid, type, clientId),\n            (rng) => {\n                if (rng) {\n                    loadRandomState(rng);\n                }\n            }\n        );\n\n        this.frame = snapshot.frame;\n        this.seq = snapshot.seq;\n\n        // Restore visual positions for smooth interpolation\n        this.syncRenderStateFromTransforms(savedVisualPositions);\n    }\n\n    /**\n     * Sync render state after snapshot restore.\n     * Uses saved visual positions for smooth interpolation.\n     */\n    private syncRenderStateFromTransforms(savedPositions: Map<number, { x: number; y: number }>): void {\n        for (const eid of this.activeEntities) {\n            const entity = this.getEntity(eid);\n            if (!entity) continue;\n\n            // Use saved visual position as prev for smooth blending\n            const saved = savedPositions.get(eid);\n            if (saved) {\n                entity.render.prevX = saved.x;\n                entity.render.prevY = saved.y;\n            }\n\n            // Set interpX/Y from current transform\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n            for (const component of components) {\n                if (component.name === 'Transform2D') {\n                    const xArr = component.storage.fields['x'];\n                    const yArr = component.storage.fields['y'];\n                    if (xArr && yArr) {\n                        entity.render.interpX = xArr[index] / 65536;\n                        entity.render.interpY = yArr[index] / 65536;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear world for snapshot restore (doesn't reset allocator).\n     */\n    private clearForSnapshot(): void {\n        // Release all entities\n        for (const eid of this.activeEntities) {\n            const components = this.entityComponents.get(eid) || [];\n            const index = eid & INDEX_MASK;\n\n            for (const component of components) {\n                removeComponentFromEntity(component.storage, index);\n            }\n\n            this.entityPool.release(eid);\n        }\n\n        // Clear tracking\n        this.activeEntities.clear();\n        this.entityTypes.clear();\n        this.entityComponents.clear();\n        this.entityClientIds.clear();\n\n        // Clear query indices\n        this.queryEngine.clear();\n    }\n\n    /**\n     * Create entity from snapshot data (without allocating new ID).\n     */\n    private createEntityFromSnapshot(eid: number, type: string, clientId?: number): void {\n        const def = this.entityDefs.get(type);\n        if (!def) {\n            console.warn(`Unknown entity type in snapshot: ${type}`);\n            return;\n        }\n\n        const index = eid & INDEX_MASK;\n\n        // Get entity wrapper\n        const entity = this.entityPool.acquire(eid);\n\n        // Track entity\n        this.activeEntities.add(eid);\n        this.entityTypes.set(eid, type);\n\n        if (clientId !== undefined) {\n            this.entityClientIds.set(eid, clientId);\n        }\n\n        // Setup components (data will be restored by codec)\n        const componentTypes: ComponentType[] = [];\n        for (const compDef of def.components) {\n            const component = compDef.type;\n            componentTypes.push(component);\n            addComponentToEntity(component.storage, index);\n        }\n\n        this.entityComponents.set(eid, componentTypes);\n\n        // Initialize entity wrapper\n        entity._init(eid, type, componentTypes, this);\n\n        // Register in query engine\n        this.queryEngine.addEntity(eid, type, componentTypes, clientId);\n    }\n\n    /**\n     * Serialize snapshot to binary for network transfer.\n     */\n    snapshotToBinary(snapshot: SparseSnapshot): ArrayBuffer {\n        return this.snapshotCodec.toBinary(snapshot);\n    }\n\n    /**\n     * Deserialize snapshot from binary.\n     */\n    snapshotFromBinary(buffer: ArrayBuffer): SparseSnapshot {\n        return this.snapshotCodec.fromBinary(buffer);\n    }\n\n    /**\n     * Get snapshot size estimate.\n     */\n    getSnapshotSize(snapshot: SparseSnapshot): number {\n        return this.snapshotCodec.getSize(snapshot);\n    }\n\n    // ==========================================\n    // Network Integration (Phase 3)\n    // ==========================================\n\n    /**\n     * Network input format.\n     */\n    private inputBuffer: Map<number, Record<string, any>> = new Map();\n\n    /**\n     * Run a single game tick with network inputs.\n     *\n     * Executes all system phases in order:\n     * 1. INPUT - Apply network inputs to entities\n     * 2. UPDATE - Game logic systems\n     * 3. PREPHYSICS - Save state for interpolation\n     * 4. PHYSICS - Physics simulation (external hook)\n     * 5. POSTPHYSICS - Post-physics cleanup\n     * 6. RENDER - Rendering (client only)\n     */\n    /** True while running deterministic simulation phases */\n    _isSimulating: boolean = false;\n\n    tick(frame: number, inputs: NetworkInput[] = []): void {\n        this.frame = frame;\n\n        // Apply network inputs (O(1) per input via clientIdIndex)\n        this.applyNetworkInputs(inputs);\n\n        // Run deterministic simulation phases\n        this._isSimulating = true;\n        try {\n            this.scheduler.runPhase('input');\n            this.scheduler.runPhase('update');\n            this.scheduler.runPhase('prePhysics');\n            this.scheduler.runPhase('physics');\n            this.scheduler.runPhase('postPhysics');\n        } finally {\n            this._isSimulating = false;\n        }\n\n        // Render phase only runs on client (not deterministic)\n        if (this._isClient) {\n            this.scheduler.runPhase('render');\n        }\n\n        // Clear input buffer after tick\n        this.inputBuffer.clear();\n    }\n\n    /**\n     * Apply network inputs to entities via O(1) clientId lookup.\n     */\n    private applyNetworkInputs(inputs: NetworkInput[]): void {\n        for (const input of inputs) {\n            // O(1) lookup via clientIdIndex\n            const entity = this.getEntityByClientId(input.clientId);\n\n            if (entity) {\n                // Store input data for systems to read\n                this.inputBuffer.set(input.clientId, input.data);\n\n                // Apply input to entity's render state for interpolation reference\n                const data = input.data;\n                if (data) {\n                    // Store in entity's input cache for system access\n                    entity._setInputData(data);\n                }\n            }\n            // If no entity for this clientId, silently ignore (disconnected player)\n        }\n    }\n\n    /**\n     * Get input data for a clientId.\n     */\n    getInputForClient(clientId: number): Record<string, any> | undefined {\n        return this.inputBuffer.get(clientId);\n    }\n\n    /**\n     * Check if we have input for a clientId this tick.\n     */\n    hasInputForClient(clientId: number): boolean {\n        return this.inputBuffer.has(clientId);\n    }\n\n    /**\n     * Run only physics phase (for external physics integration).\n     */\n    runPhysics(): void {\n        this.scheduler.runPhase('physics');\n    }\n\n    /**\n     * Set physics step callback (called during PHYSICS phase).\n     */\n    setPhysicsStep(fn: () => void): () => void {\n        return this.addSystem(fn, { phase: 'physics', order: 0 });\n    }\n\n    /**\n     * Save previous positions for interpolation (called in prePhysics).\n     */\n    saveInterpolationState(): void {\n        for (const eid of this.activeEntities) {\n            const entity = this.getEntity(eid);\n            if (entity) {\n                entity._savePreviousState();\n            }\n        }\n    }\n\n    // ==========================================\n    // State Synchronization\n    // ==========================================\n\n    /** Local client ID for this client */\n    localClientId: number | null = null;\n\n    /**\n     * Get deterministic hash of world state.\n     * Used for comparing state between clients.\n     * Returns 4-byte unsigned integer (xxhash32).\n     * Excludes components with sync: false (client-only state).\n     */\n    getStateHash(): number {\n        // Get all entity data in deterministic order\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\n\n        // Filter out syncNone entities (client-only, should not affect hash)\n        const syncedEids = sortedEids.filter(eid => {\n            const typeName = this.entityTypes.get(eid);\n            if (!typeName) return true;  // Include if no type (shouldn't happen)\n            const entityDef = this.entityDefs.get(typeName);\n            // Skip if syncFields is empty array (syncNone)\n            if (entityDef?.syncFields && entityDef.syncFields.length === 0) {\n                return false;\n            }\n            return true;\n        });\n\n        let hash = 0;\n\n        // Hash entity count first (only synced entities)\n        hash = xxhash32Combine(hash, syncedEids.length);\n\n        for (const eid of syncedEids) {\n            const index = eid & INDEX_MASK;\n            const components = this.entityComponents.get(eid) || [];\n\n            // Hash eid\n            hash = xxhash32Combine(hash, eid >>> 0);\n\n            // Hash each component's fields in deterministic order\n            for (const component of components) {\n                // Skip components that are not synced (client-only state)\n                if (!component.sync) continue;\n\n                const fieldNames = [...component.fieldNames].sort();\n                for (const fieldName of fieldNames) {\n                    const arr = component.storage.fields[fieldName];\n                    const value = arr[index];\n                    hash = xxhash32Combine(hash, value >>> 0);\n                }\n            }\n        }\n\n        return hash >>> 0;\n    }\n\n    /**\n     * Get deterministic hash as hex string (for debugging).\n     * @deprecated Use getStateHash() which returns a number.\n     */\n    getStateHashHex(): string {\n        return this.getStateHash().toString(16).padStart(8, '0');\n    }\n}\n\n/**\n * Network input format.\n */\nexport interface NetworkInput {\n    clientId: number;\n    data: Record<string, any>;\n}\n\n/**\n * World state for snapshotting.\n */\nexport interface WorldState {\n    entities: EntityState[];\n    allocator: EntityIdAllocatorState;\n    strings: {\n        tables: Record<string, Record<string, number>>;\n        nextIds: Record<string, number>;\n    };\n}\n\n/**\n * Entity state for snapshotting.\n */\nexport interface EntityState {\n    eid: number;\n    type: string;\n    components: Record<string, Record<string, number>>;\n    clientId?: number;\n}\n", "/**\n * Codec Module\n *\n * Binary encoding/decoding for network communication.\n */\n\nexport { encode, decode } from './binary';\n", "/**\n * Binary Codec\n *\n * Compact binary encoding for arbitrary JSON-like data.\n * Used for inputs, snapshots, and all engine-network communication.\n */\n\n// Type markers\nconst TYPE_NULL = 0x00;\nconst TYPE_FALSE = 0x01;\nconst TYPE_TRUE = 0x02;\nconst TYPE_INT8 = 0x03;\nconst TYPE_INT16 = 0x04;\nconst TYPE_INT32 = 0x05;\nconst TYPE_FLOAT64 = 0x06;\nconst TYPE_STRING = 0x07;\nconst TYPE_ARRAY = 0x08;\nconst TYPE_OBJECT = 0x09;\nconst TYPE_UINT8 = 0x0A;\nconst TYPE_UINT16 = 0x0B;\nconst TYPE_UINT32 = 0x0C;\n\n/**\n * Binary encoder - accumulates bytes\n */\nclass BinaryEncoder {\n    private buffer: number[] = [];\n\n    writeByte(b: number): void {\n        this.buffer.push(b & 0xFF);\n    }\n\n    writeUint16(n: number): void {\n        this.buffer.push((n >> 8) & 0xFF);\n        this.buffer.push(n & 0xFF);\n    }\n\n    writeUint32(n: number): void {\n        this.buffer.push((n >> 24) & 0xFF);\n        this.buffer.push((n >> 16) & 0xFF);\n        this.buffer.push((n >> 8) & 0xFF);\n        this.buffer.push(n & 0xFF);\n    }\n\n    writeInt32(n: number): void {\n        this.writeUint32(n >>> 0);\n    }\n\n    writeFloat64(n: number): void {\n        const view = new DataView(new ArrayBuffer(8));\n        view.setFloat64(0, n, false); // big-endian\n        for (let i = 0; i < 8; i++) {\n            this.buffer.push(view.getUint8(i));\n        }\n    }\n\n    writeString(s: string): void {\n        const encoded = new TextEncoder().encode(s);\n        this.writeUint16(encoded.length);\n        for (let i = 0; i < encoded.length; i++) {\n            this.buffer.push(encoded[i]);\n        }\n    }\n\n    writeValue(value: any): void {\n        if (value === null || value === undefined) {\n            this.writeByte(TYPE_NULL);\n        } else if (value === false) {\n            this.writeByte(TYPE_FALSE);\n        } else if (value === true) {\n            this.writeByte(TYPE_TRUE);\n        } else if (typeof value === 'number') {\n            if (Number.isInteger(value)) {\n                if (value >= 0 && value <= 255) {\n                    this.writeByte(TYPE_UINT8);\n                    this.writeByte(value);\n                } else if (value >= 0 && value <= 65535) {\n                    this.writeByte(TYPE_UINT16);\n                    this.writeUint16(value);\n                } else if (value >= -2147483648 && value <= 2147483647) {\n                    this.writeByte(TYPE_INT32);\n                    this.writeInt32(value);\n                } else {\n                    this.writeByte(TYPE_FLOAT64);\n                    this.writeFloat64(value);\n                }\n            } else {\n                this.writeByte(TYPE_FLOAT64);\n                this.writeFloat64(value);\n            }\n        } else if (typeof value === 'string') {\n            this.writeByte(TYPE_STRING);\n            this.writeString(value);\n        } else if (Array.isArray(value)) {\n            this.writeByte(TYPE_ARRAY);\n            this.writeUint16(value.length);\n            for (const item of value) {\n                this.writeValue(item);\n            }\n        } else if (typeof value === 'object') {\n            this.writeByte(TYPE_OBJECT);\n            const keys = Object.keys(value);\n            this.writeUint16(keys.length);\n            for (const key of keys) {\n                this.writeString(key);\n                this.writeValue(value[key]);\n            }\n        } else {\n            // Unknown type - encode as null\n            this.writeByte(TYPE_NULL);\n        }\n    }\n\n    toUint8Array(): Uint8Array {\n        return new Uint8Array(this.buffer);\n    }\n}\n\n/**\n * Binary decoder - reads bytes\n */\nclass BinaryDecoder {\n    private data: Uint8Array;\n    private pos: number = 0;\n\n    constructor(data: Uint8Array) {\n        this.data = data;\n    }\n\n    readByte(): number {\n        return this.data[this.pos++];\n    }\n\n    readUint16(): number {\n        const b1 = this.data[this.pos++];\n        const b2 = this.data[this.pos++];\n        return (b1 << 8) | b2;\n    }\n\n    readUint32(): number {\n        const b1 = this.data[this.pos++];\n        const b2 = this.data[this.pos++];\n        const b3 = this.data[this.pos++];\n        const b4 = this.data[this.pos++];\n        return ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) >>> 0;\n    }\n\n    readInt32(): number {\n        const u = this.readUint32();\n        return u > 0x7FFFFFFF ? u - 0x100000000 : u;\n    }\n\n    readFloat64(): number {\n        const view = new DataView(new ArrayBuffer(8));\n        for (let i = 0; i < 8; i++) {\n            view.setUint8(i, this.data[this.pos++]);\n        }\n        return view.getFloat64(0, false);\n    }\n\n    readString(): string {\n        const len = this.readUint16();\n        const bytes = this.data.slice(this.pos, this.pos + len);\n        this.pos += len;\n        return new TextDecoder().decode(bytes);\n    }\n\n    readValue(): any {\n        const type = this.readByte();\n\n        switch (type) {\n            case TYPE_NULL:\n                return null;\n            case TYPE_FALSE:\n                return false;\n            case TYPE_TRUE:\n                return true;\n            case TYPE_UINT8:\n                return this.readByte();\n            case TYPE_UINT16:\n                return this.readUint16();\n            case TYPE_INT32:\n                return this.readInt32();\n            case TYPE_UINT32:\n                return this.readUint32();\n            case TYPE_FLOAT64:\n                return this.readFloat64();\n            case TYPE_STRING:\n                return this.readString();\n            case TYPE_ARRAY: {\n                const len = this.readUint16();\n                const arr = [];\n                for (let i = 0; i < len; i++) {\n                    arr.push(this.readValue());\n                }\n                return arr;\n            }\n            case TYPE_OBJECT: {\n                const len = this.readUint16();\n                const obj: Record<string, any> = {};\n                for (let i = 0; i < len; i++) {\n                    const key = this.readString();\n                    obj[key] = this.readValue();\n                }\n                return obj;\n            }\n            default:\n                return null;\n        }\n    }\n}\n\n/**\n * Encode any JSON-compatible value to binary.\n */\nexport function encode(value: any): Uint8Array {\n    const encoder = new BinaryEncoder();\n    encoder.writeValue(value);\n    return encoder.toUint8Array();\n}\n\n/**\n * Decode binary data to a value.\n */\nexport function decode(data: Uint8Array): any {\n    const decoder = new BinaryDecoder(data);\n    return decoder.readValue();\n}\n", "/**\n * State Delta Computation\n *\n * Computes compact deltas between snapshots for efficient network sync.\n * Used by the distributed state sync protocol.\n */\n\nimport { xxhash32Combine } from '../hash/xxhash';\nimport { SparseSnapshot, EntityMeta } from '../core/snapshot';\nimport { getAllComponents } from '../core/component';\n\n\n/**\n * Represents changes between two world states.\n */\nexport interface StateDelta {\n  /** Frame number this delta applies to */\n  frame: number;\n\n  /** Hash of the base state (before applying delta) */\n  baseHash: number;\n\n  /** Hash of the resulting state (after applying delta) */\n  resultHash: number;\n\n  /** Newly created entities */\n  created: CreatedEntity[];\n\n  /** Deleted entity IDs */\n  deleted: number[];\n}\n\n/**\n * A newly created entity with all its data.\n */\nexport interface CreatedEntity {\n  eid: number;\n  type: string;\n  clientId?: number;\n  /** Component name -> field name -> value */\n  components: Record<string, Record<string, number>>;\n}\n\n\n/**\n * Compute state delta between two snapshots.\n */\nexport function computeStateDelta(\n  prevSnapshot: SparseSnapshot | null,\n  currentSnapshot: SparseSnapshot\n): StateDelta {\n  const allComponents = getAllComponents();\n\n  // Build lookup for previous entity IDs\n  const prevEntityIds = new Set<number>();\n  if (prevSnapshot) {\n    for (const meta of prevSnapshot.entityMeta) {\n      prevEntityIds.add(meta.eid);\n    }\n  }\n\n  // Find created entities (need component data for new entities)\n  const created: CreatedEntity[] = [];\n  const deleted: number[] = [];\n\n  for (let i = 0; i < currentSnapshot.entityMeta.length; i++) {\n    const meta = currentSnapshot.entityMeta[i];\n\n    if (!prevEntityIds.has(meta.eid)) {\n      // New entity - extract component data\n      const entityData: Record<string, Record<string, number>> = {};\n      for (const [compName, buffer] of currentSnapshot.componentData) {\n        const component = allComponents.get(compName);\n        if (!component) continue;\n\n        const fields: Record<string, number> = {};\n        let offset = 0;\n        for (const fieldName of component.fieldNames) {\n          const arr = component.storage.fields[fieldName];\n          const bytesPerElement = arr.BYTES_PER_ELEMENT;\n          const packedArr = new (arr.constructor as any)(buffer, offset, currentSnapshot.entityCount);\n          fields[fieldName] = packedArr[i];\n          offset += currentSnapshot.entityCount * bytesPerElement;\n        }\n        entityData[compName] = fields;\n      }\n\n      created.push({\n        eid: meta.eid,\n        type: meta.type,\n        clientId: meta.clientId,\n        components: entityData\n      });\n    }\n  }\n\n  // Find deleted entities\n  if (prevSnapshot) {\n    const currentEntityIds = new Set<number>();\n    for (const meta of currentSnapshot.entityMeta) {\n      currentEntityIds.add(meta.eid);\n    }\n    for (const meta of prevSnapshot.entityMeta) {\n      if (!currentEntityIds.has(meta.eid)) {\n        deleted.push(meta.eid);\n      }\n    }\n  }\n\n  // Sort for determinism\n  created.sort((a, b) => a.eid - b.eid);\n  deleted.sort((a, b) => a - b);\n\n  return {\n    frame: currentSnapshot.frame,\n    baseHash: prevSnapshot ? computeSnapshotHash(prevSnapshot) : 0,\n    resultHash: computeSnapshotHash(currentSnapshot),\n    created,\n    deleted\n  };\n}\n\n/**\n * Compute xxhash32 of a snapshot for state verification.\n */\nexport function computeSnapshotHash(snapshot: SparseSnapshot): number {\n  const allComponents = getAllComponents();\n\n  let hash = 0;\n\n  // Hash frame number\n  hash = xxhash32Combine(hash, snapshot.frame);\n\n  // Hash entity count\n  hash = xxhash32Combine(hash, snapshot.entityCount);\n\n  // Hash each entity in deterministic order (already sorted in snapshot)\n  for (let i = 0; i < snapshot.entityMeta.length; i++) {\n    const meta = snapshot.entityMeta[i];\n\n    // Hash eid\n    hash = xxhash32Combine(hash, meta.eid);\n\n    // Hash component data for this entity\n    for (const [compName, buffer] of snapshot.componentData) {\n      const component = allComponents.get(compName);\n      if (!component) continue;\n\n      let offset = 0;\n      for (const fieldName of component.fieldNames) {\n        const arr = component.storage.fields[fieldName];\n        const bytesPerElement = arr.BYTES_PER_ELEMENT;\n        const packedArr = new (arr.constructor as any)(buffer, offset, snapshot.entityCount);\n        const value = packedArr[i];\n        hash = xxhash32Combine(hash, value >>> 0);\n        offset += snapshot.entityCount * bytesPerElement;\n      }\n    }\n  }\n\n  return hash >>> 0;\n}\n\n/**\n * Serialize delta to binary format for network transfer.\n */\nexport function serializeDelta(delta: StateDelta): Uint8Array {\n  // Use JSON for simplicity - can optimize to binary later\n  const json = JSON.stringify(delta);\n  const encoder = new TextEncoder();\n  return encoder.encode(json);\n}\n\n/**\n * Deserialize delta from binary format.\n */\nexport function deserializeDelta(bytes: Uint8Array): StateDelta {\n  const decoder = new TextDecoder();\n  const json = decoder.decode(bytes);\n  return JSON.parse(json);\n}\n\n/**\n * Get partition data for a specific partition.\n * Partitions entities by eid % numPartitions.\n *\n * @param delta Full delta\n * @param partitionId Which partition (0 to numPartitions-1)\n * @param numPartitions Total number of partitions\n * @returns Serialized partition data containing only entities for this partition\n */\nexport function getPartition(\n  delta: StateDelta,\n  partitionId: number,\n  numPartitions: number\n): Uint8Array {\n  // Filter created entities\n  const partitionCreated = delta.created.filter(\n    e => getEntityPartition(e.eid, numPartitions) === partitionId\n  );\n\n  // Filter deleted entities\n  const partitionDeleted = delta.deleted.filter(\n    eid => getEntityPartition(eid, numPartitions) === partitionId\n  );\n\n  const partitionDelta: PartitionDelta = {\n    partitionId,\n    numPartitions,\n    frame: delta.frame,\n    created: partitionCreated,\n    deleted: partitionDeleted\n  };\n\n  const json = JSON.stringify(partitionDelta);\n  const encoder = new TextEncoder();\n  return encoder.encode(json);\n}\n\n/**\n * Determine which partition an entity belongs to.\n */\nexport function getEntityPartition(eid: number, numPartitions: number): number {\n  return eid % numPartitions;\n}\n\n/**\n * Partition-specific delta data.\n */\nexport interface PartitionDelta {\n  partitionId: number;\n  numPartitions: number;\n  frame: number;\n  created: CreatedEntity[];\n  deleted: number[];\n}\n\n/**\n * Deserialize partition data.\n */\nexport function deserializePartition(bytes: Uint8Array): PartitionDelta {\n  const decoder = new TextDecoder();\n  const json = decoder.decode(bytes);\n  return JSON.parse(json);\n}\n\n/**\n * Assemble full delta from partition data.\n */\nexport function assemblePartitions(partitions: PartitionDelta[]): StateDelta | null {\n  if (partitions.length === 0) return null;\n\n  // Verify all partitions are for the same frame\n  const frame = partitions[0].frame;\n\n  for (const p of partitions) {\n    if (p.frame !== frame) {\n      console.warn('Partition frame mismatch');\n      return null;\n    }\n  }\n\n  // Combine all partition data\n  const created: CreatedEntity[] = [];\n  const deleted: number[] = [];\n\n  for (const p of partitions) {\n    created.push(...p.created);\n    deleted.push(...p.deleted);\n  }\n\n  // Sort for determinism\n  created.sort((a, b) => a.eid - b.eid);\n  deleted.sort((a, b) => a - b);\n\n  return {\n    frame,\n    baseHash: 0, // Not known from partitions\n    resultHash: 0, // Not known from partitions\n    created,\n    deleted\n  };\n}\n\n/**\n * Apply delta to update snapshot/world state.\n * Returns the entity IDs that were affected.\n */\nexport function applyDelta(\n  delta: StateDelta,\n  createEntity: (eid: number, type: string, clientId?: number, components?: Record<string, Record<string, number>>) => void,\n  deleteEntity: (eid: number) => void\n): { created: number[]; deleted: number[] } {\n  // Apply deletions first\n  for (const eid of delta.deleted) {\n    deleteEntity(eid);\n  }\n\n  // Apply creations\n  for (const entity of delta.created) {\n    createEntity(entity.eid, entity.type, entity.clientId, entity.components);\n  }\n\n  return {\n    created: delta.created.map(e => e.eid),\n    deleted: delta.deleted\n  };\n}\n\n/**\n * Check if delta is empty (no changes).\n */\nexport function isDeltaEmpty(delta: StateDelta): boolean {\n  return delta.created.length === 0 && delta.deleted.length === 0;\n}\n\n/**\n * Get approximate size of delta in bytes.\n */\nexport function getDeltaSize(delta: StateDelta): number {\n  // Rough estimate\n  let size = 16; // frame + hashes\n\n  for (const entity of delta.created) {\n    size += 12; // eid + type overhead\n    size += JSON.stringify(entity.components).length;\n  }\n\n  size += delta.deleted.length * 4; // 4 bytes per deleted eid\n\n  return size;\n}\n", "/**\n * Partition Assignment Algorithm\n *\n * Determines which clients are responsible for sending which partitions.\n * Uses fixed-point arithmetic for cross-platform determinism.\n *\n * Key properties:\n * - Deterministic: Same inputs always produce same outputs\n * - Zero-coordination: All clients can compute independently\n * - Reliability-weighted: More reliable clients are more likely to be selected\n * - Frame-seeded: Different assignments each frame to distribute load\n */\n\nimport { xxhash32Combine } from '../hash/xxhash';\n\n/**\n * Fixed-point scale factor (2^16 = 65536)\n * This gives us ~4 decimal places of precision.\n */\nconst FP_SCALE = 65536;\nconst FP_HALF = 32768;\n\n/**\n * Result of partition assignment computation.\n */\nexport interface PartitionAssignment {\n  /** Map of partitionId -> array of clientIds assigned to send it */\n  partitionSenders: Map<number, string[]>;\n\n  /** Number of partitions */\n  numPartitions: number;\n\n  /** Frame this assignment is for */\n  frame: number;\n}\n\n/**\n * Compute partition assignment for a frame.\n * All clients compute the same result independently.\n *\n * @param entityCount Number of entities (determines partition count)\n * @param clientIds List of active client IDs\n * @param frame Current frame number (used as seed)\n * @param reliability Map of clientId -> reliability score (0-100)\n * @param sendersPerPartition How many clients should send each partition (default: 2)\n * @returns Partition assignment\n */\nexport function computePartitionAssignment(\n  entityCount: number,\n  clientIds: string[],\n  frame: number,\n  reliability: Record<string, number>,\n  sendersPerPartition: number = 2\n): PartitionAssignment {\n  // Sort client IDs for determinism\n  const sortedClients = [...clientIds].sort();\n\n  // Determine number of partitions based on entity count\n  const numPartitions = computePartitionCount(entityCount, sortedClients.length);\n\n  // Create result map\n  const partitionSenders = new Map<number, string[]>();\n\n  // Assign senders to each partition\n  for (let partitionId = 0; partitionId < numPartitions; partitionId++) {\n    // Compute seed for this partition+frame combination\n    const seed = computePartitionSeed(frame, partitionId);\n\n    // Select clients for this partition using weighted random\n    const senders = weightedRandomPick(\n      sortedClients,\n      Math.min(sendersPerPartition, sortedClients.length),\n      seed,\n      reliability\n    );\n\n    partitionSenders.set(partitionId, senders);\n  }\n\n  return {\n    partitionSenders,\n    numPartitions,\n    frame\n  };\n}\n\n/**\n * Compute deterministic partition count based on entity count and client count.\n */\nexport function computePartitionCount(entityCount: number, clientCount: number): number {\n  if (clientCount <= 0) return 1;\n  if (entityCount <= 0) return 1;\n\n  // Target: 20-50 entities per partition\n  // Min: 1 partition\n  // Max: clientCount * 2 partitions (so each client handles ~2 partitions)\n  const targetEntitiesPerPartition = 30;\n  const idealPartitions = Math.ceil(entityCount / targetEntitiesPerPartition);\n\n  // Clamp to reasonable range\n  const minPartitions = 1;\n  const maxPartitions = Math.max(1, clientCount * 2);\n\n  return Math.max(minPartitions, Math.min(maxPartitions, idealPartitions));\n}\n\n/**\n * Compute deterministic seed for a partition+frame combination.\n * Uses xxhash32 combining for good distribution.\n */\nexport function computePartitionSeed(frame: number, partitionId: number): number {\n  let seed = 0x12345678;\n  seed = xxhash32Combine(seed, frame >>> 0);\n  seed = xxhash32Combine(seed, partitionId >>> 0);\n  return seed >>> 0;\n}\n\n/**\n * Weighted random selection without replacement.\n * Uses fixed-point arithmetic for determinism.\n *\n * @param clients Sorted list of client IDs\n * @param count Number of clients to select\n * @param seed Random seed\n * @param reliability Map of clientId -> reliability score (0-100)\n * @returns Selected client IDs\n */\nexport function weightedRandomPick(\n  clients: string[],\n  count: number,\n  seed: number,\n  reliability: Record<string, number>\n): string[] {\n  if (clients.length === 0) return [];\n  if (count >= clients.length) return [...clients];\n\n  const result: string[] = [];\n  const available = [...clients];\n  let rng = seed;\n\n  for (let i = 0; i < count && available.length > 0; i++) {\n    // Compute weights in fixed-point\n    const weights = computeFixedPointWeights(available, reliability);\n\n    // Select based on weights\n    const selectedIdx = selectWeighted(weights, rng);\n    result.push(available[selectedIdx]);\n\n    // Remove selected client\n    available.splice(selectedIdx, 1);\n\n    // Advance RNG\n    rng = nextRandom(rng);\n  }\n\n  return result;\n}\n\n/**\n * Compute weights in fixed-point format.\n * Reliability 0-100 maps to weight 1-101 (never zero to ensure all clients have some chance).\n */\nfunction computeFixedPointWeights(\n  clients: string[],\n  reliability: Record<string, number>\n): number[] {\n  const weights: number[] = [];\n\n  for (const clientId of clients) {\n    // Get reliability, default to 50 if not specified\n    const rel = reliability[clientId] ?? 50;\n\n    // Clamp to 0-100 range\n    const clampedRel = Math.max(0, Math.min(100, rel));\n\n    // Convert to weight: reliability + 1 (so 0 reliability still has weight 1)\n    // Scale to fixed-point\n    const weight = ((clampedRel + 1) * FP_SCALE) | 0;\n    weights.push(weight);\n  }\n\n  return weights;\n}\n\n/**\n * Select an index based on weights using fixed-point arithmetic.\n */\nfunction selectWeighted(weights: number[], seed: number): number {\n  if (weights.length === 0) return -1;\n  if (weights.length === 1) return 0;\n\n  // Compute total weight\n  let totalWeight = 0;\n  for (const w of weights) {\n    totalWeight = (totalWeight + w) | 0;\n  }\n\n  if (totalWeight <= 0) {\n    // Fallback to uniform if all weights are 0\n    return seed % weights.length;\n  }\n\n  // Generate random threshold in [0, totalWeight)\n  // Use fixed-point multiplication to avoid floating point\n  const randNormalized = (seed >>> 0) % FP_SCALE;\n  const threshold = mulFP(randNormalized, totalWeight);\n\n  // Find which bucket the threshold falls into\n  let cumulative = 0;\n  for (let i = 0; i < weights.length; i++) {\n    cumulative = (cumulative + weights[i]) | 0;\n    if (threshold < cumulative) {\n      return i;\n    }\n  }\n\n  // Fallback (should rarely happen due to rounding)\n  return weights.length - 1;\n}\n\n/**\n * Fixed-point multiplication.\n * a and b are in FP_SCALE format.\n * Returns result in original scale (divides by FP_SCALE).\n */\nfunction mulFP(a: number, b: number): number {\n  // Use BigInt for large intermediate values to avoid overflow\n  // This is the only way to get deterministic multiplication in JS\n  const result = (BigInt(a >>> 0) * BigInt(b >>> 0)) / BigInt(FP_SCALE);\n  return Number(result) | 0;\n}\n\n/**\n * Simple deterministic RNG (xorshift32).\n * Returns next random value.\n */\nfunction nextRandom(state: number): number {\n  let x = state >>> 0;\n  x ^= x << 13;\n  x ^= x >>> 17;\n  x ^= x << 5;\n  return x >>> 0;\n}\n\n/**\n * Determine which partition an entity belongs to.\n * Same as in state-delta.ts, exported here for convenience.\n */\nexport function getEntityPartition(eid: number, numPartitions: number): number {\n  return eid % numPartitions;\n}\n\n/**\n * Check if a client is assigned to send a specific partition.\n */\nexport function isClientAssigned(\n  assignment: PartitionAssignment,\n  clientId: string,\n  partitionId: number\n): boolean {\n  const senders = assignment.partitionSenders.get(partitionId);\n  return senders?.includes(clientId) ?? false;\n}\n\n/**\n * Get all partitions a client is assigned to send.\n */\nexport function getClientPartitions(\n  assignment: PartitionAssignment,\n  clientId: string\n): number[] {\n  const partitions: number[] = [];\n  for (const [partitionId, senders] of assignment.partitionSenders) {\n    if (senders.includes(clientId)) {\n      partitions.push(partitionId);\n    }\n  }\n  return partitions.sort((a, b) => a - b);\n}\n\n/**\n * Degradation tier for when clients fail to deliver.\n */\nexport type DegradationTier = 'NORMAL' | 'DEGRADED' | 'MINIMAL' | 'SKIP';\n\n/**\n * Compute degradation tier based on partition collection success.\n */\nexport function computeDegradationTier(\n  totalPartitions: number,\n  receivedPartitions: number,\n  trustedSenders: number,\n  totalSenders: number\n): DegradationTier {\n  // All partitions received from trusted senders\n  if (receivedPartitions === totalPartitions && trustedSenders === totalSenders) {\n    return 'NORMAL';\n  }\n\n  // Most partitions received (>75%)\n  if (receivedPartitions > totalPartitions * 0.75) {\n    return 'DEGRADED';\n  }\n\n  // Some partitions received (>25%)\n  if (receivedPartitions > totalPartitions * 0.25) {\n    return 'MINIMAL';\n  }\n\n  // Too few partitions - skip this tick's delta\n  return 'SKIP';\n}\n", "/**\n * Game - High-level wrapper for ECS World with Network Integration\n *\n * Provides the game API that examples use:\n * - game.defineEntity(name) \u2192 EntityBuilder\n * - game.spawn(type, props) \u2192 Entity\n * - game.query(type) \u2192 Iterator\n * - game.addSystem(fn, options)\n * - game.physics \u2192 Physics2D integration\n * - game.connect() \u2192 Network connection with distributed state sync\n */\n\nimport { World, EntityBuilder, NetworkInput, LOCAL_ENTITY_BIT } from './core/world';\nimport { Entity } from './core/entity';\nimport { ComponentType } from './core/component';\nimport { SystemFn, SystemOptions } from './core/system';\nimport { Transform2D, Body2D, Player } from './components';\nimport { SparseSnapshot } from './core/snapshot';\nimport { QueryIterator } from './core/query';\nimport { encode, decode } from './codec';\nimport { loadRandomState, saveRandomState } from './math/random';\nimport { INDEX_MASK } from './core/constants';\nimport {\n    computePartitionAssignment,\n    getClientPartitions,\n    computeStateDelta,\n    getPartition,\n    computePartitionCount,\n    isDeltaEmpty,\n    getDeltaSize\n} from './sync';\n\n// ==========================================\n// Types\n// ==========================================\n\n/** Physics system interface */\ninterface Physics2DLike {\n    physicsWorld: any;\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this;\n    setGravity(x: number, y: number): this;\n    getBody(entity: Entity): any;\n    clear(): void;\n    wakeAllBodies(): void;\n    syncAllFromComponents(): void;\n}\n\n/** Network connection interface (from modu-network SDK) */\ninterface Connection {\n    send(data: any): void;\n    sendSnapshot(snapshot: any, hash: number, seq?: number, frame?: number): void;\n    leaveRoom(): void;\n    clientId: string | null;\n    totalBytesIn: number;\n    totalBytesOut: number;\n    bandwidthIn: number;\n    bandwidthOut: number;\n\n    // State sync methods (optional - implemented by SDK)\n    sendStateHash?(frame: number, hash: number): void;\n    sendPartitionData?(frame: number, partitionId: number, data: Uint8Array): void;\n    requestResync?(): void;\n\n    // State sync callbacks (set by game)\n    onReliabilityUpdate?: (scores: Record<string, number>, version: number) => void;\n    onMajorityHash?: (frame: number, hash: number) => void;\n    onResyncSnapshot?: (data: Uint8Array, frame: number) => void;\n}\n\n/** Network SDK interface */\ninterface NetworkSDK {\n    connect(roomId: string, options: any): Promise<Connection>;\n}\n\n/** Network input from server */\ninterface ServerInput {\n    seq: number;\n    clientId: string;\n    data: any;\n    frame?: number;\n}\n\n/** Game callbacks for lifecycle events */\nexport interface GameCallbacks {\n    /** Called when room is first created (first client joins) */\n    onRoomCreate?(): void;\n    /** Called when a client connects */\n    onConnect?(clientId: string): void;\n    /** Called when a client disconnects */\n    onDisconnect?(clientId: string): void;\n    /** Called after snapshot restore with all restored entities */\n    onSnapshot?(entities: Entity[]): void;\n    /** Called each game tick */\n    onTick?(frame: number): void;\n    /** Called each render frame */\n    render?(): void;\n}\n\n/** Connection options */\nexport interface ConnectOptions {\n    /** Direct node URL (bypasses central service) */\n    nodeUrl?: string;\n    /** Central service URL */\n    centralServiceUrl?: string;\n    /** JWT token for authentication */\n    joinToken?: string;\n}\n\n// Debug flag - set to false for production\nconst DEBUG_NETWORK = false;\n\n// ==========================================\n// Prefab Class\n// ==========================================\n\n/**\n * Prefab - spawnable entity definition\n */\nexport class Prefab {\n    constructor(\n        private game: Game,\n        private typeName: string,\n        private builder: EntityBuilder\n    ) {}\n\n    /**\n     * Spawn a new entity from this prefab.\n     */\n    spawn(props: Record<string, any> = {}): Entity {\n        return this.game.spawn(this.typeName, props);\n    }\n}\n\n// ==========================================\n// Game Class\n// ==========================================\n\n/**\n * Game class - main entry point for games using the ECS.\n */\nexport class Game {\n    /** ECS World instance */\n    readonly world: World;\n\n    /** Physics system (optional) */\n    physics: Physics2DLike | null = null;\n\n    // ==========================================\n    // Network State\n    // ==========================================\n\n    /** WebSocket connection */\n    private connection: Connection | null = null;\n\n    /** Game callbacks */\n    private callbacks: GameCallbacks = {};\n\n    /** Connected room ID */\n    private connectedRoomId: string | null = null;\n\n    /** Local client ID (string form) */\n    private localClientIdStr: string | null = null;\n\n\n    /** Authority client (first joiner, sends snapshots) */\n    private authorityClientId: string | null = null;\n\n    /** Current server frame */\n    private currentFrame: number = 0;\n\n    /** Last processed frame (for skipping old frames after catchup) */\n    private lastProcessedFrame: number = 0;\n\n    /** Last processed input sequence */\n    private lastInputSeq: number = 0;\n\n    /** Server tick rate */\n    private serverFps: number = 20;\n\n    /** RequestAnimationFrame handle */\n    private gameLoop: number | null = null;\n\n    /** Deferred snapshot flag (send after tick completes) */\n    private pendingSnapshotUpload: boolean = false;\n\n    /** Flag: local room was created before server connected (for local-first) */\n    private localRoomCreated: boolean = false;\n\n    /** Flag: game has been started (via start() or connect()) */\n    private gameStarted: boolean = false;\n\n    /** Last snapshot info for debug UI */\n    private lastSnapshotHash: number | null = null;\n    private lastSnapshotFrame: number = 0;\n    private lastSnapshotSize: number = 0;\n    private lastSnapshotEntityCount: number = 0;\n    private snapshotLoadedFrame: number = 0;  // Frame when snapshot was loaded (for debug timing)\n\n    /** Drift tracking stats for debug UI */\n    private driftStats = {\n        determinismPercent: 100,\n        totalChecks: 0,\n        matchingFieldCount: 0,\n        totalFieldCount: 0\n    };\n\n    /** Divergence tracking */\n    private lastSyncPercent: number = 100;\n    private firstDivergenceFrame: number | null = null;\n    private divergenceHistory: Array<{ frame: number; field: string; local: any; server: any; delta?: number }> = [];\n    private recentInputs: Array<{ frame: number; seq: number; clientId: string; data: any }> = [];\n    private lastServerSnapshot: { raw: Uint8Array | null; decoded: any; frame: number } = { raw: null, decoded: null, frame: 0 };\n    private lastGoodSnapshot: { snapshot: any; frame: number; hash: number } | null = null;\n    private divergenceCaptured: boolean = false;\n    private divergenceCapture: {\n        lastGoodSnapshot: any;\n        lastGoodFrame: number;\n        inputs: Array<{ frame: number; seq: number; clientId: string; data: any }>;\n        localSnapshot: any;\n        serverSnapshot: any;\n        diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }>;\n        divergenceFrame: number;\n        clientId: string | null;\n        isAuthority: boolean;\n    } | null = null;\n\n    /** Tick timing for render interpolation */\n    private lastTickTime: number = 0;\n    private tickIntervalMs: number = 50; // 20fps default\n\n    // ==========================================\n    // State Sync\n    // ==========================================\n\n    /** Current reliability scores from server (clientId -> score) */\n    private reliabilityScores: Record<string, number> = {};\n\n    /** Reliability scores version (for change detection) */\n    private reliabilityVersion: number = 0;\n\n    /** Active client list (sorted, for deterministic partition assignment) */\n    private activeClients: string[] = [];\n\n    /** Previous snapshot for delta computation */\n    private prevSnapshot: SparseSnapshot | null = null;\n\n    /** State sync enabled flag */\n    private stateSyncEnabled: boolean = true;\n\n    /** Delta bandwidth tracking */\n    private deltaBytesThisSecond: number = 0;\n    private deltaBytesPerSecond: number = 0;\n    private deltaBytesSampleTime: number = 0;\n\n    /** Desync tracking for hash-based sync */\n    private isDesynced: boolean = false;\n    private desyncFrame: number = 0;\n    private desyncLocalHash: number = 0;\n    private desyncMajorityHash: number = 0;\n    private resyncPending: boolean = false;\n\n    /** Hash comparison stats (rolling window) */\n    private hashChecksPassed: number = 0;\n    private hashChecksFailed: number = 0;\n\n    /** State hash history for desync comparison (frame -> hash) */\n    private stateHashHistory: Map<number, number> = new Map();\n    private readonly HASH_HISTORY_SIZE = 10;  // Keep last 10 frames of hashes\n\n    // ==========================================\n    // String Interning\n    // ==========================================\n\n    /** String to ID mapping for clientIds */\n    private clientIdToNum: Map<string, number> = new Map();\n    private numToClientId: Map<number, string> = new Map();\n    private nextClientNum: number = 1;\n\n    /** Prefab registry */\n    private prefabs: Map<string, Prefab> = new Map();\n\n    /** Collision handlers (type:type -> handler) */\n    private collisionHandlers: Map<string, (a: Entity, b: Entity) => void> = new Map();\n\n    /** Clients that already have entities from snapshot (skip onConnect for them during catchup) */\n    private clientsWithEntitiesFromSnapshot: Set<string> = new Set();\n\n    /** ClientIds that were in the snapshot's clientIdMap (includes clients who joined then left) */\n    private clientIdsFromSnapshotMap: Set<string> = new Set();\n\n    /** ClientIds that have DISCONNECT inputs during current catchup (for robust stale JOIN detection) */\n    private clientsWithDisconnectInCatchup: Set<string> = new Set();\n\n    /** True during catchup simulation */\n    private inCatchupMode: boolean = false;\n\n    /** Attached renderer */\n    private renderer: any = null;\n\n    /** Installed plugins */\n    private plugins: Map<string, any> = new Map();\n\n    constructor() {\n        this.world = new World();\n    }\n\n    // ==========================================\n    // Plugin API\n    // ==========================================\n\n    /**\n     * Add a plugin to the game.\n     *\n     * Plugins can be classes or factory functions that integrate with the game.\n     * Common plugins include Physics2DSystem and AutoRenderer.\n     *\n     * @example\n     * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n     * game.addPlugin(AutoRenderer, canvas);\n     *\n     * @param Plugin - Plugin class or factory\n     * @param args - Arguments to pass to the plugin constructor\n     * @returns The created plugin instance\n     */\n    addPlugin<T>(\n        Plugin: new (game: Game, ...args: any[]) => T,\n        ...args: any[]\n    ): T {\n        const plugin = new Plugin(this, ...args);\n        const name = Plugin.name || 'anonymous';\n        this.plugins.set(name, plugin);\n        return plugin;\n    }\n\n    /**\n     * Get a previously added plugin by class.\n     */\n    getPlugin<T>(Plugin: new (...args: any[]) => T): T | undefined {\n        return this.plugins.get(Plugin.name) as T | undefined;\n    }\n\n    /**\n     * Current frame number.\n     */\n    get frame(): number {\n        return this.currentFrame;\n    }\n\n    /**\n     * Deterministic time in milliseconds.\n     * Use this instead of Date.now() for game logic.\n     *\n     * @example\n     * const RESPAWN_TIME = 3000; // 3 seconds\n     * deadPlayers.set(clientId, game.time + RESPAWN_TIME);\n     * if (game.time >= respawnTime) spawnPlayer(clientId);\n     */\n    get time(): number {\n        return this.currentFrame * this.tickIntervalMs;\n    }\n\n    // ==========================================\n    // Entity Definition API\n    // ==========================================\n\n    /**\n     * Define a new entity type.\n     *\n     * @example\n     * const Cell = game.defineEntity('cell')\n     *     .with(Transform2D)\n     *     .with(Body2D, { shapeType: 1, radius: 20 })\n     *     .with(Player);\n     */\n    defineEntity(name: string): GameEntityBuilder {\n        return new GameEntityBuilder(this, name);\n    }\n\n    /**\n     * Register a prefab (internal).\n     */\n    _registerPrefab(name: string, builder: EntityBuilder): Prefab {\n        const prefab = new Prefab(this, name, builder);\n        this.prefabs.set(name, prefab);\n        return prefab;\n    }\n\n    // ==========================================\n    // Entity Spawning\n    // ==========================================\n\n    /**\n     * Spawn an entity.\n     *\n     * @param type Entity type name\n     * @param props Property overrides\n     */\n    spawn(type: string, props: Record<string, any> = {}): Entity {\n        // Convert string clientId to number\n        let numericProps = { ...props };\n        if (props.clientId && typeof props.clientId === 'string') {\n            numericProps.clientId = this.internClientId(props.clientId);\n        }\n\n        return this.world.spawn(type, numericProps);\n    }\n\n    /**\n     * Get a prefab by name.\n     */\n    getPrefab(name: string): Prefab | undefined {\n        return this.prefabs.get(name);\n    }\n\n    // ==========================================\n    // Query API\n    // ==========================================\n\n    /**\n     * Query entities by type.\n     */\n    query(type: string): QueryIterator<Entity> {\n        return this.world.query(type);\n    }\n\n    /**\n     * Get entities by type as array.\n     */\n    getEntitiesByType(type: string): Entity[] {\n        return this.world.query(type).toArray();\n    }\n\n    /**\n     * Get all entities.\n     */\n    getAllEntities(): Entity[] {\n        return this.world.getAllEntities();\n    }\n\n    /**\n     * Get entity by client ID.\n     */\n    getEntityByClientId(clientId: string): Entity | null {\n        const numId = this.clientIdToNum.get(clientId);\n        if (numId === undefined) return null;\n        return this.world.getEntityByClientId(numId);\n    }\n\n    /**\n     * Get player by client ID (alias for getEntityByClientId).\n     */\n    getPlayer(clientId: string): Entity | null {\n        return this.getEntityByClientId(clientId);\n    }\n\n    /**\n     * Get all players (entities with Player component).\n     */\n    getPlayers(): Entity[] {\n        return this.world.query(Player).toArray();\n    }\n\n    // ==========================================\n    // System API\n    // ==========================================\n\n    /**\n     * Add a system.\n     */\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\n        return this.world.addSystem(fn, options);\n    }\n\n    // ==========================================\n    // Collision API\n    // ==========================================\n\n    /**\n     * Register a collision handler.\n     */\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this {\n        if (this.physics) {\n            this.physics.onCollision(typeA, typeB, handler);\n        } else {\n            const key = `${typeA}:${typeB}`;\n            this.collisionHandlers.set(key, handler);\n        }\n        return this;\n    }\n\n    // ==========================================\n    // String Interning\n    // ==========================================\n\n    /**\n     * Intern a client ID string, get back a number.\n     * Creates a new mapping if one doesn't exist.\n     */\n    internClientId(clientId: string): number {\n        let num = this.clientIdToNum.get(clientId);\n        if (num === undefined) {\n            num = this.nextClientNum++;\n            this.clientIdToNum.set(clientId, num);\n            this.numToClientId.set(num, clientId);\n        }\n        return num;\n    }\n\n    /**\n     * Get the numeric ID for a client ID string without creating a new mapping.\n     */\n    getClientIdNum(clientId: string): number | undefined {\n        return this.clientIdToNum.get(clientId);\n    }\n\n    /**\n     * Get client ID string from number.\n     */\n    getClientIdString(num: number): string | undefined {\n        return this.numToClientId.get(num);\n    }\n\n    /**\n     * Intern any string in a namespace.\n     */\n    internString(namespace: string, str: string): number {\n        return this.world.internString(namespace, str);\n    }\n\n    /**\n     * Get string by ID from namespace.\n     */\n    getString(namespace: string, id: number): string | null {\n        return this.world.getString(namespace, id);\n    }\n\n    // ==========================================\n    // State Management\n    // ==========================================\n\n    /**\n     * Get deterministic state hash.\n     * Returns 4-byte unsigned integer (xxhash32).\n     */\n    getStateHash(): number {\n        return this.world.getStateHash();\n    }\n\n    /**\n     * Get deterministic state hash as hex string (for debugging).\n     * @deprecated Use getStateHash() which returns a number.\n     */\n    getStateHashHex(): string {\n        return this.world.getStateHashHex();\n    }\n\n    /**\n     * Reset game state.\n     */\n    reset(): void {\n        this.world.reset();\n        this.currentFrame = 0;\n    }\n\n    /**\n     * Configure the game with callbacks.\n     *\n     * This method stores callbacks but does NOT start the game.\n     * Use this when you want to configure callbacks separately from starting.\n     *\n     * @example\n     * game.init({\n     *     onRoomCreate() { spawnFood(); },\n     *     onConnect(clientId) { spawnPlayer(clientId); }\n     * });\n     * game.start();  // Start locally\n     * // Later...\n     * game.connect(roomId);  // Connect to server\n     *\n     * @param callbacks Game lifecycle callbacks\n     * @returns The game instance for chaining\n     */\n    init(callbacks: GameCallbacks): this {\n        this.callbacks = { ...this.callbacks, ...callbacks };\n        return this;\n    }\n\n    /**\n     * Start the game locally (offline mode).\n     *\n     * Use this for single-player or when you want to start the game\n     * before connecting to a server. The game will simulate locally\n     * at the configured tick rate.\n     *\n     * If you later call connect(), the local state will be REPLACED\n     * by the server state (clean handoff, no merge).\n     *\n     * @param callbacks Optional callbacks (onTick, render, etc.). If provided,\n     *                  these are merged with any callbacks set via init().\n     */\n    start(callbacks: GameCallbacks = {}): void {\n        // Merge callbacks (init() callbacks are preserved, start() callbacks override)\n        this.callbacks = { ...this.callbacks, ...callbacks };\n\n        // Generate a local client ID for offline play\n        const localClientId = 'local-' + Math.random().toString(36).substring(2, 10);\n        this.localClientIdStr = localClientId;\n\n        // Call onRoomCreate for initial setup (like spawning world entities)\n        if (this.callbacks.onRoomCreate) {\n            this.callbacks.onRoomCreate();\n        }\n        this.localRoomCreated = true;\n\n        // Call onConnect for the local player (spawns player entity)\n        if (this.callbacks.onConnect) {\n            this.callbacks.onConnect(localClientId);\n        }\n\n        // Start the game loop (will tick locally since no connection)\n        this.startGameLoop();\n\n        // Mark game as started\n        this.gameStarted = true;\n\n        console.log('[ecs] Started in local/offline mode with clientId:', localClientId);\n    }\n\n    // ==========================================\n    // Network Connection\n    // ==========================================\n\n    /**\n     * Connect to a multiplayer room.\n     *\n     * Can be called in several ways:\n     *\n     * **Mode 1: Online-only (callbacks in connect)**\n     * ```js\n     * game.connect(roomId, {\n     *     onRoomCreate() { spawnFood(); },\n     *     onConnect(clientId) { spawnPlayer(clientId); }\n     * });\n     * ```\n     * This auto-starts locally, then connects to server.\n     *\n     * **Mode 2: Local-first with seamless transition**\n     * ```js\n     * game.init({ onRoomCreate, onConnect });\n     * game.start();  // Play locally immediately\n     * game.connect(roomId);  // Server state replaces local state\n     * ```\n     *\n     * **Mode 3: Using options parameter**\n     * ```js\n     * game.connect(roomId, { onRoomCreate, onConnect }, { nodeUrl: '...' });\n     * ```\n     *\n     * When called after start(), the local state is FLUSHED and REPLACED with server state.\n     * This is a clean handoff - no state merging.\n     *\n     * @param roomId The room to connect to\n     * @param callbacksOrOptions Either GameCallbacks or ConnectOptions\n     * @param options ConnectOptions (only if second param is callbacks)\n     */\n    async connect(\n        roomId: string,\n        callbacksOrOptions?: GameCallbacks | ConnectOptions,\n        options?: ConnectOptions\n    ): Promise<void> {\n        // Handle overloaded signatures:\n        // connect(roomId)\n        // connect(roomId, callbacks)\n        // connect(roomId, options)\n        // connect(roomId, callbacks, options)\n        let callbacks: GameCallbacks = {};\n        let connectOptions: ConnectOptions = {};\n\n        if (callbacksOrOptions) {\n            // Check if it's ConnectOptions (has nodeUrl, centralServiceUrl, or joinToken)\n            const isConnectOptions = 'nodeUrl' in callbacksOrOptions ||\n                                     'centralServiceUrl' in callbacksOrOptions ||\n                                     'joinToken' in callbacksOrOptions;\n\n            if (isConnectOptions) {\n                // connect(roomId, options) - no callbacks\n                connectOptions = callbacksOrOptions as ConnectOptions;\n            } else {\n                // connect(roomId, callbacks) or connect(roomId, callbacks, options)\n                callbacks = callbacksOrOptions as GameCallbacks;\n                connectOptions = options || {};\n            }\n        }\n\n        // Merge callbacks (preserve existing from init()/start() if any)\n        this.callbacks = { ...this.callbacks, ...callbacks };\n\n        // Allow URL params to override (for testing)\n        if (typeof window !== 'undefined') {\n            const params = new URLSearchParams(window.location.search);\n            if (params.get('room')) roomId = params.get('room')!;\n            if (params.get('nodeUrl')) connectOptions.nodeUrl = params.get('nodeUrl')!;\n        }\n\n        this.connectedRoomId = roomId;\n\n        // Track if we started locally before this connect() call\n        const wasStartedLocally = this.gameStarted;\n\n        if (wasStartedLocally) {\n            // LOCAL-FIRST MODE: start() was called first\n            // Game is already running locally - just connect to server in background\n            // When server connects, local state will be REPLACED with server state\n            console.log(`[ecs] Connecting to room \"${roomId}\"... (local game will be replaced with server state)`);\n        } else {\n            // ONLINE-FIRST MODE: connect() called without start()\n            // Start game locally while waiting for server connection\n            console.log(`[ecs] Starting game locally, connecting to room \"${roomId}\" in background...`);\n\n            // Generate a temporary local clientId for offline play\n            const localClientId = 'local-' + Math.random().toString(36).substring(2, 10);\n            this.localClientIdStr = localClientId;\n\n            // Call onRoomCreate immediately for local play (spawns world entities like food)\n            if (this.callbacks.onRoomCreate) {\n                this.callbacks.onRoomCreate();\n                this.localRoomCreated = true;\n            }\n\n            // NOTE: Don't call onConnect locally in online-first mode\n            // Player spawns when real server connection happens\n            // This avoids duplicate players and state divergence\n\n            // Mark game as started\n            this.gameStarted = true;\n        }\n\n        // Start the game loop if not already running\n        this.startGameLoop();\n\n        // Get network SDK (only available in browser)\n        const network: NetworkSDK | undefined = typeof window !== 'undefined'\n            ? (window as any).moduNetwork\n            : undefined;\n        if (!network) {\n            console.warn('[ecs] moduNetwork not found - running in offline mode');\n            return;\n        }\n\n        // Add promise timeout tracking for debugging hangs\n        const connectStartTime = typeof performance !== 'undefined' ? performance.now() : Date.now();\n\n        try {\n            this.connection = await network.connect(roomId, {\n                nodeUrl: connectOptions.nodeUrl,\n                centralServiceUrl: connectOptions.centralServiceUrl,\n                appId: 'dev',\n                joinToken: connectOptions.joinToken,\n\n                onConnect: (\n                    snapshot: any,\n                    inputs: ServerInput[],\n                    frame: number,\n                    nodeUrl: string | null,\n                    fps: number,\n                    clientId: string\n                ) => {\n                    this.handleConnect(snapshot, inputs, frame, fps, clientId);\n                },\n\n                onTick: (frame: number, inputs: ServerInput[], _snapshotFrame?: number, _snapshotHash?: string, majorityHash?: number) => {\n                    this.handleTick(frame, inputs, majorityHash);\n                },\n\n                onDisconnect: () => {\n                    this.handleDisconnect();\n                },\n\n                onBinarySnapshot: (data: Uint8Array) => {\n                    this.handleServerSnapshot(data);\n                },\n\n                onError: (error: string) => {\n                    console.error('[ecs] Network error:', error);\n                }\n            });\n\n            const connectDuration = (typeof performance !== 'undefined' ? performance.now() : Date.now()) - connectStartTime;\n            console.log(`[ecs] Connected successfully in ${connectDuration.toFixed(0)}ms, clientId: ${this.connection.clientId}`);\n\n            this.localClientIdStr = this.connection.clientId;\n\n            // Set up state sync callbacks (using 'in' check since properties may be undefined)\n            if ('onReliabilityUpdate' in this.connection) {\n                this.connection.onReliabilityUpdate = (scores: Record<string, number>, version: number) => {\n                    this.handleReliabilityUpdate(scores, version);\n                };\n            }\n            if ('onMajorityHash' in this.connection) {\n                this.connection.onMajorityHash = (frame: number, hash: number) => {\n                    this.handleMajorityHash(frame, hash);\n                };\n            }\n            if ('onResyncSnapshot' in this.connection) {\n                this.connection.onResyncSnapshot = (data: Uint8Array, frame: number) => {\n                    this.handleResyncSnapshot(data, frame);\n                };\n            }\n        } catch (err: any) {\n            const connectDuration = (typeof performance !== 'undefined' ? performance.now() : Date.now()) - connectStartTime;\n            console.error(`[ecs] Connection failed after ${connectDuration.toFixed(0)}ms:`, err?.message || err);\n            console.error('[ecs] Make sure the server is running. Check: 1) Central service on port 9001, 2) Node server');\n            this.connection = null;\n            this.connectedRoomId = null;\n        }\n    }\n\n    /**\n     * Handle reliability score update from server.\n     */\n    private handleReliabilityUpdate(scores: Record<string, number>, version: number): void {\n        if (version <= this.reliabilityVersion) {\n            return; // Already have this or newer\n        }\n        this.reliabilityScores = scores;\n        this.reliabilityVersion = version;\n    }\n\n    /**\n     * Handle majority hash from server (for desync detection).\n     */\n    private handleMajorityHash(frame: number, majorityHash: number): void {\n        // Compare our cached hash for this frame with majority\n        // Server sends majorityHash for frame-1 (see input-batcher.ts)\n        // We look up our cached hash for that frame from history\n\n        const localHash = this.stateHashHistory.get(frame);\n\n        if (localHash === undefined) {\n            // Haven't computed hash for this frame yet, skip\n            // This happens during initial connection or if history was pruned\n            // Rate-limit warning to avoid console spam\n            if (frame % 100 === 0) {\n                console.warn(`[state-sync] No local hash for frame ${frame} (history has ${this.stateHashHistory.size} frames)`);\n            }\n            return;\n        }\n\n        if (localHash === majorityHash) {\n            // Hash matches - track successful check\n            this.hashChecksPassed++;\n\n            // If we were desynced but now match, we've recovered\n            if (this.isDesynced && !this.resyncPending) {\n                console.log(`[state-sync] Recovered from desync at frame ${frame}`);\n                this.isDesynced = false;\n            }\n        } else {\n            // Hash mismatch - desync detected\n            this.hashChecksFailed++;\n\n            // Only request resync if not already pending\n            if (!this.resyncPending) {\n                this.isDesynced = true;\n                this.desyncFrame = frame;\n                this.desyncLocalHash = localHash;\n                this.desyncMajorityHash = majorityHash;\n\n                console.error(`[state-sync] DESYNC DETECTED at frame ${frame}`);\n                console.error(`  Local hash:    ${localHash.toString(16).padStart(8, '0')}`);\n                console.error(`  Majority hash: ${majorityHash.toString(16).padStart(8, '0')}`);\n\n                // Dump local state for debugging - compare between browser tabs\n                this.dumpLocalStateForDebug(frame);\n\n                console.error(`  Requesting resync from authority...`);\n\n                // Request full state from authority for recovery\n                if (this.connection?.requestResync) {\n                    this.resyncPending = true;\n                    this.connection.requestResync();\n                } else {\n                    console.warn(`[state-sync] Cannot request resync - SDK does not support requestResync()`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handle resync snapshot from authority (hard recovery after desync).\n     * This compares state, logs detailed diff, then replaces local state.\n     */\n    private handleResyncSnapshot(data: Uint8Array, serverFrame: number): void {\n        console.warn(`[ENGINE-RESYNC] Received resync snapshot (${data.length} bytes) for frame ${serverFrame}. currentFrame=${this.currentFrame} isDesynced=${this.isDesynced}`);\n\n        // Decode the snapshot - try binary format first, then JSON fallback\n        let snapshot: any;\n        try {\n            const decoded = decode(data);\n            snapshot = decoded?.snapshot;\n            // Also restore hash from binary if available\n            if (snapshot && decoded?.hash !== undefined) {\n                snapshot.hash = decoded.hash;\n            }\n        } catch (e) {\n            // Binary decode failed, will try JSON below\n        }\n\n        // If binary decode didn't get a snapshot, try JSON format\n        // (SDK may send JSON-encoded snapshot for resync)\n        if (!snapshot) {\n            try {\n                const jsonStr = new TextDecoder().decode(data);\n                const parsed = JSON.parse(jsonStr);\n\n                // The SDK might send the snapshot in different formats:\n                // 1. { snapshot: {...} } - wrapped format with actual snapshot object\n                // 2. { snapshot: [binary array], snapshotHash: ... } - binary data as array\n                // 3. Direct snapshot object\n                let rawSnapshot = parsed?.snapshot;\n\n                // Check if rawSnapshot is binary data encoded as array (has numeric keys like 0, 1, 2...)\n                // The SDK stores binary MessagePack data which becomes a JSON object with numeric keys\n                if (rawSnapshot && typeof rawSnapshot === 'object' && !rawSnapshot.types && !rawSnapshot.entities) {\n                    const keys = Object.keys(rawSnapshot);\n                    if (keys.length > 0 && keys[0] === '0') {\n                        // It's binary data as a JSON object with numeric keys - convert and decode\n                        const binaryData = new Uint8Array(Object.values(rawSnapshot) as number[]);\n                        try {\n                            const decoded = decode(binaryData);\n                            snapshot = decoded?.snapshot;\n                            // Also get the hash from the decoded binary (it was encoded with the snapshot)\n                            if (snapshot && decoded?.hash !== undefined) {\n                                snapshot.hash = decoded.hash;\n                            }\n                        } catch (e) {\n                            // Failed to decode binary from JSON wrapper\n                        }\n                    }\n                }\n\n                if (!snapshot) {\n                    snapshot = rawSnapshot;\n                }\n\n                if (!snapshot && parsed?.types && parsed?.entities) {\n                    // Direct snapshot format (not wrapped)\n                    snapshot = parsed;\n                }\n            } catch (e) {\n                // JSON parse also failed\n            }\n        }\n\n        if (!snapshot) {\n            console.error(`[state-sync] Failed to decode resync snapshot - no snapshot data (tried binary and JSON)`);\n            this.resyncPending = false;\n            return;\n        }\n\n        // Log detailed comparison BEFORE replacing state\n        console.error(`[state-sync] === DESYNC DIAGNOSIS ===`);\n        console.error(`  Desync detected at frame: ${this.desyncFrame}`);\n        console.error(`  Resync snapshot frame: ${serverFrame}`);\n        console.error(`  Local hash at desync:    ${this.desyncLocalHash.toString(16).padStart(8, '0')}`);\n        console.error(`  Majority hash at desync: ${this.desyncMajorityHash.toString(16).padStart(8, '0')}`);\n\n        // Run field-by-field comparison to get detailed diff\n        // This uses the same logic as compareSnapshotFields but logs immediately\n        this.logDesyncDiff(snapshot, serverFrame);\n\n        // Now perform hard recovery - replace local state with authority state\n        console.log(`[state-sync] Performing hard recovery...`);\n\n        // Store the current frame before resync\n        const preResyncFrame = this.currentFrame;\n\n        // Load the authority snapshot (this resets and rebuilds world state)\n        this.loadNetworkSnapshot(snapshot);\n\n        // Update frame to match server\n        this.currentFrame = serverFrame;\n\n        // Clear the desync state\n        this.resyncPending = false;\n        this.isDesynced = false;\n\n        // Verify resync worked\n        const newLocalHash = this.world.getStateHash();\n        const serverHash = snapshot.hash;\n        if (serverHash && newLocalHash === serverHash) {\n            console.log(`[state-sync] Hard recovery successful - hash=${newLocalHash.toString(16).padStart(8, '0')}`);\n        } else if (!serverHash) {\n            // No server hash in snapshot - this is OK, we can't verify but state was loaded\n            console.log(`[state-sync] Hard recovery completed - hash=${newLocalHash.toString(16).padStart(8, '0')}`);\n        } else {\n            console.error(`[state-sync] Hard recovery hash mismatch: expected=${serverHash?.toString(16).padStart(8, '0')} got=${newLocalHash.toString(16).padStart(8, '0')}`);\n        }\n\n        // CRITICAL: Set prevSnapshot so delta computation has valid baseline after resync\n        this.prevSnapshot = this.world.getSparseSnapshot();\n\n        // CRITICAL: Initialize hash history so next majorityHash comparison works\n        // Clear old history and start fresh from this frame\n        this.stateHashHistory.clear();\n        this.stateHashHistory.set(serverFrame, newLocalHash);\n\n        // Store as last good snapshot\n        this.lastGoodSnapshot = {\n            snapshot: JSON.parse(JSON.stringify(snapshot)),\n            frame: serverFrame,\n            hash: newLocalHash\n        };\n\n        // CRITICAL: Clear clientsWithEntitiesFromSnapshot after resync\n        // loadNetworkSnapshot populates this set, but we're not doing catchup here.\n        // If left populated, future join events would incorrectly skip onConnect\n        // for clients whose entities are in this stale set.\n        this.clientsWithEntitiesFromSnapshot.clear();\n        this.clientIdsFromSnapshotMap.clear();\n        this.clientsWithDisconnectInCatchup.clear();\n\n        console.log(`[state-sync] === END RESYNC ===`);\n    }\n\n    /**\n     * Log detailed diff between local state and authority snapshot.\n     * Called during resync to help diagnose what went wrong.\n     */\n    /**\n     * Dump local state for debugging when desync is detected.\n     * Compare output between browser tabs to find differences.\n     */\n    private dumpLocalStateForDebug(frame: number): void {\n        console.group(`[DESYNC DEBUG] Local state at frame ${frame}`);\n        console.log(`Entity count: ${this.world.getAllEntities().length}`);\n\n        // Group entities by type\n        const byType = new Map<string, any[]>();\n        for (const entity of this.world.getAllEntities()) {\n            if (!byType.has(entity.type)) byType.set(entity.type, []);\n            byType.get(entity.type)!.push(entity);\n        }\n\n        // Log counts by type\n        console.log('Entity counts by type:');\n        for (const [type, entities] of byType) {\n            console.log(`  ${type}: ${entities.length}`);\n        }\n\n        // Log first few entities of dynamic types with component values\n        const dynamicTypes = ['furniture', 'player'];\n        for (const type of dynamicTypes) {\n            const entities = byType.get(type) || [];\n            if (entities.length === 0) continue;\n\n            console.group(`${type} entities (first 5):`);\n            for (let i = 0; i < Math.min(5, entities.length); i++) {\n                const e = entities[i];\n                const data: Record<string, any> = { eid: e.eid };\n                for (const comp of e.getComponents()) {\n                    if (!comp.sync) continue;\n                    const index = e.eid & 0xFFFF;\n                    for (const field of comp.fieldNames) {\n                        const key = `${comp.name}.${field}`;\n                        data[key] = comp.storage.fields[field][index];\n                    }\n                }\n                console.log(`  [${i}]`, JSON.stringify(data));\n            }\n            console.groupEnd();\n        }\n\n        console.groupEnd();\n    }\n\n    private logDesyncDiff(serverSnapshot: any, serverFrame: number): void {\n        const lines: string[] = [];\n        const diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }> = [];\n\n        const types = serverSnapshot.types || [];\n        const serverEntities = serverSnapshot.entities || [];\n        const schema = serverSnapshot.schema || [];\n\n        // Build map of server entities by eid\n        const serverEntityMap = new Map<number, any>();\n        for (const e of serverEntities) {\n            serverEntityMap.set(e[0], e);\n        }\n\n        let matchingFields = 0;\n        let totalFields = 0;\n\n        // Compare each local entity with server entity\n        for (const entity of this.world.getAllEntities()) {\n            const eid = entity.eid;\n            const serverEntity = serverEntityMap.get(eid);\n            const index = eid & INDEX_MASK;\n\n            if (!serverEntity) {\n                // Entity exists locally but not on server\n                for (const comp of entity.getComponents()) {\n                    totalFields += comp.fieldNames.length;\n                    for (const fieldName of comp.fieldNames) {\n                        diffs.push({\n                            entity: entity.type,\n                            eid,\n                            comp: comp.name,\n                            field: fieldName,\n                            local: 'EXISTS',\n                            server: 'MISSING'\n                        });\n                    }\n                }\n                continue;\n            }\n\n            const [, typeIndex, serverValues] = serverEntity;\n            const typeSchema = schema[typeIndex];\n\n            if (!typeSchema) continue;\n\n            let valueIdx = 0;\n            for (const [compName, fieldNames] of typeSchema) {\n                const localComp = entity.getComponents().find(c => c.name === compName);\n\n                for (const fieldName of fieldNames) {\n                    totalFields++;\n                    const serverValue = serverValues[valueIdx++];\n\n                    if (localComp) {\n                        const localValue = localComp.storage.fields[fieldName][index];\n                        const fieldDef = localComp.schema[fieldName];\n\n                        let valuesMatch = false;\n                        if (fieldDef?.type === 'bool') {\n                            const localBool = localValue !== 0;\n                            const serverBool = serverValue !== 0 && serverValue !== false;\n                            valuesMatch = localBool === serverBool;\n                        } else {\n                            valuesMatch = localValue === serverValue;\n                        }\n\n                        if (valuesMatch) {\n                            matchingFields++;\n                        } else {\n                            diffs.push({\n                                entity: entity.type,\n                                eid,\n                                comp: compName,\n                                field: fieldName,\n                                local: localValue,\n                                server: serverValue\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        // Check for server entities not in local state\n        for (const [eid, serverEntity] of serverEntityMap) {\n            if (this.world.getEntity(eid) === null) {\n                const [, typeIndex, serverValues] = serverEntity;\n                const serverType = types[typeIndex] || `type${typeIndex}`;\n                totalFields += serverValues.length;\n                diffs.push({\n                    entity: serverType,\n                    eid,\n                    comp: '*',\n                    field: '*',\n                    local: 'MISSING',\n                    server: 'EXISTS'\n                });\n            }\n        }\n\n        // Build readable output\n        const syncPercent = totalFields > 0 ? (matchingFields / totalFields) * 100 : 100;\n\n        lines.push(`DIVERGENT FIELDS: ${diffs.length} differences found`);\n        lines.push(`  Sync: ${syncPercent.toFixed(1)}% (${matchingFields}/${totalFields} fields match)`);\n        lines.push(``);\n\n        // Try to find entity owners\n        const entityOwners = new Map<number, string>();\n        for (const entity of this.world.getAllEntities()) {\n            if (entity.has(Player)) {\n                const playerData = entity.get(Player);\n                const ownerClientId = this.numToClientId.get(playerData.clientId);\n                if (ownerClientId) {\n                    entityOwners.set(entity.eid, ownerClientId.slice(0, 8));\n                }\n            }\n        }\n\n        // Group diffs by entity for readability\n        const diffsByEntity = new Map<number, typeof diffs>();\n        for (const d of diffs) {\n            if (!diffsByEntity.has(d.eid)) {\n                diffsByEntity.set(d.eid, []);\n            }\n            diffsByEntity.get(d.eid)!.push(d);\n        }\n\n        for (const [eid, entityDiffs] of diffsByEntity) {\n            const first = entityDiffs[0];\n            const owner = entityOwners.get(eid);\n            const ownerStr = owner ? ` [owner: ${owner}]` : '';\n            lines.push(`  ${first.entity}#${eid.toString(16)}${ownerStr}:`);\n\n            for (const d of entityDiffs) {\n                const delta = typeof d.local === 'number' && typeof d.server === 'number'\n                    ? ` (\u0394 ${(d.local - d.server).toFixed(4)})`\n                    : '';\n                lines.push(`    ${d.comp}.${d.field}: local=${d.local} server=${d.server}${delta}`);\n            }\n        }\n\n        if (diffs.length === 0) {\n            lines.push(`  No field differences found (hash mismatch may be due to RNG or string state)`);\n        }\n\n        // Log recent inputs that may have caused the divergence\n        const recentInputCount = Math.min(this.recentInputs.length, 20);\n        if (recentInputCount > 0) {\n            lines.push(``);\n            lines.push(`RECENT INPUTS (last ${recentInputCount}):`);\n            const recent = this.recentInputs.slice(-recentInputCount);\n            for (const input of recent) {\n                const shortId = input.clientId.slice(0, 8);\n                lines.push(`  f${input.frame} [${shortId}]: ${JSON.stringify(input.data)}`);\n            }\n        }\n\n        console.error(lines.join('\\n'));\n    }\n\n    /**\n     * Handle initial connection (first join or late join).\n     */\n    private handleConnect(\n        snapshot: any,\n        inputs: ServerInput[],\n        frame: number,\n        fps: number,\n        clientId: string\n    ): void {\n        // Decode binary snapshot if needed\n        let snapshotSize = 0;\n        if (snapshot instanceof Uint8Array) {\n            snapshotSize = snapshot.length;\n            if (snapshot.length < 2) {\n                snapshot = null;\n            } else {\n                try {\n                    const decoded = decode(snapshot);\n                    snapshot = decoded?.snapshot || null;\n                    // CRITICAL: Preserve hash from binary encoding for verification\n                    if (snapshot && decoded?.hash !== undefined) {\n                        snapshot.hash = decoded.hash;\n                    }\n                } catch (e) {\n                    console.error('[ecs] Failed to decode snapshot:', e);\n                    snapshot = null;\n                }\n            }\n        }\n\n        // Store connection state\n        this.localClientIdStr = clientId;\n        this.serverFps = fps;\n        this.tickIntervalMs = 1000 / fps;\n        this.currentFrame = frame;\n\n        // Store snapshot hash for debug UI\n        if (snapshot?.hash !== undefined) {\n            this.lastSnapshotHash = typeof snapshot.hash === 'number'\n                ? snapshot.hash\n                : parseInt(String(snapshot.hash), 16) || 0;\n            this.lastSnapshotFrame = snapshot.frame || frame;\n            this.lastSnapshotSize = snapshotSize;\n            this.lastSnapshotEntityCount = snapshot.entities?.length || 0;\n        }\n\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Connected as ${clientId}, frame ${frame}, fps ${fps}`);\n            console.log(`[ecs] Snapshot:`, snapshot ? { frame: snapshot.frame, entityCount: snapshot.entities?.length } : 'none');\n            console.log(`[ecs] Inputs: ${inputs.length}`);\n        }\n\n        const hasValidSnapshot = snapshot?.entities && snapshot.entities.length > 0;\n\n        if (hasValidSnapshot) {\n            // === LATE JOINER PATH ===\n            // NOTE: We do NOT pre-intern clientIds from join inputs here.\n            // The snapshot's clientIdMap already contains all mappings we need.\n            // Pre-interning caused desync because different clients had different\n            // pre-existing state, leading to divergent nextClientNum values.\n\n            const snapshotSeq = snapshot.seq || 0;\n\n            // Restore snapshot (clientIdMap restores numToClientId for clientsWithEntitiesFromSnapshot)\n            this.currentFrame = snapshot.frame || frame;\n\n            this.loadNetworkSnapshot(snapshot);\n            // Verify loaded state hash matches expected (from authority)\n            const loadedHash = this.world.getStateHash();\n            const expectedHash = snapshot.hash;\n            if (expectedHash !== undefined && loadedHash !== expectedHash) {\n                console.error(`[SNAPSHOT] HASH MISMATCH! loaded=0x${loadedHash.toString(16)} expected=0x${expectedHash?.toString(16)}`);\n            }\n\n            // Isolate RNG for onSnapshot callback\n            const rngStateSnapshot = saveRandomState();\n            if (this.callbacks.onSnapshot) {\n                this.callbacks.onSnapshot(this.world.getAllEntities());\n            }\n\n            loadRandomState(rngStateSnapshot);\n\n            // Filter inputs - always include lifecycle events, others only if after snapshot\n            const getInputType = (input: ServerInput): string | undefined => {\n                let data = input.data;\n                if (data instanceof Uint8Array) {\n                    try { data = decode(data); } catch { return undefined; }\n                }\n                return data?.type;\n            };\n\n            const pendingInputs = inputs\n                .filter(i => i.seq > snapshotSeq)\n                .sort((a, b) => a.seq - b.seq);\n\n            // Process lifecycle events before catchup so player exists immediately\n            for (const input of pendingInputs) {\n                const inputType = getInputType(input);\n                if (inputType === 'join' || inputType === 'reconnect' || inputType === 'disconnect' || inputType === 'leave') {\n                    this.processInput(input);\n                }\n            }\n\n            // 6. Run catchup simulation\n            const snapshotFrame = this.currentFrame;\n            const isPostTick = snapshot.postTick === true;\n            const startFrame = isPostTick ? snapshotFrame + 1 : snapshotFrame;\n            const ticksToRun = frame - startFrame + 1;\n\n            // CRITICAL: Limit catchup to prevent performance issues\n            // If too many frames need to be simulated, request a fresh snapshot instead\n            const MAX_CATCHUP_FRAMES = 200; // ~10 seconds at 20Hz tick rate\n            if (ticksToRun > MAX_CATCHUP_FRAMES) {\n                console.warn(`[CATCHUP] Too many frames to catch up (${ticksToRun} > ${MAX_CATCHUP_FRAMES}). Requesting fresh snapshot.`);\n\n                // Request fresh snapshot from authority - don't use stale state\n                if (this.connection?.requestResync) {\n                    this.connection.requestResync();\n                }\n\n                // Player lifecycle events already processed above, so player exists.\n                // Set up minimal state so game loop can run while waiting for resync.\n                this.currentFrame = frame;\n                this.lastProcessedFrame = frame;\n                this.prevSnapshot = this.world.getSparseSnapshot();\n                this.startGameLoop();\n                return;\n            }\n\n            // Run catchup simulation\n            if (ticksToRun > 0) {\n                this.runCatchup(startFrame, frame, pendingInputs);\n            }\n\n            this.snapshotLoadedFrame = this.currentFrame;  // Track for debug timing\n\n            // CRITICAL: Set prevSnapshot after catchup so delta computation has a valid baseline\n            // Without this, late joiner's first delta would compare against stale/null snapshot\n            this.prevSnapshot = this.world.getSparseSnapshot();\n\n            // Store as last good snapshot - we just loaded authority's state\n            this.lastGoodSnapshot = {\n                snapshot: JSON.parse(JSON.stringify(snapshot)),\n                frame: this.currentFrame,\n                hash: this.getStateHash()\n            };\n\n        } else {\n            // === FIRST JOINER PATH ===\n            if (DEBUG_NETWORK) console.log('[ecs] First join: creating room');\n\n            this.currentFrame = frame;\n\n            // First joiner is always authority\n            this.authorityClientId = clientId;\n            // Add to activeClients for state sync\n            if (!this.activeClients.includes(clientId)) {\n                this.activeClients.push(clientId);\n                this.activeClients.sort();\n            }\n\n            // LOCAL-FIRST HANDOFF: If start() was called before connect(),\n            // flush local state and recreate fresh with server identity.\n            // This ensures entity IDs and clientId match server expectations.\n            if (this.localRoomCreated) {\n                console.log('[ecs] Local-first handoff: flushing local state, recreating with server identity');\n\n                // Reset world state (clears all entities, ID allocator, etc.)\n                this.world.reset();\n                if (this.physics) {\n                    this.physics.clear();\n                }\n\n                // Clear local state tracking\n                this.clientIdToNum.clear();\n                this.numToClientId.clear();\n                this.nextClientNum = 1;\n                this.activeClients = [clientId];\n                this.stateHashHistory.clear(); // Clear old local hashes to prevent false desync\n                this.localRoomCreated = false; // Reset so callbacks run fresh\n\n                // Recreate room with fresh state\n                this.callbacks.onRoomCreate?.();\n                this.localRoomCreated = true;\n            } else {\n                // Normal path: connect() called without start()\n                this.callbacks.onRoomCreate?.();\n            }\n\n            // Process all inputs (may include our own join event which calls onConnect)\n            for (const input of inputs) {\n                this.processInput(input);\n            }\n\n            // CRITICAL: Run initial tick to execute systems and compute initial hash\n            // Without this, entities are created but systems never run for frame 0,\n            // causing hash mismatch when server sends majorityHash for frame 0\n            this.world.tick(frame, []);\n            this.lastProcessedFrame = frame;\n\n            // Record initial hash so we have it when server sends majorityHash\n            const initialHash = this.world.getStateHash();\n            this.stateHashHistory.set(frame, initialHash);\n        }\n\n        // Send initial snapshot if we're authority\n        if (this.checkIsAuthority()) {\n            this.sendSnapshot('init');\n        }\n\n        // Start game loop\n        this.startGameLoop();\n        console.log(`[ecs] Game loop started, waiting for server TICK messages...`);\n    }\n\n    /**\n     * Handle server tick.\n     */\n    private handleTick(frame: number, inputs: ServerInput[], majorityHash?: number): void {\n        // Skip frames we've already processed (e.g., during catchup)\n        if (frame <= this.lastProcessedFrame) {\n            if (DEBUG_NETWORK) {\n                console.log(`[ecs] Skipping old frame ${frame} (already at ${this.lastProcessedFrame})`);\n            }\n            return;\n        }\n\n        this.currentFrame = frame;\n        this.lastProcessedFrame = frame;\n\n        if (DEBUG_NETWORK && inputs.length > 0) {\n            const types = inputs.map(i => i.data?.type || 'game').join(',');\n            console.log(`[ecs] onTick frame=${frame}: ${inputs.length} inputs (${types})`);\n        }\n\n        // 1. Process all inputs for this frame (sorted by seq for determinism)\n        // Multiple inputs can arrive in a single tick - seq determines order\n        const sortedInputs = inputs.length > 1\n            ? [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0))\n            : inputs;\n\n        for (const input of sortedInputs) {\n            this.processInput(input);\n        }\n\n        // 2. Run ECS world tick (systems)\n        this.world.tick(frame, []);\n\n        // Record state hash for desync detection\n        const hashAfter = this.world.getStateHash();\n\n        // 3. Call game's onTick callback\n        this.callbacks.onTick?.(frame);\n\n        // 4. Send deferred snapshot if pending\n        if (this.pendingSnapshotUpload && this.checkIsAuthority()) {\n            this.sendSnapshot('join');\n            this.pendingSnapshotUpload = false;\n        }\n\n        // 5. Record tick time for interpolation\n        this.lastTickTime = typeof performance !== 'undefined' ? performance.now() : Date.now();\n\n        // 6. Check for desync using majority hash from server\n        // Server sends majorityHash for frame-1 (see input-batcher.ts getMajorityHash call)\n        // We compare against our cached hash for the same frame\n        if (majorityHash !== undefined && majorityHash !== 0) {\n            const hashFrame = frame - 1;  // Must match server's offset in input-batcher.ts\n            this.handleMajorityHash(hashFrame, majorityHash);\n        } else if (this.activeClients.length > 1 && frame % 100 === 0) {\n            // Log when we expect majorityHash but don't receive it (only in multiplayer)\n            console.warn(`[state-sync] No majorityHash in tick ${frame} (expected with ${this.activeClients.length} clients)`);\n        }\n\n        // 7. Send state sync data (stateHash + partition data if assigned)\n        // This must happen AFTER desync check so the cache is still valid\n        this.sendStateSync(frame);\n    }\n\n    /**\n     * Send state synchronization data after tick.\n     * Sends stateHash to server, and partition data if this client is assigned.\n     */\n    private sendStateSync(frame: number): void {\n        if (!this.stateSyncEnabled || !this.connection?.sendStateHash) {\n            return;\n        }\n\n        // Update delta bandwidth sampling (every second)\n        const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\n        if (now - this.deltaBytesSampleTime >= 1000) {\n            this.deltaBytesPerSecond = this.deltaBytesThisSecond;\n            this.deltaBytesThisSecond = 0;\n            this.deltaBytesSampleTime = now;\n        }\n\n        // Compute and send state hash (9 bytes: 1 type + 4 frame + 4 hash)\n        const stateHash = this.world.getStateHash();\n        this.connection.sendStateHash(frame, stateHash);\n        this.deltaBytesThisSecond += 9;\n\n        // Cache hash in history for desync comparison\n        // (majorityHash for this frame will arrive in a future tick)\n        this.stateHashHistory.set(frame, stateHash);\n        // Prune old entries to limit memory usage\n        if (this.stateHashHistory.size > this.HASH_HISTORY_SIZE) {\n            const oldestFrame = frame - this.HASH_HISTORY_SIZE;\n            for (const f of this.stateHashHistory.keys()) {\n                if (f <= oldestFrame) {\n                    this.stateHashHistory.delete(f);\n                }\n            }\n        }\n\n        // Always update prevSnapshot for delta comparison (even when alone)\n        const currentSnapshot = this.world.getSparseSnapshot();\n\n        // Partition-based delta sync: send only changed entity data for assigned partitions\n        // Skip when alone - no one else needs the delta data\n        if (this.activeClients.length > 1 && this.connection.clientId && this.connection.sendPartitionData && this.prevSnapshot) {\n            // Compute delta between previous and current state\n            const delta = computeStateDelta(this.prevSnapshot, currentSnapshot);\n\n            const deltaSize = getDeltaSize(delta);\n\n            // Log delta stats (once per second) - only when there's activity\n            if (frame % 60 === 0 && !isDeltaEmpty(delta)) {\n                console.log(`[delta] frame=${frame} created=${delta.created.length} deleted=${delta.deleted.length} bytes=${deltaSize}`);\n            }\n\n            // Only send if there are actual changes\n            if (!isDeltaEmpty(delta)) {\n                const entityCount = this.world.entityCount;\n                const numPartitions = computePartitionCount(entityCount, this.activeClients.length);\n\n                const assignment = computePartitionAssignment(\n                    entityCount,\n                    this.activeClients,\n                    frame,\n                    this.reliabilityScores\n                );\n\n                const myPartitions = getClientPartitions(assignment, this.connection.clientId);\n\n                for (const partitionId of myPartitions) {\n                    // Check if this partition has any actual changes before serializing\n                    const hasChangesInPartition =\n                        delta.created.some(e => (e.eid % numPartitions) === partitionId) ||\n                        delta.deleted.some(eid => (eid % numPartitions) === partitionId);\n\n                    if (hasChangesInPartition) {\n                        const partitionData = getPartition(delta, partitionId, numPartitions);\n                        this.connection.sendPartitionData(frame, partitionId, partitionData);\n                        this.deltaBytesThisSecond += 8 + partitionData.length;\n                    }\n                }\n            }\n        }\n\n        this.prevSnapshot = currentSnapshot;\n    }\n\n    /**\n     * Process a network input (join/leave/game).\n     */\n    private processInput(input: ServerInput): void {\n        // Decode binary data if needed\n        let data = input.data;\n        if (data instanceof Uint8Array) {\n            try {\n                data = decode(data);\n            } catch (e) {\n                console.warn('[ecs] Failed to decode input:', e);\n                return;\n            }\n        }\n\n        const clientId = data?.clientId || input.clientId;\n        const type = data?.type;\n\n        // Track input for divergence debugging (keep last 500)\n        this.recentInputs.push({\n            frame: this.currentFrame,\n            seq: input.seq,\n            clientId,\n            data: JSON.parse(JSON.stringify(data))\n        });\n        if (this.recentInputs.length > 500) {\n            this.recentInputs.shift();\n        }\n\n        // Track input sequence\n        if (input.seq > this.lastInputSeq) {\n            this.lastInputSeq = input.seq;\n        }\n\n        if (type === 'join') {\n            const wasActive = this.activeClients.includes(clientId);\n            if (!wasActive) {\n                this.activeClients.push(clientId);\n                this.activeClients.sort();\n            }\n\n            if (this.authorityClientId === null) {\n                this.authorityClientId = clientId;\n            }\n\n            // Isolate RNG for callback\n            const rngState = saveRandomState();\n            this.callbacks.onConnect?.(clientId);\n            loadRandomState(rngState);\n\n            // Mark snapshot needed\n            if (this.checkIsAuthority()) {\n                this.pendingSnapshotUpload = true;\n            }\n        } else if (type === 'resync_request') {\n            // Another client is requesting resync - authority should upload fresh snapshot\n            // This ensures resyncing clients get current state, not stale stored snapshot\n            if (this.checkIsAuthority()) {\n                this.pendingSnapshotUpload = true;\n            }\n        } else if (type === 'leave' || type === 'disconnect') {\n            // Remove from activeClients\n            const activeIdx = this.activeClients.indexOf(clientId);\n            if (activeIdx !== -1) {\n                this.activeClients.splice(activeIdx, 1);\n            }\n\n            if (clientId === this.authorityClientId) {\n                this.authorityClientId = this.activeClients[0] || null;\n            }\n\n            this.clientsWithEntitiesFromSnapshot.delete(clientId);\n\n            // Isolate RNG for callback\n            const rngStateDisconnect = saveRandomState();\n            this.callbacks.onDisconnect?.(clientId);\n            loadRandomState(rngStateDisconnect);\n\n            // CRITICAL FIX: Upload snapshot after disconnect so late joiners get updated state.\n            if (this.checkIsAuthority()) {\n                this.pendingSnapshotUpload = true;\n            }\n        } else if (data) {\n            // Game input - store in world's input registry\n            this.routeInputToEntity(clientId, data);\n        }\n    }\n\n    /**\n     * Route game input to the world's input registry for systems to read.\n     */\n    private routeInputToEntity(clientId: string, data: any): void {\n        const numId = this.internClientId(clientId);\n\n        // Always store input in registry - systems query by clientId, not entity\n        // This supports games where one clientId maps to multiple entities (e.g., split cells)\n        this.world.setInput(numId, data);\n\n        if (DEBUG_NETWORK) {\n            const entity = this.world.getEntityByClientId(numId);\n            console.log(`[ecs] routeInput: clientId=${clientId.slice(0, 8)}, numId=${numId}, entity=${entity?.eid || 'null'}, data=${JSON.stringify(data)}`);\n        }\n    }\n\n    /**\n     * Process input for authority chain only (no game logic).\n     */\n    private processAuthorityChainInput(input: ServerInput): void {\n        let data = input.data;\n        if (data instanceof Uint8Array) {\n            try { data = decode(data); } catch { return; }\n        }\n\n        const clientId = data?.clientId || input.clientId;\n        const type = data?.type;\n\n        if (type === 'join') {\n            if (!this.activeClients.includes(clientId)) {\n                this.activeClients.push(clientId);\n                this.activeClients.sort();\n            }\n            if (this.authorityClientId === null) {\n                this.authorityClientId = clientId;\n            }\n        } else if (type === 'leave' || type === 'disconnect') {\n            // Remove from activeClients\n            const activeIdx = this.activeClients.indexOf(clientId);\n            if (activeIdx !== -1) {\n                this.activeClients.splice(activeIdx, 1);\n            }\n            if (clientId === this.authorityClientId) {\n                this.authorityClientId = this.activeClients[0] || null;\n            }\n        }\n    }\n\n    /**\n     * Run catchup simulation.\n     */\n    private runCatchup(startFrame: number, endFrame: number, inputs: ServerInput[]): void {\n        const ticksToRun = endFrame - startFrame + 1;\n\n        // CRITICAL: Sort all inputs by seq to ensure correct order within frames\n        // Multiple inputs can occur in a single frame - seq determines order\n        const sortedInputs = [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0));\n\n        // NOTE: Stale JOIN detection has been REMOVED.\n        // Previously we pre-scanned to skip JOINs that would be followed by DISCONNECTs.\n        // But skipping JOINs causes allocator divergence (entity IDs not allocated, so\n        // generations don't increment when DISCONNECT frees them).\n        // Now we process ALL JOINs and let DISCONNECTs handle cleanup naturally.\n\n        // Build map of frame -> inputs for that frame (sorted by seq)\n        const inputsByFrame = new Map<number, ServerInput[]>();\n        for (const input of sortedInputs) {\n            // CRITICAL: Inputs MUST have explicit frames for deterministic catchup.\n            // If input.frame is undefined, different clients would assign different frames\n            // (based on their local endFrame), causing desync.\n            // Skip frameless inputs during catchup - they'll be processed in normal ticks.\n            if (input.frame === undefined || input.frame === null) {\n                continue;\n            }\n\n            const rawFrame = input.frame;\n\n            // CRITICAL: Don't process inputs that are AFTER the catchup range\n            // These should be processed during normal ticks, not catchup\n            if (rawFrame > endFrame) {\n                continue;  // Skip this input - it will come in future ticks\n            }\n\n            const frame = Math.max(rawFrame, startFrame);\n            if (!inputsByFrame.has(frame)) {\n                inputsByFrame.set(frame, []);\n            }\n            inputsByFrame.get(frame)!.push(input);\n        }\n\n        // CRITICAL: Clear old hash history before catchup\n        // We'll record hash for each catchup frame so majorityHash comparison works\n        this.stateHashHistory.clear();\n\n        // Set catchup mode so processInput knows to filter JOINs by seq\n        this.inCatchupMode = true;\n\n        // Run each tick\n        for (let f = 0; f < ticksToRun; f++) {\n            const tickFrame = startFrame + f;\n            this.currentFrame = tickFrame;  // Update so processInput records correct frame\n\n            // Process inputs for this frame (already sorted by seq)\n            const frameInputs = inputsByFrame.get(tickFrame) || [];\n            for (const input of frameInputs) {\n                this.processInput(input);\n            }\n\n            // Run world tick\n            this.world.tick(tickFrame, []);\n            const hashAfterTick = this.world.getStateHash();\n\n            // Call game's onTick\n            this.callbacks.onTick?.(tickFrame);\n\n            // CRITICAL: Record state hash for each catchup frame\n            this.stateHashHistory.set(tickFrame, hashAfterTick);\n        }\n\n        this.currentFrame = endFrame;\n        this.lastProcessedFrame = endFrame;  // Prevent re-processing old frames\n\n        // Clear the snapshot entity tracking - catchup is done\n        // Future join events should trigger onConnect normally\n        this.clientsWithEntitiesFromSnapshot.clear();\n        this.clientIdsFromSnapshotMap.clear();\n        this.clientsWithDisconnectInCatchup.clear();\n        this.inCatchupMode = false;\n    }\n\n    // ==========================================\n    // Snapshot Methods\n    // ==========================================\n\n    /**\n     * Convert ECS snapshot to network wire format.\n     */\n    private getNetworkSnapshot(): any {\n        // Format 5: Type-indexed encoding with optional syncFields\n        // - types: [\"snake-head\", \"snake-segment\", ...] - type names array\n        // - schema: [[compSchema], [compSchema], ...] - indexed by type index\n        // - entities: [[eid, typeIndex, values], ...] - typeIndex instead of string\n        // If entity type has syncFields, only those fields are included in schema/values\n\n        // Build type index and schema\n        const types: string[] = [];\n        const typeToIndex = new Map<string, number>();\n        const schema: [string, string[]][][] = [];\n        const typeSyncFields = new Map<string, Set<string>>();  // Cache syncFields per type\n        const entities: any[] = [];\n\n        for (const entity of this.world.getAllEntities()) {\n            const index = entity.eid & INDEX_MASK;\n            const type = entity.type;\n\n            // Get syncFields for this type (check if syncNone)\n            const entityDef = this.world.getEntityDef(type);\n\n            // CRITICAL: Skip syncNone entities entirely (syncFields = empty array)\n            // These are client-only entities that should NOT be in snapshots\n            if (entityDef?.syncFields && entityDef.syncFields.length === 0) {\n                continue;  // Skip this entity\n            }\n\n            // Assign type index if new type\n            if (!typeToIndex.has(type)) {\n                const typeIdx = types.length;\n                types.push(type);\n                typeToIndex.set(type, typeIdx);\n\n                // Get syncFields for this type (if defined)\n                const syncFieldsSet = entityDef?.syncFields\n                    ? new Set(entityDef.syncFields)\n                    : null;\n                typeSyncFields.set(type, syncFieldsSet!);\n\n                // Build schema for this type (only synced fields)\n                const typeSchema: [string, string[]][] = [];\n                for (const comp of entity.getComponents()) {\n                    const fieldsToSync = syncFieldsSet\n                        ? comp.fieldNames.filter(f => syncFieldsSet.has(f))\n                        : comp.fieldNames;\n                    if (fieldsToSync.length > 0) {\n                        typeSchema.push([comp.name, fieldsToSync]);\n                    }\n                }\n                schema.push(typeSchema);\n            }\n\n            // Encode values as flat array matching schema order (only synced fields)\n            const syncFieldsSet = typeSyncFields.get(type);\n            const values: any[] = [];\n            for (const comp of entity.getComponents()) {\n                for (const fieldName of comp.fieldNames) {\n                    // Only include if no syncFields defined OR field is in syncFields\n                    if (!syncFieldsSet || syncFieldsSet.has(fieldName)) {\n                        values.push(comp.storage.fields[fieldName][index]);\n                    }\n                }\n            }\n\n            entities.push([\n                entity.eid,  // eid as number (no need for hex conversion)\n                typeToIndex.get(type)!,  // type INDEX (1 byte) instead of string\n                values\n            ]);\n        }\n\n        // CRITICAL: Get the FULL allocator state, not just active entity generations.\n        // The previous \"minimal\" approach lost generation info for destroyed entity slots,\n        // causing entity ID collisions after refresh:\n        // - Authority had generation=N for a slot, late joiner had generation=0\n        // - When both allocated from the slot, they got different entity IDs\n        // - This caused permanent desync with identical entity counts but different hashes\n        const allocatorState = this.world.idAllocator.getState();\n\n        return {\n            frame: this.currentFrame,\n            seq: this.lastInputSeq,\n            postTick: true, // Snapshot is taken after tick - late joiners should NOT re-run this frame\n            format: 5, // Format 5: type-indexed compact encoding\n            types,     // Type names array (sent once)\n            schema,    // Component schemas indexed by type index\n            entities,  // Array of [eid, typeIndex, values[]]\n            idAllocatorState: allocatorState,\n            rng: saveRandomState(),\n            strings: this.world.strings.getState(),\n            clientIdMap: {\n                toNum: Object.fromEntries(this.clientIdToNum),\n                nextNum: this.nextClientNum\n            },\n            inputState: this.world.getInputState()\n        };\n    }\n\n    /**\n     * Load network snapshot into ECS world.\n     */\n    private loadNetworkSnapshot(snapshot: any): void {\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Loading snapshot: ${snapshot.entities?.length} entities`);\n        }\n\n        // Reset world FIRST (clears everything including ID allocator and strings)\n        this.world.reset();\n\n        // CRITICAL: Clear physics state before recreating entities\n        // Without this, old physics bodies with stale state (positions, sleeping, etc.)\n        // would be reused when entities are recreated with the same eids\n        if (this.physics) {\n            this.physics.clear();\n        }\n\n        // Restore RNG state\n        if (snapshot.rng) {\n            loadRandomState(snapshot.rng);\n        }\n\n        // Restore strings AFTER reset\n        if (snapshot.strings) {\n            this.world.strings.setState(snapshot.strings);\n        }\n\n        // Restore clientId interning from snapshot - snapshot is authoritative.\n        // NOTE: We do NOT preserve pre-existing mappings. Clients that joined AFTER\n        // the snapshot will be interned when their JOIN inputs are processed during catchup.\n        // Preserving pre-existing mappings caused desync because different clients had\n        // different state before loading, leading to divergent nextClientNum values.\n        if (snapshot.clientIdMap) {\n            const snapshotMappings = Object.entries(snapshot.clientIdMap.toNum) as [string, number][];\n\n            // Track ALL clientIds from snapshot (including those who joined then left)\n            // This is used to detect \"stale\" JOINs during catchup\n            this.clientIdsFromSnapshotMap.clear();\n            for (const [clientId] of snapshotMappings) {\n                this.clientIdsFromSnapshotMap.add(clientId);\n            }\n\n            // Restore snapshot's mappings (authoritative)\n            this.clientIdToNum = new Map(snapshotMappings.map(([k, v]) => [k, v as number]));\n            this.numToClientId = new Map(snapshotMappings.map(([k, v]) => [v as number, k]));\n            this.nextClientNum = snapshot.clientIdMap.nextNum || 1;\n        }\n\n        // Format 5: type-indexed encoding\n        const types = snapshot.types;\n        const schema = snapshot.schema;\n        const entitiesData = snapshot.entities;\n\n        // Track loaded entities by type for onRestore callbacks\n        const loadedEntitiesByType = new Map<string, Entity[]>();\n\n        for (const entityData of entitiesData) {\n            const [eid, typeIndex, values] = entityData;\n            const type = types[typeIndex];\n            const typeSchema = schema[typeIndex];\n\n            // Spawn entity with specific eid\n            let entity;\n            try {\n                entity = this.world.spawnWithId(type, eid, {});\n            } catch (e) {\n                console.warn(`[ecs] Failed to spawn ${type} with eid ${eid}:`, e);\n                continue;\n            }\n\n            // Track for onRestore callback\n            if (!loadedEntitiesByType.has(type)) {\n                loadedEntitiesByType.set(type, []);\n            }\n            loadedEntitiesByType.get(type)!.push(entity);\n\n            // Restore values using schema\n            const index = eid & INDEX_MASK;\n            let valueIdx = 0;\n\n            for (const [compName, fieldNames] of typeSchema) {\n                // Find component on entity\n                for (const comp of entity.getComponents()) {\n                    if (comp.name === compName) {\n                        for (const fieldName of fieldNames) {\n                            comp.storage.fields[fieldName][index] = values[valueIdx++];\n                        }\n                        break;\n                    }\n                }\n            }\n\n            // CRITICAL: Update clientIdIndex for Player entities after component restore\n            // The spawnWithId call above didn't have clientId in props, so the index wasn't set\n            if (entity.has(Player)) {\n                const player = entity.get(Player);\n                if (player.clientId !== 0) {\n                    this.world.setEntityClientId(entity.eid, player.clientId);\n                }\n            }\n        }\n\n        // Call onRestore callbacks for entity types that have them\n        // This allows reconstructing non-synced fields from synced data\n        for (const [type, entities] of loadedEntitiesByType) {\n            const entityDef = this.world.getEntityDef(type);\n            if (entityDef?.onRestore) {\n                for (const entity of entities) {\n                    entityDef.onRestore(entity, this);\n                }\n            }\n        }\n\n        // Restore input sequence\n        this.lastInputSeq = snapshot.seq || 0;\n\n        // Restore ID allocator state for proper future allocations\n        // Format 3+: minimal format with generations as object { index: gen }\n        // Format 2-: full format with generations as array\n        if (snapshot.idAllocatorState) {\n            const state = snapshot.idAllocatorState;\n\n            // First restore the basic allocator state\n            this.world.idAllocator.reset();\n            this.world.idAllocator.setNextId(state.nextIndex);\n\n            // Restore generations - handle both array and object formats\n            if (Array.isArray(state.generations)) {\n                for (let i = 0; i < state.generations.length; i++) {\n                    (this.world.idAllocator as any).generations[i] = state.generations[i];\n                }\n            } else if (typeof state.generations === 'object') {\n                for (const [indexStr, gen] of Object.entries(state.generations)) {\n                    const index = parseInt(indexStr, 10);\n                    (this.world.idAllocator as any).generations[index] = gen;\n                }\n            }\n\n            // NOTE: syncNone entities now use a separate localIdAllocator, so they don't\n            // affect the main idAllocator state. The snapshot's allocator state should be\n            // correct for synced entities. We verify by checking loaded entities match.\n            // Skip local entities (those with LOCAL_ENTITY_BIT set).\n            const loadedIndices = new Set<number>();\n            for (const entity of this.world.getAllEntities()) {\n                // Skip local entities - they use a different allocator\n                if (entity.eid & LOCAL_ENTITY_BIT) continue;\n                loadedIndices.add(entity.eid & INDEX_MASK);\n            }\n            const freeList: number[] = [];\n            for (let i = 0; i < state.nextIndex; i++) {\n                if (!loadedIndices.has(i)) {\n                    freeList.push(i);\n                }\n            }\n            (this.world.idAllocator as any).freeList = freeList;\n        }\n\n        // Track which clients already have entities from the snapshot\n        // This prevents duplicate entity creation during catchup\n        // ALSO populate activeClients for correct partition assignment\n        this.clientsWithEntitiesFromSnapshot.clear();\n        // CRITICAL: Clear activeClients before populating from snapshot\n        // Without this, stale clients remain after resync (e.g., client left but snapshot doesn't include them)\n        this.activeClients.length = 0;\n\n        // Get network SDK for registering clientIds (needed for TICK decoding)\n        const network: any = typeof window !== 'undefined' ? (window as any).moduNetwork : undefined;\n\n        for (const entity of this.world.query(Player)) {\n            const player = entity.get(Player);\n            if (player.clientId === 0) {\n                // ERROR: clientId=0 should never happen in networked games\n                console.error(`[ecs] Player entity ${entity.eid} has clientId=0 (invalid)`);\n                continue;\n            }\n            const clientIdStr = this.getClientIdString(player.clientId);\n            if (clientIdStr) {\n                this.clientsWithEntitiesFromSnapshot.add(clientIdStr);\n\n                // CRITICAL: Add to activeClients for partition assignment\n                // Without this, partition assignment differs between authority and late joiner\n                if (!this.activeClients.includes(clientIdStr)) {\n                    this.activeClients.push(clientIdStr);\n                }\n\n                // CRITICAL FIX: Register clientId with network SDK for TICK decoding\n                // Without this, late joiners can't decode inputs from clients\n                // whose JOIN event was already included in the snapshot.\n                // The SDK uses a hash-to-clientId map for binary TICK decoding.\n                if (network?.registerClientId) {\n                    network.registerClientId(clientIdStr);\n                    if (DEBUG_NETWORK) {\n                        console.log(`[ecs] Registered clientId ${clientIdStr.slice(0, 8)} from snapshot entity`);\n                    }\n                }\n\n                if (DEBUG_NETWORK) {\n                    console.log(`[ecs] Snapshot has entity for client ${clientIdStr.slice(0, 8)}`);\n                }\n            }\n        }\n        // Sort activeClients for deterministic partition assignment\n        this.activeClients.sort();\n\n        // NOTE: Do NOT set authorityClientId here from activeClients[0]\n        // Authority is determined by join order, not alphabetical order\n        // processAuthorityChainInput() will set it correctly from the first join event\n\n        // CRITICAL: Sync ALL physics bodies from restored ECS components\n        // This is the ROOT CAUSE of desync on late joiners:\n        // 1. ECS components (Transform2D, Body2D) are restored with correct positions/velocities\n        // 2. But physics world's internal RigidBody2D objects still have OLD positions/velocities\n        // 3. On next physics step, the old values are used, causing immediate divergence\n        //\n        // syncAllFromComponents() copies position/velocity from ECS components to physics bodies\n        // for ALL body types (including dynamic bodies which normal sync skips)\n        // Sync physics bodies from ECS components\n        if (this.physics) {\n            this.physics.syncAllFromComponents();\n        }\n\n        // Restore input state so movement systems behave identically\n        if (snapshot.inputState) {\n            this.world.setInputState(snapshot.inputState);\n            // Verify immediately after setting\n            const verifyState = this.world.getInputState();\n            const snapshotKeys = Object.keys(snapshot.inputState).sort().join(',');\n            const loadedKeys = Object.keys(verifyState).sort().join(',');\n            if (snapshotKeys !== loadedKeys) {\n                console.error(`[INPUT-STATE] KEYS DIFFER! snapshot=[${snapshotKeys}] loaded=[${loadedKeys}]`);\n            }\n        }\n    }\n\n    /**\n     * Send snapshot to network.\n     */\n    private sendSnapshot(source: string): void {\n        if (!this.connection) return;\n\n        // CRITICAL: Wake all physics bodies when sending snapshot\n        // This ensures the authority's bodies are in the same state as the late joiner's\n        // bodies will be after they restore and wake. Without this, authority has sleeping\n        // bodies while late joiner has awake bodies, causing physics divergence.\n        if (this.physics) {\n            this.physics.wakeAllBodies();\n        }\n\n        const snapshot = this.getNetworkSnapshot();\n        const hash = this.world.getStateHash();\n        const binary = encode({ snapshot, hash });\n        const entityCount = snapshot.entities.length;\n\n        this.connection.sendSnapshot(binary, hash, snapshot.seq, snapshot.frame);\n\n        // Update debug UI tracking - show last SENT snapshot for authority\n        this.lastSnapshotHash = hash;\n        this.lastSnapshotFrame = snapshot.frame;\n        this.lastSnapshotSize = binary.length;\n        this.lastSnapshotEntityCount = entityCount;\n    }\n\n    /**\n     * Handle server snapshot (for drift detection).\n     */\n    private handleServerSnapshot(data: Uint8Array): void {\n        if (DEBUG_NETWORK) {\n            console.log(`[ecs] Received server snapshot: ${data.length} bytes`);\n        }\n\n        // Decode and compare for drift detection\n        try {\n            const decoded = decode(data);\n            const serverSnapshot = decoded?.snapshot;\n            const serverHash = decoded?.hash;\n\n            if (serverSnapshot) {\n                // Ensure hash is stored as number\n                this.lastSnapshotHash = typeof serverHash === 'number'\n                    ? serverHash\n                    : (serverHash ? parseInt(String(serverHash), 16) : null) || null;\n                this.lastSnapshotFrame = serverSnapshot.frame;\n                this.lastSnapshotSize = data.length;\n                this.lastSnapshotEntityCount = serverSnapshot.entities?.length || 0;\n\n                // Only compare if frames match - otherwise comparison is meaningless\n                if (this.currentFrame === serverSnapshot.frame) {\n                    // Field-by-field comparison for drift stats\n                    this.compareSnapshotFields(serverSnapshot);\n\n                    // Compare hashes\n                    const localHash = this.getStateHash();\n                    if (localHash !== serverHash) {\n                        console.warn(`[ecs] DRIFT detected at frame ${serverSnapshot.frame}: local=${localHash}, server=${serverHash}`);\n                    }\n                } else {\n                    // Frames don't match - skip comparison (would give false positives)\n                    // Reset drift stats since we can't validate\n                    this.driftStats = {\n                        determinismPercent: 100,\n                        totalChecks: 0,\n                        matchingFieldCount: 0,\n                        totalFieldCount: 0\n                    };\n                }\n            }\n        } catch (e) {\n            console.warn('[ecs] Failed to decode server snapshot:', e);\n        }\n    }\n\n    /**\n     * Compare server snapshot fields with local state for drift tracking.\n     */\n    private compareSnapshotFields(serverSnapshot: any): void {\n        const frame = serverSnapshot.frame;\n        let matchingFields = 0;\n        let totalFields = 0;\n        const diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }> = [];\n\n        // Store server snapshot for debugging\n        this.lastServerSnapshot = { raw: null, decoded: serverSnapshot, frame };\n\n        const types = serverSnapshot.types || [];\n        const serverEntities = serverSnapshot.entities || [];\n        const schema = serverSnapshot.schema || [];\n\n        // Build map of server entities by eid (numeric)\n        const serverEntityMap = new Map<number, any>();\n        for (const e of serverEntities) {\n            serverEntityMap.set(e[0], e);\n        }\n\n        // Compare each local entity with server entity\n        for (const entity of this.world.getAllEntities()) {\n            const eid = entity.eid;\n            const serverEntity = serverEntityMap.get(eid);\n            const index = eid & INDEX_MASK;\n\n            if (!serverEntity) {\n                for (const comp of entity.getComponents()) {\n                    totalFields += comp.fieldNames.length;\n                    for (const fieldName of comp.fieldNames) {\n                        diffs.push({ entity: entity.type, eid, comp: comp.name, field: fieldName, local: 'EXISTS', server: 'MISSING' });\n                    }\n                }\n                continue;\n            }\n\n            const [, typeIndex, serverValues] = serverEntity;\n            const typeSchema = schema[typeIndex];\n\n            if (!typeSchema) continue;\n\n            let valueIdx = 0;\n            for (const [compName, fieldNames] of typeSchema) {\n                const localComp = entity.getComponents().find(c => c.name === compName);\n\n                for (const fieldName of fieldNames) {\n                    totalFields++;\n                    const serverValue = serverValues[valueIdx++];\n\n                    if (localComp) {\n                        const localValue = localComp.storage.fields[fieldName][index];\n                        const fieldDef = localComp.schema[fieldName];\n\n                        let valuesMatch = false;\n                        if (fieldDef?.type === 'bool') {\n                            const localBool = localValue !== 0;\n                            const serverBool = serverValue !== 0 && serverValue !== false;\n                            valuesMatch = localBool === serverBool;\n                        } else {\n                            valuesMatch = localValue === serverValue;\n                        }\n\n                        if (valuesMatch) {\n                            matchingFields++;\n                        } else {\n                            diffs.push({ entity: entity.type, eid, comp: compName, field: fieldName, local: localValue, server: serverValue });\n                        }\n                    }\n                }\n            }\n        }\n\n        // Count server entities not in local state\n        for (const [eid, serverEntity] of serverEntityMap) {\n            if (this.world.getEntity(eid) === null) {\n                const [, typeIndex, serverValues] = serverEntity;\n                const serverType = types[typeIndex] || `type${typeIndex}`;\n                totalFields += serverValues.length;\n                diffs.push({ entity: serverType, eid, comp: '*', field: '*', local: 'MISSING', server: 'EXISTS' });\n            }\n        }\n\n        const newPercent = totalFields > 0 ? (matchingFields / totalFields) * 100 : 100;\n        const wasSync = this.lastSyncPercent === 100;\n        const isSync = newPercent === 100;\n\n        // Store good snapshot when 100% sync\n        if (isSync) {\n            this.lastGoodSnapshot = {\n                snapshot: JSON.parse(JSON.stringify(serverSnapshot)),\n                frame: frame,\n                hash: this.getStateHash()\n            };\n        }\n\n        // First divergence - capture debug data and auto-show\n        if (wasSync && !isSync && !this.divergenceCaptured) {\n            this.firstDivergenceFrame = frame;\n            this.divergenceHistory = [];\n            this.divergenceCaptured = true;\n\n            const lastGoodFrame = this.lastGoodSnapshot?.frame ?? 0;\n            const inputsInRange = this.recentInputs.filter(i => i.frame > lastGoodFrame && i.frame <= frame);\n            const localSnapshot = this.world.getState();\n\n            this.divergenceCapture = {\n                lastGoodSnapshot: this.lastGoodSnapshot?.snapshot ?? null,\n                lastGoodFrame: lastGoodFrame,\n                inputs: inputsInRange,\n                localSnapshot: localSnapshot,\n                serverSnapshot: serverSnapshot,\n                diffs: diffs,\n                divergenceFrame: frame,\n                clientId: this.localClientIdStr,\n                isAuthority: this.checkIsAuthority()\n            };\n\n            this.showDivergenceDiff(diffs, inputsInRange, frame);\n        }\n\n        this.lastSyncPercent = newPercent;\n\n        // Update drift stats\n        this.driftStats.totalChecks++;\n        this.driftStats.matchingFieldCount = matchingFields;\n        this.driftStats.totalFieldCount = totalFields;\n        this.driftStats.determinismPercent = newPercent;\n\n        // Sparse ongoing divergence log (every 60 frames)\n        if (diffs.length > 0 && newPercent < 100 && this.divergenceCaptured && frame % 60 === 0) {\n            console.warn(`[DIVERGENCE] Frame ${frame}: still diverged (${newPercent.toFixed(1)}% sync, first at ${this.firstDivergenceFrame})`);\n        }\n    }\n\n    /**\n     * Show divergence debug data (auto-called on first divergence).\n     */\n    private showDivergenceDiff(\n        diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }>,\n        inputs: Array<{ frame: number; seq: number; clientId: string; data: any }>,\n        frame: number\n    ): void {\n        const lines: string[] = [];\n        const lastGoodFrame = this.lastGoodSnapshot?.frame ?? 0;\n        const myClientId = this.localClientIdStr || '';\n\n        // Build client legend (assign P1, P2, etc.)\n        const clientIds = new Set<string>();\n        for (const input of inputs) {\n            clientIds.add(input.clientId);\n        }\n        const clientList = Array.from(clientIds);\n        const clientLabels = new Map<string, string>();\n        clientList.forEach((cid, i) => {\n            const label = cid === myClientId ? 'ME' : `P${i + 1}`;\n            clientLabels.set(cid, label);\n        });\n\n        // Try to find entity owners (entities with Player component)\n        const entityOwners = new Map<number, string>();\n        for (const entity of this.world.getAllEntities()) {\n            if (entity.has(Player)) {\n                const playerData = entity.get(Player);\n                const ownerClientId = this.numToClientId.get(playerData.clientId);\n                if (ownerClientId) {\n                    entityOwners.set(entity.eid, clientLabels.get(ownerClientId) || ownerClientId.slice(0, 8));\n                }\n            }\n        }\n\n        lines.push(`=== DIVERGENCE DEBUG DATA ===`);\n        lines.push(`Frame: ${frame} | Last good: ${lastGoodFrame} | Authority: ${this.checkIsAuthority()}`);\n        lines.push(`Clients: ${clientList.map(cid => `${clientLabels.get(cid)}=${cid.slice(0, 8)}`).join(', ')}`);\n        lines.push(``);\n\n        lines.push(`DIVERGENT FIELDS (${diffs.length}):`);\n        for (const d of diffs) {\n            const delta = typeof d.local === 'number' && typeof d.server === 'number'\n                ? ` \u0394${d.local - d.server}`\n                : '';\n            const owner = entityOwners.get(d.eid);\n            const ownerStr = owner ? ` [${owner}]` : '';\n            lines.push(`  ${d.entity}#${d.eid.toString(16)}${ownerStr}.${d.comp}.${d.field}: local=${d.local} server=${d.server}${delta}`);\n        }\n        lines.push(``);\n\n        lines.push(`INPUTS (${inputs.length}):`);\n        for (const input of inputs) {\n            const label = clientLabels.get(input.clientId) || input.clientId.slice(0, 8);\n            lines.push(`  f${input.frame} [${label}]: ${JSON.stringify(input.data)}`);\n        }\n        lines.push(``);\n\n        if (this.lastGoodSnapshot) {\n            const goodEnts = Object.keys(this.lastGoodSnapshot.snapshot.entities || {}).length;\n            lines.push(`LAST GOOD SNAPSHOT (f${lastGoodFrame}): ${goodEnts} entities`);\n        } else {\n            lines.push(`LAST GOOD SNAPSHOT: none (never had 100% sync)`);\n        }\n\n        if (this.lastServerSnapshot.decoded) {\n            const serverEnts = Object.keys(this.lastServerSnapshot.decoded.entities || {}).length;\n            lines.push(`SERVER SNAPSHOT (f${this.lastServerSnapshot.frame}): ${serverEnts} entities`);\n        }\n\n        lines.push(`=== END DEBUG DATA ===`);\n        lines.push(`To get detailed replay data: game.getDivergenceReplay()`);\n\n        console.error(lines.join('\\n'));\n    }\n\n    /**\n     * Download divergence replay data as JSON.\n     */\n    getDivergenceReplay(): void {\n        if (!this.divergenceCapture) {\n            console.warn('[REPLAY] No divergence captured yet.');\n            return;\n        }\n\n        const json = JSON.stringify(this.divergenceCapture, null, 2);\n        const blob = new Blob([json], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `divergence-${this.divergenceCapture.divergenceFrame}.json`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n\n        console.log(`[REPLAY] Downloaded (${(json.length / 1024).toFixed(1)} KB)`);\n    }\n\n    // ==========================================\n    // Game Loop\n    // ==========================================\n\n    /**\n     * Start the game loop (render + local simulation when offline).\n     *\n     * When connected to server: server TICK messages drive simulation via handleTick().\n     * When offline: simulation ticks locally at tickRate.\n     */\n    private startGameLoop(): void {\n        if (this.gameLoop) return;\n\n        let lastTickTime = typeof performance !== 'undefined' ? performance.now() : Date.now();\n\n        const loop = () => {\n            const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\n\n            // Local simulation when not connected to server\n            // When connected, server TICK messages drive simulation via handleTick()\n            if (!this.connection) {\n                // Fixed timestep accumulator for deterministic simulation\n                while (now - lastTickTime >= this.tickIntervalMs) {\n                    this.currentFrame++;\n\n                    // Run ECS world tick (systems)\n                    this.world.tick(this.currentFrame, []);\n\n                    // Call game's onTick callback\n                    this.callbacks.onTick?.(this.currentFrame);\n\n                    lastTickTime += this.tickIntervalMs;\n                }\n            }\n\n            // Render\n            if (this.renderer?.render) {\n                this.renderer.render();\n            } else if (this.callbacks.render) {\n                this.callbacks.render();\n            }\n\n            this.gameLoop = requestAnimationFrame(loop);\n        };\n\n        this.gameLoop = requestAnimationFrame(loop);\n    }\n\n    /**\n     * Stop the render loop.\n     */\n    private stopGameLoop(): void {\n        if (this.gameLoop) {\n            cancelAnimationFrame(this.gameLoop);\n            this.gameLoop = null;\n        }\n    }\n\n    /**\n     * Handle disconnect from server.\n     *\n     * Fires the onDisconnect callback with no clientId (network disconnect, not player leave).\n     * The game loop continues running - the game can decide how to handle this:\n     * - Continue playing locally (single-player mode)\n     * - Show a reconnect UI\n     * - Pause the game\n     */\n    private handleDisconnect(): void {\n        console.log('[ecs] Disconnected from server');\n\n        // Clear connection state\n        const wasConnected = this.connection !== null;\n        this.connection = null;\n\n        // Fire onDisconnect callback with undefined clientId to indicate network disconnect\n        // (as opposed to a specific player leaving, which passes their clientId)\n        if (wasConnected && this.callbacks.onDisconnect) {\n            // Pass undefined to indicate this is a network disconnect, not a player leave\n            this.callbacks.onDisconnect(undefined as any);\n        }\n\n        // NOTE: We do NOT stop the game loop.\n        // The game continues running locally - the callback can decide what to do.\n        // If the game wants to stop, it can call game.stop() or game.leaveRoom().\n    }\n\n    // ==========================================\n    // Utility Methods\n    // ==========================================\n\n    /**\n     * Check if this client is the authority.\n     * Handles potential length mismatch between SDK and server client IDs.\n     */\n    checkIsAuthority(): boolean {\n        if (this.localClientIdStr === null || this.authorityClientId === null) {\n            return false;\n        }\n        // Server may send shorter client IDs, compare by prefix\n        const minLen = Math.min(this.localClientIdStr.length, this.authorityClientId.length);\n        return this.localClientIdStr.substring(0, minLen) === this.authorityClientId.substring(0, minLen);\n    }\n\n    /**\n     * Check if this client is the authority (public).\n     */\n    isAuthority(): boolean {\n        return this.checkIsAuthority();\n    }\n\n    /**\n     * Check if connected.\n     */\n    isConnected(): boolean {\n        return this.connection !== null;\n    }\n\n    /**\n     * Check if game has been started (via start() or connect()).\n     */\n    isStarted(): boolean {\n        return this.gameStarted;\n    }\n\n    /**\n     * Get current frame.\n     */\n    getFrame(): number {\n        return this.currentFrame;\n    }\n\n    /**\n     * Get server tick rate.\n     */\n    getServerFps(): number {\n        return this.serverFps;\n    }\n\n    /**\n     * Get render interpolation alpha (0-1).\n     */\n    getRenderAlpha(): number {\n        if (this.lastTickTime === 0) return 1;\n        const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\n        const elapsed = now - this.lastTickTime;\n        return Math.min(elapsed / this.tickIntervalMs, 1.0);\n    }\n\n    /**\n     * Send input to network.\n     */\n    sendInput(input: any): void {\n        if (!this.connection) return;\n        const binary = encode(input);\n        this.connection.send(binary);\n    }\n\n    /**\n     * Leave current room and stop the game.\n     */\n    leaveRoom(): void {\n        if (this.connection) {\n            this.connection.leaveRoom();\n            this.connection = null;\n        }\n        this.stopGameLoop();\n    }\n\n    /**\n     * Stop the game loop.\n     *\n     * Use this to pause or end the game. The game state is preserved.\n     * Call start() or connect() to resume.\n     */\n    stop(): void {\n        this.stopGameLoop();\n        console.log('[ecs] Game stopped');\n    }\n\n    /**\n     * Get local client ID.\n     */\n    get localClientId(): string | null {\n        return this.localClientIdStr;\n    }\n\n    /**\n     * Set local client ID.\n     */\n    setLocalClientId(clientId: string): void {\n        this.localClientIdStr = clientId;\n        const numId = this.internClientId(clientId);\n        this.world.localClientId = numId;\n    }\n\n    /**\n     * Get room ID.\n     */\n    getRoomId(): string | null {\n        return this.connectedRoomId;\n    }\n\n    /**\n     * Get last snapshot info.\n     */\n    getLastSnapshot(): { hash: number | null; frame: number; size: number; entityCount: number } {\n        return {\n            hash: this.lastSnapshotHash,\n            frame: this.lastSnapshotFrame,\n            size: this.lastSnapshotSize,\n            entityCount: this.lastSnapshotEntityCount\n        };\n    }\n\n    /**\n     * Get connected clients.\n     */\n    getClients(): string[] {\n        return this.activeClients;\n    }\n\n    /**\n     * Get client ID (for debug UI).\n     */\n    getClientId(): string | null {\n        return this.localClientIdStr;\n    }\n\n    /**\n     * Get node URL (for debug UI).\n     */\n    getNodeUrl(): string | null {\n        // Could be tracked from connection, for now return null\n        return null;\n    }\n\n    /**\n     * Get upload rate in bytes/second (for debug UI).\n     */\n    getUploadRate(): number {\n        return this.connection?.bandwidthOut || 0;\n    }\n\n    /**\n     * Get download rate in bytes/second (for debug UI).\n     */\n    getDownloadRate(): number {\n        return this.connection?.bandwidthIn || 0;\n    }\n\n    /**\n     * Get drift stats (for debug UI).\n     * Authority clients show 100% until they receive a comparison snapshot.\n     */\n    getDriftStats(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number } {\n        // If no snapshots have been compared yet, assume 100% sync\n        // Authority clients are the source of truth, so they're always \"in sync\"\n        if (this.driftStats.totalChecks === 0) {\n            const entityCount = this.world.getAllEntities().length;\n            // Estimate total fields from local entities if no comparison done yet\n            let estimatedFields = 0;\n            for (const entity of this.world.getAllEntities()) {\n                for (const comp of entity.getComponents()) {\n                    estimatedFields += comp.fieldNames.length;\n                }\n            }\n            return {\n                determinismPercent: 100,\n                totalChecks: 0,\n                matchingFieldCount: estimatedFields,\n                totalFieldCount: estimatedFields\n            };\n        }\n        return { ...this.driftStats };\n    }\n\n    /**\n     * Get hash-based sync stats (for debug UI).\n     * Returns the rolling percentage of hash checks that passed.\n     */\n    getSyncStats(): { syncPercent: number; passed: number; failed: number; isDesynced: boolean; resyncPending: boolean } {\n        const total = this.hashChecksPassed + this.hashChecksFailed;\n        const syncPercent = total > 0 ? (this.hashChecksPassed / total) * 100 : 100;\n        return {\n            syncPercent,\n            passed: this.hashChecksPassed,\n            failed: this.hashChecksFailed,\n            isDesynced: this.isDesynced,\n            resyncPending: this.resyncPending\n        };\n    }\n\n    /**\n     * Attach a renderer.\n     */\n    setRenderer(renderer: any): void {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Get canvas from attached renderer.\n     */\n    getCanvas(): HTMLCanvasElement | null {\n        return this.renderer?.element ?? null;\n    }\n\n    /**\n     * Get reliability scores (for debug UI).\n     */\n    getReliabilityScores(): Record<string, number> {\n        return { ...this.reliabilityScores };\n    }\n\n    /**\n     * Get active clients list (for debug UI).\n     */\n    getActiveClients(): string[] {\n        return [...this.activeClients];\n    }\n\n    /**\n     * Get local world entity count (for debug UI).\n     */\n    getEntityCount(): number {\n        return this.world.entityCount;\n    }\n\n    /**\n     * Get state sync delta bandwidth in bytes/second (for debug UI).\n     */\n    getDeltaBandwidth(): number {\n        return this.deltaBytesPerSecond;\n    }\n}\n\n// ==========================================\n// GameEntityBuilder\n// ==========================================\n\n/**\n * Game-specific entity builder with fluent API.\n */\nexport class GameEntityBuilder {\n    private worldBuilder: EntityBuilder;\n    private inputCommandsDef: any = null;\n\n    constructor(\n        private game: Game,\n        private name: string\n    ) {\n        this.worldBuilder = game.world.defineEntity(name);\n    }\n\n    /**\n     * Add a component to the entity definition.\n     */\n    with<T extends Record<string, any>>(\n        component: ComponentType<T>,\n        defaults?: Partial<T>\n    ): this {\n        this.worldBuilder.with(component, defaults);\n        return this;\n    }\n\n    /**\n     * Define input commands for this entity type.\n     */\n    commands(def: any): this {\n        this.inputCommandsDef = def;\n        return this;\n    }\n\n    /**\n     * Specify which fields to sync in snapshots (field-level sync).\n     * Only the specified fields are included in network snapshots.\n     *\n     * Use this to reduce bandwidth by only syncing essential fields.\n     * Non-synced fields can be reconstructed via onRestore().\n     *\n     * @example\n     * game.defineEntity('snake-segment')\n     *     .with(Transform2D)\n     *     .with(Sprite)\n     *     .with(SnakeSegment)\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\n     *     .register();\n     */\n    syncOnly(fields: string[]): this {\n        this.worldBuilder._setSyncFields(fields);\n        return this;\n    }\n\n    /**\n     * Exclude all fields from syncing for this entity type.\n     * The entity will not be included in network snapshots at all.\n     *\n     * Use this for purely client-local entities like cameras, UI, or effects.\n     *\n     * @example\n     * game.defineEntity('local-camera')\n     *     .with(Camera2D)\n     *     .syncNone()\n     *     .register();\n     */\n    syncNone(): this {\n        this.worldBuilder._setSyncFields([]);\n        return this;\n    }\n\n    /**\n     * @deprecated Use syncOnly() instead for clarity\n     */\n    sync(fields: string[]): this {\n        return this.syncOnly(fields);\n    }\n\n    /**\n     * Set a callback to reconstruct non-synced fields after snapshot load.\n     * Called for each entity of this type after loading a snapshot.\n     *\n     * @example\n     * game.defineEntity('snake-segment')\n     *     .with(Transform2D)\n     *     .with(Sprite)\n     *     .with(SnakeSegment)\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\n     *     .onRestore((entity, game) => {\n     *         const owner = game.world.getEntityByClientId(entity.get(SnakeSegment).ownerId);\n     *         if (owner) {\n     *             entity.get(Sprite).color = owner.get(Sprite).color;\n     *             entity.get(Sprite).radius = SEGMENT_RADIUS;\n     *         }\n     *     })\n     *     .register();\n     */\n    onRestore(callback: (entity: Entity, game: Game) => void): this {\n        this.worldBuilder._setOnRestore(callback);\n        return this;\n    }\n\n    /**\n     * Finalize and register the entity definition.\n     */\n    register(): Prefab {\n        this.worldBuilder._ensureRegistered();\n        return this.game._registerPrefab(this.name, this.worldBuilder);\n    }\n}\n\n// ==========================================\n// Factory Function\n// ==========================================\n\n/**\n * Initialize a new game instance.\n */\nexport function createGame(): Game {\n    console.log('[MODU] Engine version: BUILD_50');\n    return new Game();\n}\n", "/**\n * Simple2DRenderer - Basic 2D canvas renderer for entities with Sprite component\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Sprite, Camera2D, SHAPE_RECT, SHAPE_CIRCLE, SPRITE_IMAGE } from '../components';\n\nexport interface Simple2DRendererOptions {\n    /** Background color (default: '#111') */\n    background?: string;\n    /** Whether to clear canvas each frame (default: true) */\n    autoClear?: boolean;\n}\n\n/**\n * Simple 2D renderer that draws all entities with Sprite component.\n *\n * Can be used as a plugin via game.addPlugin() or standalone.\n *\n * @example\n * // Plugin pattern (recommended)\n * game.addPlugin(Simple2DRenderer, canvas);\n *\n * // Standalone pattern\n * new Simple2DRenderer(game, canvas);\n */\nexport class Simple2DRenderer {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    private game: Game;\n    private options: Required<Simple2DRendererOptions>;\n    private imageCache: Map<string, HTMLImageElement> = new Map();\n    private _cameraEntity: Entity | null = null;\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string, options: Simple2DRendererOptions = {}) {\n        this.game = game;\n\n        // Accept either element or selector\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) throw new Error('Could not get 2d context');\n        this.ctx = ctx;\n\n        this.options = {\n            background: options.background ?? '#111',\n            autoClear: options.autoClear ?? true\n        };\n\n        // Attach to game\n        game.setRenderer(this);\n    }\n\n    /** Canvas width */\n    get width(): number { return this.canvas.width; }\n\n    /** Canvas height */\n    get height(): number { return this.canvas.height; }\n\n    /** The canvas element */\n    get element(): HTMLCanvasElement { return this.canvas; }\n\n    /** The 2D context (for custom drawing) */\n    get context(): CanvasRenderingContext2D { return this.ctx; }\n\n    /**\n     * Set the camera entity to use for rendering.\n     * When set, the renderer will apply camera transform (position, zoom).\n     */\n    set camera(entity: Entity | null) {\n        this._cameraEntity = entity;\n        if (entity) {\n            // Update viewport size in camera component\n            try {\n                const cam = entity.get(Camera2D);\n                cam.viewportWidth = this.canvas.width;\n                cam.viewportHeight = this.canvas.height;\n            } catch {\n                // Entity doesn't have Camera2D\n            }\n        }\n    }\n\n    get camera(): Entity | null {\n        return this._cameraEntity;\n    }\n\n    /**\n     * Render all entities with Sprite component.\n     */\n    render(): void {\n        const { ctx, canvas, options, game } = this;\n\n        // Clear\n        if (options.autoClear) {\n            ctx.fillStyle = options.background;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Get interpolation alpha (0-1 between physics ticks)\n        const alpha = game.getRenderAlpha();\n\n        // Get camera data if available\n        let camX = 0, camY = 0, camZoom = 1;\n        if (this._cameraEntity && !this._cameraEntity.destroyed) {\n            try {\n                const cam = this._cameraEntity.get(Camera2D);\n                camX = cam.x;\n                camY = cam.y;\n                camZoom = cam.zoom;\n\n                // Update viewport size in case canvas was resized\n                cam.viewportWidth = canvas.width;\n                cam.viewportHeight = canvas.height;\n            } catch {\n                // Camera entity doesn't have Camera2D\n            }\n        }\n\n        // Collect entities with Sprite, sorted by layer\n        const entities: Array<{ entity: any; layer: number }> = [];\n\n        for (const entity of game.getAllEntities()) {\n            // Skip destroyed entities\n            if (entity.destroyed) continue;\n\n            try {\n                const sprite = entity.get(Sprite);\n                if (sprite && sprite.visible) {\n                    // Calculate interpolated position for smooth rendering\n                    entity.interpolate(alpha);\n                    entities.push({ entity, layer: sprite.layer });\n                }\n            } catch {\n                // Entity doesn't have Sprite\n            }\n        }\n\n        // Sort by layer (lower first)\n        entities.sort((a, b) => a.layer - b.layer);\n\n        // Apply camera transform\n        ctx.save();\n        ctx.translate(canvas.width / 2, canvas.height / 2);\n        ctx.scale(camZoom, camZoom);\n        ctx.translate(-camX, -camY);\n\n        // Draw each entity\n        for (const { entity } of entities) {\n            this.drawEntity(entity);\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Draw a single entity.\n     */\n    private drawEntity(entity: any): void {\n        const { ctx, game } = this;\n\n        const sprite = entity.get(Sprite);\n\n        // Use interpolated position for smooth rendering between physics ticks\n        const x = entity.render.interpX + sprite.offsetX;\n        const y = entity.render.interpY + sprite.offsetY;\n        const scaleX = sprite.scaleX;\n        const scaleY = sprite.scaleY;\n\n        // Get color string\n        const colorStr = game.getString('color', sprite.color) || '#fff';\n\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.scale(scaleX, scaleY);\n\n        const shape = sprite.shape;\n\n        if (shape === SHAPE_CIRCLE) {\n            const radius = sprite.radius;\n            ctx.fillStyle = colorStr;\n            ctx.beginPath();\n            ctx.arc(0, 0, radius, 0, Math.PI * 2);\n            ctx.fill();\n        } else if (shape === SHAPE_RECT) {\n            const w = sprite.width;\n            const h = sprite.height;\n            ctx.fillStyle = colorStr;\n            ctx.fillRect(-w / 2, -h / 2, w, h);\n        } else if (shape === SPRITE_IMAGE) {\n            const imageId = game.getString('sprite', sprite.spriteId);\n            if (imageId) {\n                const img = this.getImage(imageId);\n                if (img && img.complete) {\n                    const w = sprite.width || img.width;\n                    const h = sprite.height || img.height;\n                    ctx.drawImage(img, -w / 2, -h / 2, w, h);\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Get or load an image.\n     */\n    private getImage(src: string): HTMLImageElement | null {\n        let img = this.imageCache.get(src);\n        if (!img) {\n            img = new Image();\n            img.src = src;\n            this.imageCache.set(src, img);\n        }\n        return img;\n    }\n\n    /**\n     * Preload images for faster rendering.\n     */\n    preload(images: string[]): Promise<void> {\n        return Promise.all(\n            images.map(src => new Promise<void>((resolve) => {\n                const img = this.getImage(src);\n                if (img?.complete) {\n                    resolve();\n                } else if (img) {\n                    img.onload = () => resolve();\n                    img.onerror = () => resolve();\n                }\n            }))\n        ).then(() => {});\n    }\n}\n", "/**\n * InputPlugin - Handles input collection and network sending\n *\n * Provides a key-agnostic input system where:\n * - Games define actions with callback bindings\n * - Raw input state is tracked (keys, mouse)\n * - Input is automatically sent to server at tick rate\n *\n * @example\n * const input = game.addPlugin(InputPlugin, canvas);\n *\n * // Movement with custom key mapping (game defines the keys)\n * input.action('move', {\n *     type: 'vector',\n *     bindings: [() => {\n *         let x = 0, y = 0;\n *         if (input.isKeyDown('w')) y -= 1;\n *         if (input.isKeyDown('s')) y += 1;\n *         if (input.isKeyDown('a')) x -= 1;\n *         if (input.isKeyDown('d')) x += 1;\n *         return { x, y };\n *     }]\n * });\n *\n * // Button action\n * input.action('shoot', {\n *     type: 'button',\n *     bindings: [() => input.isMouseButtonDown(0)]\n * });\n *\n * // Raw state access\n * input.isKeyDown('space')     // Check any key\n * input.isMouseButtonDown(0)   // 0=left, 1=middle, 2=right\n * input.getMousePos()          // { x, y } screen coords\n */\n\nimport { Game } from '../game';\n\n// Forward declaration to avoid circular import\ninterface GameLike {\n    isConnected(): boolean;\n    localClientId: string | null;\n    sendInput(input: any): void;\n    getServerFps(): number;\n}\n\n/** Action types */\nexport type ActionType = 'button' | 'vector';\n\n/** Binding source - string shorthand or custom callback */\nexport type BindingSource = string | (() => any);\n\n/** Action definition */\nexport interface ActionDef {\n    type: ActionType;\n    bindings: BindingSource[];\n}\n\n/** Vector value */\nexport interface Vec2 {\n    x: number;\n    y: number;\n}\n\n/**\n * InputPlugin - Action-based input system\n */\nexport class InputPlugin {\n    private game: GameLike;\n    private canvas: HTMLCanvasElement;\n\n    /** Action definitions */\n    private actions: Map<string, ActionDef> = new Map();\n\n    /** Current bindings (may differ from defaults after rebind) */\n    private bindings: Map<string, BindingSource[]> = new Map();\n\n    /** Raw input state */\n    private mousePos: Vec2 = { x: 0, y: 0 };\n    private keysDown: Set<string> = new Set();\n    private mouseButtons: Set<number> = new Set();\n\n    /** Send interval handle */\n    private sendInterval: number | null = null;\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string) {\n        this.game = game;\n\n        // Resolve canvas\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        this.setupListeners();\n        this.startSendLoop();\n    }\n\n    /**\n     * Define an action with default bindings.\n     */\n    action(name: string, def: ActionDef): this {\n        this.actions.set(name, def);\n        // Set default bindings if not already rebound\n        if (!this.bindings.has(name)) {\n            this.bindings.set(name, [...def.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Rebind an action to new bindings.\n     */\n    rebind(name: string, bindings: BindingSource[]): this {\n        if (!this.actions.has(name)) {\n            console.warn(`[InputPlugin] Unknown action: ${name}`);\n            return this;\n        }\n        this.bindings.set(name, bindings);\n        return this;\n    }\n\n    /**\n     * Reset action to default bindings.\n     */\n    resetBinding(name: string): this {\n        const action = this.actions.get(name);\n        if (action) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Reset all bindings to defaults.\n     */\n    resetAllBindings(): this {\n        for (const [name, action] of this.actions) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Get current bindings for serialization.\n     * Only includes string bindings (callbacks can't be serialized).\n     */\n    getBindings(): Record<string, string[]> {\n        const result: Record<string, string[]> = {};\n        for (const [name, sources] of this.bindings) {\n            result[name] = sources.filter(s => typeof s === 'string') as string[];\n        }\n        return result;\n    }\n\n    /**\n     * Load bindings from serialized data.\n     */\n    loadBindings(data: Record<string, string[]>): this {\n        for (const [name, sources] of Object.entries(data)) {\n            if (this.actions.has(name)) {\n                this.bindings.set(name, sources);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Check if a key is currently pressed.\n     * Games can use this in callback bindings for custom key mappings.\n     */\n    isKeyDown(key: string): boolean {\n        return this.keysDown.has(key.toLowerCase());\n    }\n\n    /**\n     * Get current value of an action.\n     */\n    get(name: string): boolean | Vec2 | null {\n        const action = this.actions.get(name);\n        const sources = this.bindings.get(name);\n        if (!action || !sources) return null;\n\n        if (action.type === 'button') {\n            return this.resolveButton(sources);\n        } else {\n            return this.resolveVector(sources);\n        }\n    }\n\n    /**\n     * Get all action values as an object.\n     */\n    getAll(): Record<string, any> {\n        const result: Record<string, any> = {};\n        for (const name of this.actions.keys()) {\n            result[name] = this.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Resolve button value from sources (OR logic).\n     */\n    private resolveButton(sources: BindingSource[]): boolean {\n        for (const source of sources) {\n            if (typeof source === 'function') {\n                if (source()) return true;\n            } else if (this.resolveStringButton(source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resolve vector value from sources (additive, clamped).\n     */\n    private resolveVector(sources: BindingSource[]): Vec2 {\n        let x = 0, y = 0;\n\n        for (const source of sources) {\n            let vec: Vec2 | null = null;\n\n            if (typeof source === 'function') {\n                vec = source();\n            } else {\n                vec = this.resolveStringVector(source);\n            }\n\n            if (vec) {\n                x += vec.x;\n                y += vec.y;\n            }\n        }\n\n        // Don't normalize here - games handle diagonal speed with integer math\n        // to maintain determinism across clients\n        return { x, y };\n    }\n\n    /**\n     * Resolve a string binding to button value.\n     */\n    private resolveStringButton(source: string): boolean {\n        // key:X - single key\n        if (source.startsWith('key:')) {\n            const key = source.slice(4).toLowerCase();\n            return this.keysDown.has(key);\n        }\n\n        // mouse:left, mouse:right, mouse:middle\n        if (source.startsWith('mouse:')) {\n            const button = source.slice(6);\n            if (button === 'left') return this.mouseButtons.has(0);\n            if (button === 'right') return this.mouseButtons.has(2);\n            if (button === 'middle') return this.mouseButtons.has(1);\n        }\n\n        return false;\n    }\n\n    /**\n     * Resolve a string binding to vector value.\n     */\n    private resolveStringVector(source: string): Vec2 | null {\n        // mouse - current position\n        if (source === 'mouse') {\n            return { ...this.mousePos };\n        }\n\n        return null;\n    }\n\n    /**\n     * Get mouse position.\n     */\n    getMousePos(): Vec2 {\n        return { ...this.mousePos };\n    }\n\n    /**\n     * Check if a mouse button is pressed.\n     * 0 = left, 1 = middle, 2 = right\n     */\n    isMouseButtonDown(button: number): boolean {\n        return this.mouseButtons.has(button);\n    }\n\n    /**\n     * Set up event listeners.\n     */\n    private setupListeners(): void {\n        // Mouse move\n        this.canvas.addEventListener('mousemove', (e) => {\n            const rect = this.canvas.getBoundingClientRect();\n            this.mousePos.x = e.clientX - rect.left;\n            this.mousePos.y = e.clientY - rect.top;\n        });\n\n        // Mouse buttons\n        this.canvas.addEventListener('mousedown', (e) => {\n            this.mouseButtons.add(e.button);\n        });\n\n        this.canvas.addEventListener('mouseup', (e) => {\n            this.mouseButtons.delete(e.button);\n        });\n\n        // Keyboard - use window to catch all keys\n        window.addEventListener('keydown', (e) => {\n            this.keysDown.add(e.key.toLowerCase());\n        });\n\n        window.addEventListener('keyup', (e) => {\n            this.keysDown.delete(e.key.toLowerCase());\n        });\n\n        // Clear keys on blur (prevent stuck keys)\n        window.addEventListener('blur', () => {\n            this.keysDown.clear();\n            this.mouseButtons.clear();\n        });\n    }\n\n    /**\n     * Start the send loop.\n     */\n    private startSendLoop(): void {\n        // Send at server tick rate (default 50ms = 20fps)\n        const sendRate = 1000 / (this.game.getServerFps?.() || 20);\n\n        this.sendInterval = window.setInterval(() => {\n            if (this.game.isConnected() && this.game.localClientId && this.actions.size > 0) {\n                const input = this.getAll();\n                // Send input every tick - deterministic networking requires continuous input\n                this.game.sendInput(input);\n            }\n        }, sendRate);\n    }\n\n    /**\n     * Stop the send loop.\n     */\n    destroy(): void {\n        if (this.sendInterval !== null) {\n            clearInterval(this.sendInterval);\n            this.sendInterval = null;\n        }\n    }\n}\n", "/**\n * CameraSystem - 2D camera management for ECS\n *\n * Updates Camera2D component based on follow target.\n * Handles zoom smoothing and position interpolation.\n *\n * This system is client-only - Camera2D component has sync: false.\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Camera2D, Transform2D } from '../components';\n\nexport interface CameraSystemOptions {\n    /** Default zoom level (default: 1) */\n    defaultZoom?: number;\n    /** Default smoothing (default: 0.1) */\n    defaultSmoothing?: number;\n    /** Minimum zoom level (default: 0.1) */\n    minZoom?: number;\n    /** Maximum zoom level (default: 10) */\n    maxZoom?: number;\n}\n\n/**\n * CameraSystem - manages Camera2D components.\n *\n * @example\n * // Add as plugin\n * const cameraSystem = game.addPlugin(CameraSystem);\n *\n * // Create a camera entity\n * game.defineEntity('camera').with(Camera2D).register();\n * const camera = game.spawn('camera');\n *\n * // Follow an entity\n * cameraSystem.follow(camera, playerEntity);\n *\n * // Or manually set position\n * const cam = camera.get(Camera2D);\n * cam.x = 100;\n * cam.y = 200;\n * cam.zoom = 1.5;\n */\nexport class CameraSystem {\n    private game: Game;\n    private options: Required<CameraSystemOptions>;\n\n    constructor(game: Game, options: CameraSystemOptions = {}) {\n        this.game = game;\n        this.options = {\n            defaultZoom: options.defaultZoom ?? 1,\n            defaultSmoothing: options.defaultSmoothing ?? 0.1,\n            minZoom: options.minZoom ?? 0.1,\n            maxZoom: options.maxZoom ?? 10\n        };\n\n        // Register update system\n        game.addSystem(this.update.bind(this), { phase: 'render' });\n    }\n\n    /**\n     * Update all cameras.\n     */\n    private update(): void {\n        for (const entity of this.game.query('Camera2D')) {\n            this.updateCamera(entity);\n        }\n    }\n\n    /**\n     * Update a single camera entity.\n     */\n    private updateCamera(cameraEntity: Entity): void {\n        const cam = cameraEntity.get(Camera2D);\n\n        // Follow target entity if set\n        if (cam.followEntity !== 0) {\n            const target = this.game.world.getEntity(cam.followEntity);\n            if (target && !target.destroyed) {\n                try {\n                    const transform = target.get(Transform2D);\n                    // Smooth follow\n                    cam.x += (transform.x - cam.x) * cam.smoothing;\n                    cam.y += (transform.y - cam.y) * cam.smoothing;\n                } catch {\n                    // Target doesn't have Transform2D\n                }\n            }\n        }\n\n        // Smooth zoom transition\n        if (cam.zoom !== cam.targetZoom) {\n            cam.zoom += (cam.targetZoom - cam.zoom) * cam.smoothing;\n            // Clamp zoom\n            cam.zoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, cam.zoom));\n        }\n    }\n\n    /**\n     * Set camera to follow an entity.\n     */\n    follow(cameraEntity: Entity, targetEntity: Entity | null): void {\n        const cam = cameraEntity.get(Camera2D);\n        cam.followEntity = targetEntity ? targetEntity.eid : 0;\n    }\n\n    /**\n     * Center camera on multiple entities (weighted by optional areas).\n     */\n    centerOn(cameraEntity: Entity, entities: Entity[], weights?: number[]): void {\n        if (entities.length === 0) return;\n\n        const cam = cameraEntity.get(Camera2D);\n        let totalWeight = 0;\n        let centerX = 0;\n        let centerY = 0;\n\n        for (let i = 0; i < entities.length; i++) {\n            const entity = entities[i];\n            if (entity.destroyed) continue;\n\n            try {\n                const transform = entity.get(Transform2D);\n                const weight = weights?.[i] ?? 1;\n\n                centerX += transform.x * weight;\n                centerY += transform.y * weight;\n                totalWeight += weight;\n            } catch {\n                // Entity doesn't have Transform2D\n            }\n        }\n\n        if (totalWeight > 0) {\n            cam.x += (centerX / totalWeight - cam.x) * cam.smoothing;\n            cam.y += (centerY / totalWeight - cam.y) * cam.smoothing;\n        }\n    }\n\n    /**\n     * Convert world coordinates to screen coordinates.\n     */\n    worldToScreen(cameraEntity: Entity, worldX: number, worldY: number): { x: number; y: number } {\n        const cam = cameraEntity.get(Camera2D);\n        return {\n            x: (worldX - cam.x) * cam.zoom + cam.viewportWidth / 2,\n            y: (worldY - cam.y) * cam.zoom + cam.viewportHeight / 2\n        };\n    }\n\n    /**\n     * Convert screen coordinates to world coordinates.\n     */\n    screenToWorld(cameraEntity: Entity, screenX: number, screenY: number): { x: number; y: number } {\n        const cam = cameraEntity.get(Camera2D);\n        return {\n            x: (screenX - cam.viewportWidth / 2) / cam.zoom + cam.x,\n            y: (screenY - cam.viewportHeight / 2) / cam.zoom + cam.y\n        };\n    }\n\n    /**\n     * Set zoom with optional target position.\n     */\n    setZoom(cameraEntity: Entity, zoom: number, immediate: boolean = false): void {\n        const cam = cameraEntity.get(Camera2D);\n        const clampedZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, zoom));\n        cam.targetZoom = clampedZoom;\n        if (immediate) {\n            cam.zoom = clampedZoom;\n        }\n    }\n\n    /**\n     * Get visible bounds in world coordinates.\n     */\n    getVisibleBounds(cameraEntity: Entity): { left: number; top: number; right: number; bottom: number } {\n        const cam = cameraEntity.get(Camera2D);\n        const halfWidth = (cam.viewportWidth / 2) / cam.zoom;\n        const halfHeight = (cam.viewportHeight / 2) / cam.zoom;\n\n        return {\n            left: cam.x - halfWidth,\n            top: cam.y - halfHeight,\n            right: cam.x + halfWidth,\n            bottom: cam.y + halfHeight\n        };\n    }\n\n    /**\n     * Check if a world point is visible.\n     */\n    isPointVisible(cameraEntity: Entity, worldX: number, worldY: number, margin: number = 0): boolean {\n        const bounds = this.getVisibleBounds(cameraEntity);\n        return worldX >= bounds.left - margin &&\n               worldX <= bounds.right + margin &&\n               worldY >= bounds.top - margin &&\n               worldY <= bounds.bottom + margin;\n    }\n}\n", "/**\n * Determinism Guard\n *\n * Warns developers when non-deterministic functions are called during simulation.\n * Suggests deterministic alternatives like dRandom() and dSqrt().\n */\n\nimport type { Game } from '../game';\n\ninterface OriginalFunctions {\n    mathRandom?: typeof Math.random;\n    mathSqrt?: typeof Math.sqrt;\n    dateNow?: typeof Date.now;\n    performanceNow?: typeof performance.now;\n}\n\nconst originalFunctions: OriginalFunctions = {};\nlet installedGame: Game | null = null;\nlet warnedFunctions: Set<string> = new Set();\n\nfunction isSimulating(): boolean {\n    return installedGame?.world?._isSimulating ?? false;\n}\n\nfunction warnOnce(key: string, message: string) {\n    if (!warnedFunctions.has(key)) {\n        warnedFunctions.add(key);\n        console.warn(message);\n    }\n}\n\n/**\n * Enable determinism guard for a game instance.\n * Warns when dangerous functions are called during simulation.\n *\n * @example\n * const game = createGame();\n * enableDeterminismGuard(game);\n */\nexport function enableDeterminismGuard(game: Game): void {\n    if (installedGame) {\n        console.warn('Determinism guard already installed for another game instance');\n        return;\n    }\n\n    installedGame = game;\n    warnedFunctions.clear();\n\n    // Intercept Math.random\n    originalFunctions.mathRandom = Math.random;\n    Math.random = function(): number {\n        if (isSimulating()) {\n            warnOnce('Math.random',\n                '\u26A0\uFE0F Math.random() is non-deterministic!\\n' +\n                '   Use dRandom() instead for deterministic random numbers.\\n' +\n                '   Example: const r = dRandom();'\n            );\n        }\n        return originalFunctions.mathRandom!();\n    };\n\n    // Intercept Math.sqrt\n    originalFunctions.mathSqrt = Math.sqrt;\n    Math.sqrt = function(x: number): number {\n        if (isSimulating()) {\n            warnOnce('Math.sqrt',\n                '\u26A0\uFE0F Math.sqrt() is non-deterministic!\\n' +\n                '   Use dSqrt() instead for deterministic square root.\\n' +\n                '   Example: const dist = dSqrt(dx * dx + dy * dy);'\n            );\n        }\n        return originalFunctions.mathSqrt!(x);\n    };\n\n    // Intercept Date.now\n    originalFunctions.dateNow = Date.now;\n    Date.now = function(): number {\n        if (isSimulating()) {\n            warnOnce('Date.now',\n                '\u26A0\uFE0F Date.now() is non-deterministic!\\n' +\n                '   Use game.time instead for deterministic timing.\\n' +\n                '   Example: const respawnAt = game.time + 3000;'\n            );\n        }\n        return originalFunctions.dateNow!();\n    };\n\n    // Intercept performance.now\n    if (typeof performance !== 'undefined') {\n        originalFunctions.performanceNow = performance.now.bind(performance);\n        performance.now = function(): number {\n            if (isSimulating()) {\n                warnOnce('performance.now',\n                    '\u26A0\uFE0F performance.now() is non-deterministic!\\n' +\n                    '   Use game.time instead for deterministic timing.'\n                );\n            }\n            return originalFunctions.performanceNow!();\n        };\n    }\n\n    console.log('\uD83D\uDEE1\uFE0F Determinism guard enabled');\n}\n\n/**\n * Disable determinism guard and restore original functions.\n */\nexport function disableDeterminismGuard(): void {\n    if (originalFunctions.mathRandom) {\n        Math.random = originalFunctions.mathRandom;\n    }\n    if (originalFunctions.mathSqrt) {\n        Math.sqrt = originalFunctions.mathSqrt;\n    }\n    if (originalFunctions.dateNow) {\n        Date.now = originalFunctions.dateNow;\n    }\n    if (originalFunctions.performanceNow && typeof performance !== 'undefined') {\n        performance.now = originalFunctions.performanceNow;\n    }\n\n    installedGame = null;\n    warnedFunctions.clear();\n\n    // Clear stored references\n    Object.keys(originalFunctions).forEach(key => {\n        delete (originalFunctions as any)[key];\n    });\n}\n", "// Auto-generated by update-version.js\nexport const ENGINE_VERSION = 'a7fb187';\nexport const ENGINE_BUILD_DATE = '2026-01-20T09:59:38.611Z';\n", "/**\n * Debug UI - Simple stats overlay for game instances\n *\n * Usage:\n *   Modu.enableDebugUI(game);  // Pass game instance\n *   Modu.setDebugHash(() => computeMyHash()); // Optional: show live state hash\n *\n * Also enables determinism guard to warn about non-deterministic function calls.\n */\n\nimport { enableDeterminismGuard } from './determinism-guard';\nimport type { Game } from '../game';\nimport { ENGINE_VERSION } from '../version';\n\n/** Interface for objects that can be displayed in debug UI */\nexport interface DebugUITarget {\n    getClientId(): string | null;\n    getFrame(): number;\n    getNodeUrl(): string | null;\n    getLastSnapshot(): { hash: number | null; frame: number; size: number; entityCount: number };\n    getServerFps(): number;\n    getRoomId(): string | null;\n    getUploadRate(): number;\n    getDownloadRate(): number;\n    getClients(): string[];\n    getStateHash(): number;\n    getEntityCount?(): number;\n    getDriftStats?(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number };\n    // State sync info\n    getReliabilityScores?(): Record<string, number>;\n    getActiveClients?(): string[];\n    getDeltaBandwidth?(): number;\n    getSyncStats?(): { syncPercent: number; passed: number; failed: number; isDesynced: boolean; resyncPending: boolean };\n}\n\nexport interface DebugUIOptions {\n    /** Position: 'top-right' (default), 'top-left', 'bottom-right', 'bottom-left' */\n    position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\n}\n\nlet debugDiv: HTMLDivElement | null = null;\nlet updateInterval: number | null = null;\nlet hashCallback: (() => string | number) | null = null;\nlet debugTarget: DebugUITarget | null = null;\n\n// FPS tracking\nlet lastFrameTime = 0;\nlet frameCount = 0;\nlet renderFps = 0;\nlet fpsUpdateTime = 0;\n\n/**\n * Set a callback to compute the current state hash for debug display.\n * The hash will be shown in the debug UI and should change as bodies move.\n */\nexport function setDebugHash(callback: () => string | number): void {\n    hashCallback = callback;\n}\n\n/**\n * Enable debug UI overlay - shows frame, client, node, snapshot info automatically\n * @param target - Object implementing DebugUITarget interface\n * @param options - UI options\n */\nexport function enableDebugUI(target?: DebugUITarget, options: DebugUIOptions = {}): HTMLDivElement {\n    if (debugDiv) return debugDiv;\n\n    // Store target reference for updates\n    debugTarget = target || null;\n\n    // Enable determinism guard if target is a Game instance\n    if (target && 'world' in target) {\n        enableDeterminismGuard(target as unknown as Game);\n    }\n\n    const pos = options.position || 'top-right';\n\n    debugDiv = document.createElement('div');\n    debugDiv.id = 'modu-debug-ui';\n    debugDiv.style.cssText = `\n        position: fixed;\n        ${pos.includes('top') ? 'top: 10px' : 'bottom: 10px'};\n        ${pos.includes('right') ? 'right: 10px' : 'left: 10px'};\n        background: rgba(0, 0, 0, 0.8);\n        color: #0f0;\n        font: 12px monospace;\n        padding: 8px 12px;\n        border-radius: 4px;\n        z-index: 10000;\n        min-width: 180px;\n        user-select: text;\n        cursor: text;\n        \n    `;\n    document.body.appendChild(debugDiv);\n\n    // Update loop\n    const update = (now: number) => {\n        if (!debugDiv) return;\n\n        // Calculate render FPS\n        frameCount++;\n        if (now - fpsUpdateTime >= 1000) {\n            renderFps = frameCount;\n            frameCount = 0;\n            fpsUpdateTime = now;\n        }\n\n        const eng = debugTarget;\n        if (!eng) {\n            debugDiv.innerHTML = '<div style=\"color:#f00\">No engine instance</div>';\n            return;\n        }\n\n        const clientId = eng.getClientId();\n        const frame = eng.getFrame();\n        const nodeUrl = eng.getNodeUrl();\n        const lastSnap = eng.getLastSnapshot();\n        const fps = eng.getServerFps();\n        const roomId = eng.getRoomId();\n        const up = eng.getUploadRate();\n        const down = eng.getDownloadRate();\n        const clients = eng.getClients();\n\n        // Compute live state hash (use custom callback if set, otherwise use engine's hash)\n        let currentHash = '--------';\n        try {\n            if (hashCallback) {\n                const hash = hashCallback();\n                currentHash = typeof hash === 'number' ? hash.toString(16).padStart(8, '0') : String(hash).slice(0, 8);\n            } else {\n                const hash = eng.getStateHash();\n                currentHash = hash.toString(16).padStart(8, '0');\n            }\n        } catch (e) {\n            currentHash = 'error';\n        }\n\n        // Format bandwidth with appropriate unit\n        const formatBandwidth = (bytes: number): string => {\n            if (bytes >= 1024) {\n                return (bytes / 1024).toFixed(1) + ' kB/s';\n            }\n            return Math.round(bytes) + ' B/s';\n        };\n        const upStr = formatBandwidth(up);\n        const downStr = formatBandwidth(down);\n\n        // Get delta bandwidth for sync status\n        const deltaBw = (eng as any).getDeltaBandwidth?.() || 0;\n\n        // Get hash-based sync stats\n        const syncStats = (eng as any).getSyncStats?.() || { syncPercent: 100, passed: 0, failed: 0, isDesynced: false, resyncPending: false };\n        const totalHashChecks = syncStats.passed + syncStats.failed;\n\n        // Format sync status\n        // Priority: 1) Show resync status if pending, 2) Show hash-based sync %, 3) Show \"active\" if delta bw > 0\n        let syncStatus: string;\n        if (syncStats.resyncPending) {\n            // Waiting for resync snapshot\n            syncStatus = '<span style=\"color:#f80\">resyncing...</span>';\n        } else if (syncStats.isDesynced) {\n            // Desynced but no resync available\n            syncStatus = '<span style=\"color:#f00\">DESYNCED</span>';\n        } else if (totalHashChecks > 0) {\n            // Have hash-based sync stats - show percentage\n            const syncPct = (Math.floor(syncStats.syncPercent * 10) / 10).toFixed(1);\n            const syncColor = syncStats.syncPercent === 100 ? '#0f0' :\n                            syncStats.syncPercent >= 99 ? '#ff0' : '#f00';\n            syncStatus = `<span style=\"color:${syncColor}\">${syncPct}%</span> <span style=\"color:#888\">(${totalHashChecks} checks)</span>`;\n        } else if (deltaBw > 0) {\n            // Sending state hashes but no comparisons yet\n            syncStatus = '<span style=\"color:#0f0\">active</span>';\n        } else {\n            // Not connected or sync not started\n            syncStatus = '<span style=\"color:#888\">-</span>';\n        }\n\n        // Format received snapshot info with frames ago\n        const framesAgo = lastSnap.frame ? frame - lastSnap.frame : 0;\n        const snapHashStr = lastSnap.hash !== null ? lastSnap.hash.toString(16).padStart(8, '0') : null;\n        const snapInfo = snapHashStr ? `${snapHashStr} <span style=\"color:#888\">(${framesAgo} ago)</span>` : 'none';\n\n        // Format size with appropriate units\n        const formatSize = (bytes: number): string => {\n            if (bytes >= 1024 * 1024) {\n                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';\n            } else if (bytes >= 1024) {\n                return (bytes / 1024).toFixed(1) + ' KB';\n            }\n            return bytes + ' B';\n        };\n        const sizeStr = lastSnap.size > 0 ? formatSize(lastSnap.size) : '-';\n        // Use local world entity count, not received snapshot count\n        const localEntityCount = (eng as any).getEntityCount?.() || 0;\n        const entityStr = localEntityCount > 0 ? String(localEntityCount) : '-';\n\n        // Section header style\n        const sectionStyle = 'color:#666;font-size:10px;margin-top:6px;margin-bottom:2px;border-bottom:1px solid #333;';\n\n        const deltaBwStr = formatBandwidth(deltaBw);\n\n        debugDiv.innerHTML = `\n            <div style=\"${sectionStyle}\">ROOM</div>\n            <div>ID: <span style=\"color:#fff\">${roomId || '-'}</span></div>\n            <div>Players: <span style=\"color:#ff0\">${clients.length}</span></div>\n            <div>Frame: <span style=\"color:#fff\">${frame}</span></div>\n\n            <div style=\"${sectionStyle}\">CLIENT</div>\n            <div>ID: <span style=\"color:#ff0\">${clientId ? clientId.slice(0, 8) : '-'}</span></div>\n\n            <div style=\"${sectionStyle}\">ENGINE</div>\n            <div>Commit: <span style=\"color:#888\">${ENGINE_VERSION}</span></div>\n            <div>FPS: <span style=\"color:#0f0\">${renderFps}</span> render, <span style=\"color:#0f0\">${fps}</span> tick</div>\n            <div>Net: <span style=\"color:#0f0\">${upStr}</span> up, <span style=\"color:#f80\">${downStr}</span> down</div>\n\n            <div style=\"${sectionStyle}\">STATE SYNC</div>\n            <div>Hash: <span style=\"color:#f0f\">${currentHash}</span></div>\n            <div>Delta: <span style=\"color:#0ff\">${deltaBwStr}</span></div>\n            <div>Sync: ${syncStatus}</div>\n            <div>Entities: <span style=\"color:#fff\">${entityStr}</span></div>\n        `;\n    };\n\n    // Update every frame\n    const loop = (now: number) => {\n        update(now);\n        updateInterval = requestAnimationFrame(loop) as unknown as number;\n    };\n    fpsUpdateTime = performance.now();\n    requestAnimationFrame(loop);\n\n    return debugDiv;\n}\n\n/**\n * Disable debug UI\n */\nexport function disableDebugUI(): void {\n    if (updateInterval) {\n        cancelAnimationFrame(updateInterval);\n        updateInterval = null;\n    }\n    if (debugDiv) {\n        debugDiv.remove();\n        debugDiv = null;\n    }\n    debugTarget = null;\n}\n\n/**\n * Check if debug UI is enabled\n */\nexport function isDebugUIEnabled(): boolean {\n    return debugDiv !== null;\n}\n", "/**\n * Physics 2D Module\n *\n * Deterministic 2D physics engine with fixed-point math.\n * All components use 16.16 fixed-point integers for 100% determinism.\n */\n\n// Shapes and AABB\nexport { Shape2DType, CircleShape, BoxShape2D, Shape2D, AABB2D, aabb2DOverlap, aabb2DUnion, aabb2DArea, createCircle, createBox2D, createBox2DFromSize } from './shapes';\n\n// Collision Layers\nexport { CollisionFilter, Layers, DEFAULT_FILTER, createFilter, shouldCollide, filterCollidingWith, filterExcluding } from './layers';\n\n// Rigid Body\nexport { BodyType2D, Vec2, vec2, vec2Zero, vec2Clone, vec2Add, vec2Sub, vec2Scale, vec2Dot, vec2LengthSq, vec2Cross, RigidBody2D, resetBody2DIdCounter, getBody2DIdCounter, setBody2DIdCounter, createBody2D, setBody2DMass, setBody2DVelocity, applyImpulse2D, applyForce2D } from './rigid-body';\n\n// Collision Detection and Response\nexport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\n\n// Physics World\nexport { World2D, createWorld2D, addBody2D, removeBody2D, stepWorld2D, saveWorldState2D, loadWorldState2D, BodyState2D, WorldState2D } from './world';\n\n// Spatial Partitioning\nexport { SpatialHash2D } from './spatial-hash';\nexport { QuadTree2D } from './quad-tree';\n\n// Triggers/Sensors\nexport { TriggerEvent, TriggerState, makeTrigger } from './trigger';\n", "/**\n * 2D Physics Shapes\n *\n * Defines 2D collision shapes: Circle and Box (AABB).\n * Uses fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpMin, fpMax } from '../../math/fixed';\n\n// ============================================\n// Types\n// ============================================\n\nexport enum Shape2DType {\n    Circle = 0,\n    Box = 1,\n}\n\nexport interface CircleShape {\n    type: Shape2DType.Circle;\n    radius: Fixed;\n}\n\nexport interface BoxShape2D {\n    type: Shape2DType.Box;\n    halfWidth: Fixed;   // Half extent on X axis\n    halfHeight: Fixed;  // Half extent on Y axis\n}\n\nexport type Shape2D = CircleShape | BoxShape2D;\n\n// ============================================\n// AABB (Axis-Aligned Bounding Box)\n// ============================================\n\nexport interface AABB2D {\n    minX: Fixed;\n    minY: Fixed;\n    maxX: Fixed;\n    maxY: Fixed;\n}\n\n/**\n * Check if two AABBs overlap.\n */\nexport function aabb2DOverlap(a: AABB2D, b: AABB2D): boolean {\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\n           a.minY <= b.maxY && a.maxY >= b.minY;\n}\n\n/**\n * Compute the union of two AABBs.\n */\nexport function aabb2DUnion(a: AABB2D, b: AABB2D): AABB2D {\n    return {\n        minX: fpMin(a.minX, b.minX),\n        minY: fpMin(a.minY, b.minY),\n        maxX: fpMax(a.maxX, b.maxX),\n        maxY: fpMax(a.maxY, b.maxY),\n    };\n}\n\n/**\n * Compute the area of an AABB.\n */\nexport function aabb2DArea(aabb: AABB2D): Fixed {\n    const width = aabb.maxX - aabb.minX;\n    const height = aabb.maxY - aabb.minY;\n    return fpMul(width as Fixed, height as Fixed);\n}\n\n// ============================================\n// Shape Factories\n// ============================================\n\n/**\n * Create a circle shape.\n */\nexport function createCircle(radius: number): CircleShape {\n    return {\n        type: Shape2DType.Circle,\n        radius: toFixed(radius),\n    };\n}\n\n/**\n * Create a box shape from half-extents.\n */\nexport function createBox2D(halfWidth: number, halfHeight: number): BoxShape2D {\n    return {\n        type: Shape2DType.Box,\n        halfWidth: toFixed(halfWidth),\n        halfHeight: toFixed(halfHeight),\n    };\n}\n\n/**\n * Create a box shape from full dimensions.\n * Uses bit shift for deterministic halving.\n */\nexport function createBox2DFromSize(width: number, height: number): BoxShape2D {\n    // Use bit shift instead of floating-point division for determinism\n    const halfWidth = (toFixed(width) >> 1) as Fixed;\n    const halfHeight = (toFixed(height) >> 1) as Fixed;\n    return {\n        type: Shape2DType.Box,\n        halfWidth,\n        halfHeight,\n    };\n}\n", "/**\n * Collision Layers\n *\n * Controls which bodies can collide with each other using bitmasks.\n * Layer = \"what am I\", Mask = \"what do I collide with\"\n *\n * Shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Collision Filter\n// ============================================\n\nexport interface CollisionFilter {\n    /** Which layer this body belongs to (single bit) */\n    layer: number;\n    /** Which layers this body collides with (bitmask) */\n    mask: number;\n}\n\n// ============================================\n// Default Layers\n// ============================================\n\nexport const Layers = {\n    NONE: 0,\n    DEFAULT: 1 << 0,      // 1\n    PLAYER: 1 << 1,       // 2\n    ENEMY: 1 << 2,        // 4\n    PROJECTILE: 1 << 3,   // 8\n    ITEM: 1 << 4,         // 16\n    TRIGGER: 1 << 5,      // 32\n    WORLD: 1 << 6,        // 64\n    PROP: 1 << 7,         // 128\n    // Layers 8-15 reserved for game-specific use\n    CUSTOM_1: 1 << 8,\n    CUSTOM_2: 1 << 9,\n    CUSTOM_3: 1 << 10,\n    CUSTOM_4: 1 << 11,\n    CUSTOM_5: 1 << 12,\n    CUSTOM_6: 1 << 13,\n    CUSTOM_7: 1 << 14,\n    CUSTOM_8: 1 << 15,\n    ALL: 0xFFFF           // All layers\n} as const;\n\n// ============================================\n// Default Filter\n// ============================================\n\n/**\n * Default collision filter - collides with everything\n */\nexport const DEFAULT_FILTER: CollisionFilter = {\n    layer: Layers.DEFAULT,\n    mask: Layers.ALL\n};\n\n// ============================================\n// Filter Helpers\n// ============================================\n\n/**\n * Create a collision filter\n */\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\n    return { layer, mask };\n}\n\n/**\n * Check if two filters allow collision\n * Both must have the other in their mask\n */\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\n}\n\n/**\n * Create a filter that collides with specific layers\n */\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\n    let mask = 0;\n    for (const l of collidesWithLayers) {\n        mask |= l;\n    }\n    return { layer, mask };\n}\n\n/**\n * Create a filter that collides with everything except specific layers\n */\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\n    let mask = Layers.ALL;\n    for (const l of excludeLayers) {\n        mask &= ~l;\n    }\n    return { layer, mask };\n}\n", "/**\n * 2D Rigid Body\n *\n * Defines 2D rigid body with position, rotation (angle), velocity.\n * Uses fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2D, Shape2DType, CircleShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);\nconst FRICTION_DEFAULT = toFixed(0.5);\n\n// Pre-computed fixed-point constants for deterministic inertia calculations\nconst FP_ONE_TWELFTH = 5461 as Fixed;  // 65536 / 12 = 5461.33... -> 5461\n\n// ============================================\n// Types\n// ============================================\n\nexport enum BodyType2D {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n/**\n * 2D Vector using fixed-point math.\n */\nexport interface Vec2 {\n    x: Fixed;\n    y: Fixed;\n}\n\nexport function vec2Zero(): Vec2 {\n    return { x: 0, y: 0 };\n}\n\nexport function vec2(x: number, y: number): Vec2 {\n    return { x: toFixed(x), y: toFixed(y) };\n}\n\nexport function vec2Clone(v: Vec2): Vec2 {\n    return { x: v.x, y: v.y };\n}\n\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x + b.x) as Fixed, y: (a.y + b.y) as Fixed };\n}\n\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x - b.x) as Fixed, y: (a.y - b.y) as Fixed };\n}\n\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\n}\n\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\n    return (fpMul(a.x, b.x) + fpMul(a.y, b.y)) as Fixed;\n}\n\nexport function vec2LengthSq(v: Vec2): Fixed {\n    return (fpMul(v.x, v.x) + fpMul(v.y, v.y)) as Fixed;\n}\n\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\n    // 2D cross product returns scalar (z component of 3D cross)\n    return (fpMul(a.x, b.y) - fpMul(a.y, b.x)) as Fixed;\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody2D {\n    id: number;\n    type: BodyType2D;\n    shape: Shape2D;\n    label: string;\n\n    // Transform\n    position: Vec2;\n    angle: Fixed;  // Rotation in radians (not quaternion like 3D)\n\n    // Velocity\n    linearVelocity: Vec2;\n    angularVelocity: Fixed;  // Radians per second\n\n    // Mass properties\n    mass: Fixed;\n    invMass: Fixed;\n    inertia: Fixed;\n    invInertia: Fixed;\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotation: boolean;\n    isSensor: boolean;\n    isBullet: boolean;  // Enable CCD (continuous collision detection) for fast-moving objects\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId2D = 1;\n\nexport function resetBody2DIdCounter(): void {\n    nextBodyId2D = 1;\n}\n\nexport function getBody2DIdCounter(): number {\n    return nextBodyId2D;\n}\n\nexport function setBody2DIdCounter(value: number): void {\n    nextBodyId2D = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody2D(\n    type: BodyType2D,\n    shape: Shape2D,\n    x: number,\n    y: number,\n    label?: string\n): RigidBody2D {\n    const mass = type === BodyType2D.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType2D.Dynamic ? FP_ONE : 0;\n\n    // Calculate moment of inertia using pre-computed constants\n    let inertia = 0;\n    if (type === BodyType2D.Dynamic) {\n        if (shape.type === Shape2DType.Circle) {\n            // I = (1/2) * m * r\u00B2\n            const r = (shape as CircleShape).radius;\n            inertia = fpMul(fpMul(mass, FP_HALF), fpMul(r, r));\n        } else {\n            // I = (1/12) * m * (w\u00B2 + h\u00B2)\n            // Use bit shift for *2 instead of fpMul with toFixed(2)\n            const w = (shape.halfWidth << 1) as Fixed;\n            const h = (shape.halfHeight << 1) as Fixed;\n            inertia = fpMul(fpMul(mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\n        }\n    }\n\n    // Always increment counter for new bodies (ID will be overwritten for snapshot restoration)\n    const bodyId = nextBodyId2D++;\n    const bodyLabel = label || 'body2d_' + bodyId;\n\n    return {\n        id: bodyId,\n        type,\n        shape,\n        label: bodyLabel,\n        position: vec2(x, y),\n        angle: 0,\n        linearVelocity: vec2Zero(),\n        angularVelocity: 0,\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotation: false,\n        isSensor: false,\n        isBullet: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBody2DMass(body: RigidBody2D, mass: number): void {\n    if (body.type !== BodyType2D.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBody2DVelocity(body: RigidBody2D, vx: number, vy: number): void {\n    body.linearVelocity = vec2(vx, vy);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse2D(body: RigidBody2D, impulse: Vec2, point?: Vec2): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(impulse, body.invMass));\n\n    if (point && !body.lockRotation) {\n        const r = vec2Sub(point, body.position);\n        const torque = vec2Cross(r, impulse);\n        body.angularVelocity = (body.angularVelocity + fpMul(torque, body.invInertia)) as Fixed;\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce2D(body: RigidBody2D, force: Vec2, dt: Fixed): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n    const impulse = vec2Scale(force, dt);\n    applyImpulse2D(body, impulse);\n}\n", "/**\n * 2D Collision Detection and Response\n *\n * Uses Box2D-style collision detection:\n * - SAT (Separating Axis Theorem) for box-box\n * - Closest point on box for circle-box\n * - Direct distance for circle-circle\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt, fpMin, fpMax, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2DType, Shape2D, CircleShape, BoxShape2D, AABB2D } from './shapes';\nimport { RigidBody2D, Vec2, vec2, vec2Zero, vec2Sub, vec2Add, vec2Scale, vec2Dot, vec2LengthSq, BodyType2D } from './rigid-body';\n\n// ============================================\n// Contact\n// ============================================\n\nexport interface Contact2D {\n    bodyA: RigidBody2D;\n    bodyB: RigidBody2D;\n    point: Vec2;\n    normal: Vec2;  // Points from A to B\n    depth: Fixed;\n}\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB2D(body: RigidBody2D): AABB2D {\n    const { position, shape, angle } = body;\n\n    if (shape.type === Shape2DType.Circle) {\n        const radius = (shape as CircleShape).radius;\n        return {\n            minX: (position.x - radius) as Fixed,\n            minY: (position.y - radius) as Fixed,\n            maxX: (position.x + radius) as Fixed,\n            maxY: (position.y + radius) as Fixed,\n        };\n    } else {\n        const box = shape as BoxShape2D;\n        const halfWidth = box.halfWidth;\n        const halfHeight = box.halfHeight;\n\n        if (angle === 0) {\n            return {\n                minX: (position.x - halfWidth) as Fixed,\n                minY: (position.y - halfHeight) as Fixed,\n                maxX: (position.x + halfWidth) as Fixed,\n                maxY: (position.y + halfHeight) as Fixed,\n            };\n        }\n\n        // Rotated box - compute bounding box\n        const cosAngle = fpCos(angle);\n        const sinAngle = fpSin(angle);\n        const absCos = fpAbs(cosAngle);\n        const absSin = fpAbs(sinAngle);\n\n        const extentX = (fpMul(halfWidth, absCos) + fpMul(halfHeight, absSin)) as Fixed;\n        const extentY = (fpMul(halfWidth, absSin) + fpMul(halfHeight, absCos)) as Fixed;\n\n        return {\n            minX: (position.x - extentX) as Fixed,\n            minY: (position.y - extentY) as Fixed,\n            maxX: (position.x + extentX) as Fixed,\n            maxY: (position.y + extentY) as Fixed,\n        };\n    }\n}\n\n// ============================================\n// Collision Detection\n// ============================================\n\nexport function detectCollision2D(bodyA: RigidBody2D, bodyB: RigidBody2D): Contact2D | null {\n    const shapeA = bodyA.shape;\n    const shapeB = bodyB.shape;\n\n    // Circle-Circle\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Circle) {\n        return detectCircleCircle(bodyA, bodyB);\n    }\n\n    // Box-Box\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Box) {\n        return detectBoxBox(bodyA, bodyB);\n    }\n\n    // Circle-Box (ensure circle is always first for consistent normal direction)\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Box) {\n        return detectCircleBox(bodyA, bodyB);\n    }\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Circle) {\n        const contact = detectCircleBox(bodyB, bodyA);\n        if (contact) {\n            // Swap bodies and flip normal to maintain A->B convention\n            return {\n                bodyA: bodyA,\n                bodyB: bodyB,\n                point: contact.point,\n                normal: { x: (-contact.normal.x) as Fixed, y: (-contact.normal.y) as Fixed },\n                depth: contact.depth\n            };\n        }\n        return null;\n    }\n\n    return null;\n}\n\n/**\n * Circle vs Circle collision detection\n */\nfunction detectCircleCircle(circleA: RigidBody2D, circleB: RigidBody2D): Contact2D | null {\n    const radiusA = (circleA.shape as CircleShape).radius;\n    const radiusB = (circleB.shape as CircleShape).radius;\n    const sumRadius = (radiusA + radiusB) as Fixed;\n\n    // Vector from A to B\n    const deltaX = (circleB.position.x - circleA.position.x) as Fixed;\n    const deltaY = (circleB.position.y - circleA.position.y) as Fixed;\n    const distanceSq = (fpMul(deltaX, deltaX) + fpMul(deltaY, deltaY)) as Fixed;\n    const minDistSq = fpMul(sumRadius, sumRadius);\n\n    if (distanceSq >= minDistSq) return null;\n\n    const distance = fpSqrt(distanceSq);\n    const penetration = (sumRadius - distance) as Fixed;\n\n    // Normal points from A to B\n    let normalX: Fixed, normalY: Fixed;\n    if (distance > 0) {\n        const invDist = fpDiv(FP_ONE, distance);\n        normalX = fpMul(deltaX, invDist);\n        normalY = fpMul(deltaY, invDist);\n    } else {\n        // Circles at same position - arbitrary normal\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n    }\n\n    // Contact point on surface of A\n    const contactX = (circleA.position.x + fpMul(normalX, radiusA)) as Fixed;\n    const contactY = (circleA.position.y + fpMul(normalY, radiusA)) as Fixed;\n\n    return {\n        bodyA: circleA,\n        bodyB: circleB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Box vs Box collision detection (AABB - assumes no rotation)\n */\nfunction detectBoxBox(boxA: RigidBody2D, boxB: RigidBody2D): Contact2D | null {\n    const shapeA = boxA.shape as BoxShape2D;\n    const shapeB = boxB.shape as BoxShape2D;\n\n    // Vector from A to B\n    const deltaX = (boxB.position.x - boxA.position.x) as Fixed;\n    const deltaY = (boxB.position.y - boxA.position.y) as Fixed;\n\n    // Overlap on each axis\n    const overlapX = ((shapeA.halfWidth + shapeB.halfWidth) - fpAbs(deltaX)) as Fixed;\n    const overlapY = ((shapeA.halfHeight + shapeB.halfHeight) - fpAbs(deltaY)) as Fixed;\n\n    if (overlapX <= 0 || overlapY <= 0) return null;\n\n    // Use axis with minimum overlap (SAT)\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (overlapX < overlapY) {\n        penetration = overlapX;\n        normalX = deltaX > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n        normalY = 0 as Fixed;\n    } else {\n        penetration = overlapY;\n        normalX = 0 as Fixed;\n        normalY = deltaY > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n    }\n\n    // Contact point at midpoint\n    const contactX = ((boxA.position.x + boxB.position.x) >> 1) as Fixed;\n    const contactY = ((boxA.position.y + boxB.position.y) >> 1) as Fixed;\n\n    return {\n        bodyA: boxA,\n        bodyB: boxB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Circle vs Box collision detection\n * Box2D-style: find closest point on box, check distance to circle center\n */\nfunction detectCircleBox(circle: RigidBody2D, box: RigidBody2D): Contact2D | null {\n    const radius = (circle.shape as CircleShape).radius;\n    const boxShape = box.shape as BoxShape2D;\n\n    // Circle center in box's local space (box at origin)\n    const localX = (circle.position.x - box.position.x) as Fixed;\n    const localY = (circle.position.y - box.position.y) as Fixed;\n\n    // Clamp to box bounds to find closest point\n    const clampedX = fpMax((-boxShape.halfWidth) as Fixed, fpMin(boxShape.halfWidth, localX));\n    const clampedY = fpMax((-boxShape.halfHeight) as Fixed, fpMin(boxShape.halfHeight, localY));\n\n    // Check if circle center is inside box\n    const centerInside = fpAbs(localX) < boxShape.halfWidth && fpAbs(localY) < boxShape.halfHeight;\n\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (centerInside) {\n        // Circle center is inside box - find closest face\n        const distToRight = (boxShape.halfWidth - localX) as Fixed;\n        const distToLeft = (boxShape.halfWidth + localX) as Fixed;\n        const distToTop = (boxShape.halfHeight - localY) as Fixed;\n        const distToBottom = (boxShape.halfHeight + localY) as Fixed;\n\n        // Find minimum distance to any face\n        let minDist = distToRight;\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n\n        if (distToLeft < minDist) {\n            minDist = distToLeft;\n            normalX = (-FP_ONE) as Fixed;\n            normalY = 0 as Fixed;\n        }\n        if (distToTop < minDist) {\n            minDist = distToTop;\n            normalX = 0 as Fixed;\n            normalY = FP_ONE;\n        }\n        if (distToBottom < minDist) {\n            minDist = distToBottom;\n            normalX = 0 as Fixed;\n            normalY = (-FP_ONE) as Fixed;\n        }\n\n        // Penetration is distance to face plus radius\n        penetration = (minDist + radius) as Fixed;\n    } else {\n        // Circle center is outside box - normal case\n        const diffX = (localX - clampedX) as Fixed;\n        const diffY = (localY - clampedY) as Fixed;\n        const distanceSq = (fpMul(diffX, diffX) + fpMul(diffY, diffY)) as Fixed;\n\n        // No collision if distance > radius\n        if (distanceSq >= fpMul(radius, radius)) return null;\n\n        const distance = fpSqrt(distanceSq);\n        penetration = (radius - distance) as Fixed;\n\n        if (distance > 0) {\n            const invDist = fpDiv(FP_ONE, distance);\n            // Normal points from circle toward box (from A to B)\n            // diffX/diffY points from box surface toward circle, so negate\n            normalX = fpMul((-diffX) as Fixed, invDist);\n            normalY = fpMul((-diffY) as Fixed, invDist);\n        } else {\n            // Edge case: circle exactly on box corner\n            normalX = FP_ONE;\n            normalY = 0 as Fixed;\n        }\n    }\n\n    // Contact point on circle surface (toward box)\n    const contactX = (circle.position.x + fpMul(normalX, radius)) as Fixed;\n    const contactY = (circle.position.y + fpMul(normalY, radius)) as Fixed;\n\n    return {\n        bodyA: circle,\n        bodyB: box,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\n/**\n * Resolve collision by applying position correction and velocity impulses.\n *\n * For kinematic bodies: position correction only (no velocity response)\n * For dynamic bodies: both position and velocity correction\n */\nexport function resolveCollision2D(contact: Contact2D): void {\n    const { bodyA, bodyB, normal, depth } = contact;\n\n    // Skip triggers\n    if (bodyA.isSensor || bodyB.isSensor) return;\n\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Static-Static: nothing to do\n    if (typeA === BodyType2D.Static && typeB === BodyType2D.Static) return;\n\n    // Apply position correction based on body types\n    applyPositionCorrection(bodyA, bodyB, normal, depth);\n\n    // Apply velocity impulses only for dynamic bodies\n    if (typeA === BodyType2D.Dynamic || typeB === BodyType2D.Dynamic) {\n        applyVelocityImpulse(bodyA, bodyB, normal);\n    }\n}\n\n/**\n * Apply position correction to separate overlapping bodies.\n * Called once per contact, not iterated.\n */\nfunction applyPositionCorrection(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    depth: Fixed\n): void {\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Determine how to distribute the correction\n    const aMovable = typeA !== BodyType2D.Static;\n    const bMovable = typeB !== BodyType2D.Static;\n\n    if (!aMovable && !bMovable) return;\n\n    // Tiny slop to prevent jitter (0.01 units)\n    const slop = toFixed(0.01);\n    const correctionDepth = fpMax(0 as Fixed, (depth - slop) as Fixed);\n\n    if (correctionDepth <= 0) return;\n\n    if (aMovable && bMovable) {\n        // Both movable: split correction equally\n        const halfCorrection = (correctionDepth >> 1) as Fixed;\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, halfCorrection)) as Fixed;\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, halfCorrection)) as Fixed;\n    } else if (aMovable) {\n        // Only A moves\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, correctionDepth)) as Fixed;\n    } else {\n        // Only B moves\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, correctionDepth)) as Fixed;\n    }\n}\n\n/**\n * Apply velocity impulse for dynamic body collisions.\n */\nfunction applyVelocityImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2\n): void {\n    // Get effective inverse masses (0 for non-dynamic)\n    const invMassA = bodyA.type === BodyType2D.Dynamic ? bodyA.invMass : 0 as Fixed;\n    const invMassB = bodyB.type === BodyType2D.Dynamic ? bodyB.invMass : 0 as Fixed;\n    const totalInvMass = (invMassA + invMassB) as Fixed;\n\n    if (totalInvMass === 0) return;\n\n    // Relative velocity (B relative to A)\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    // Velocity along collision normal\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Don't resolve if separating\n    if (velAlongNormal > 0) return;\n\n    // Coefficient of restitution (bounciness)\n    const restitution = fpMin(bodyA.restitution, bodyB.restitution);\n\n    // Impulse magnitude\n    const impulseMag = fpDiv(\n        fpMul((-(FP_ONE + restitution)) as Fixed, velAlongNormal),\n        totalInvMass\n    );\n\n    // Apply impulse\n    const impulseX = fpMul(normal.x, impulseMag);\n    const impulseY = fpMul(normal.y, impulseMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(impulseX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(impulseY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(impulseX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(impulseY, invMassB)) as Fixed;\n    }\n\n    // Friction impulse\n    applyFrictionImpulse(bodyA, bodyB, normal, impulseMag, invMassA, invMassB, totalInvMass);\n}\n\n/**\n * Apply friction impulse tangent to collision normal.\n */\nfunction applyFrictionImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    normalImpulse: Fixed,\n    invMassA: Fixed,\n    invMassB: Fixed,\n    totalInvMass: Fixed\n): void {\n    // Recalculate relative velocity after normal impulse\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Tangent velocity\n    const tangentX = (relVelX - fpMul(normal.x, velAlongNormal)) as Fixed;\n    const tangentY = (relVelY - fpMul(normal.y, velAlongNormal)) as Fixed;\n    const tangentLenSq = (fpMul(tangentX, tangentX) + fpMul(tangentY, tangentY)) as Fixed;\n\n    if (tangentLenSq === 0) return;\n\n    const tangentLen = fpSqrt(tangentLenSq);\n    const invTangentLen = fpDiv(FP_ONE, tangentLen);\n    const tangentNormX = fpMul(tangentX, invTangentLen);\n    const tangentNormY = fpMul(tangentY, invTangentLen);\n\n    // Friction coefficient\n    const friction = fpMul(bodyA.friction, bodyB.friction);\n\n    // Friction impulse magnitude\n    const tangentVel = (fpMul(relVelX, tangentNormX) + fpMul(relVelY, tangentNormY)) as Fixed;\n    let frictionMag = fpDiv(-tangentVel, totalInvMass);\n\n    // Coulomb friction: clamp to mu * normal force\n    const maxFriction = fpMul(friction, fpAbs(normalImpulse));\n    if (fpAbs(frictionMag) > maxFriction) {\n        frictionMag = frictionMag > 0 ? maxFriction : (-maxFriction) as Fixed;\n    }\n\n    // Apply friction\n    const frictionX = fpMul(tangentNormX, frictionMag);\n    const frictionY = fpMul(tangentNormY, frictionMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(frictionX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(frictionY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(frictionX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(frictionY, invMassB)) as Fixed;\n    }\n}\n", "/**\n * Spatial Hash Grid for O(1) Broad Phase Collision Detection\n *\n * Divides the world into fixed-size cells. Bodies are hashed to cells\n * based on their position. Collision queries only check nearby cells.\n *\n * Handles oversized entities (larger than cell size) by checking them\n * against all other entities - since there are typically few of these,\n * the O(n) cost is acceptable.\n *\n * Optimal for .io games with many uniform-sized entities (food, bullets)\n * plus a few large obstacles or grown players.\n */\n\nimport { RigidBody2D } from './rigid-body';\nimport { Fixed, toFloat, dSqrt } from '../../math/fixed';\nimport { Shape2DType, CircleShape, BoxShape2D } from './shapes';\n\n// ============================================\n// Helper: Get body radius for size comparison\n// ============================================\n\nfunction getBodyRadius(body: RigidBody2D): number {\n    if (body.shape.type === Shape2DType.Circle) {\n        return toFloat((body.shape as CircleShape).radius);\n    } else {\n        const box = body.shape as BoxShape2D;\n        // Use diagonal half-length as radius\n        const hw = toFloat(box.halfWidth);\n        const hh = toFloat(box.halfHeight);\n        return dSqrt(hw * hw + hh * hh);\n    }\n}\n\n// ============================================\n// Spatial Hash Grid\n// ============================================\n\nexport class SpatialHash2D {\n    private cellSize: number;\n    private invCellSize: number;\n    private cells: Map<number, RigidBody2D[]> = new Map();\n    private bodyToCell: Map<RigidBody2D, number> = new Map();\n\n    // Oversized entities (diameter > cellSize) - checked against all others\n    private oversized: RigidBody2D[] = [];\n    // All regular (non-oversized) bodies for oversized checks\n    private allRegular: RigidBody2D[] = [];\n\n    /**\n     * Create a spatial hash grid.\n     * @param cellSize Size of each cell. Entities larger than this are\n     *                 handled specially (checked against all others).\n     */\n    constructor(cellSize: number = 64) {\n        this.cellSize = cellSize;\n        this.invCellSize = 1 / cellSize;\n    }\n\n    /**\n     * Hash a position to a cell key.\n     * Uses bit packing for fast integer key: (x << 16) | y\n     */\n    private hashPosition(x: number, y: number): number {\n        const cellX = Math.floor(x * this.invCellSize) & 0xFFFF;\n        const cellY = Math.floor(y * this.invCellSize) & 0xFFFF;\n        return (cellX << 16) | cellY;\n    }\n\n    /**\n     * Clear all cells (call at start of each frame).\n     */\n    clear(): void {\n        this.cells.clear();\n        this.bodyToCell.clear();\n        this.oversized.length = 0;\n        this.allRegular.length = 0;\n    }\n\n    /**\n     * Insert a body into the grid.\n     * Oversized bodies (diameter > cellSize) are tracked separately.\n     */\n    insert(body: RigidBody2D): void {\n        const radius = getBodyRadius(body);\n        const diameter = radius * 2;\n\n        // Oversized entities are checked against everything\n        if (diameter > this.cellSize) {\n            this.oversized.push(body);\n            return;\n        }\n\n        // Regular entities go into spatial hash\n        this.allRegular.push(body);\n\n        const x = toFloat(body.position.x);\n        const y = toFloat(body.position.y);\n        const key = this.hashPosition(x, y);\n\n        let cell = this.cells.get(key);\n        if (!cell) {\n            cell = [];\n            this.cells.set(key, cell);\n        }\n        cell.push(body);\n        this.bodyToCell.set(body, key);\n    }\n\n    /**\n     * Insert all bodies into the grid.\n     */\n    insertAll(bodies: RigidBody2D[]): void {\n        for (const body of bodies) {\n            this.insert(body);\n        }\n    }\n\n    /**\n     * Get all bodies in the same cell as a position.\n     */\n    queryPoint(x: number, y: number): RigidBody2D[] {\n        const key = this.hashPosition(x, y);\n        return this.cells.get(key) || [];\n    }\n\n    /**\n     * Get all bodies in the same and adjacent cells (3x3 neighborhood).\n     * This handles bodies near cell boundaries.\n     */\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\n        const x = toFloat(body.position.x);\n        const y = toFloat(body.position.y);\n        const cellX = Math.floor(x * this.invCellSize);\n        const cellY = Math.floor(y * this.invCellSize);\n\n        const result: RigidBody2D[] = [];\n\n        // Check 3x3 grid of cells\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                const nx = (cellX + dx) & 0xFFFF;\n                const ny = (cellY + dy) & 0xFFFF;\n                const key = (nx << 16) | ny;\n                const cell = this.cells.get(key);\n                if (cell) {\n                    for (const other of cell) {\n                        if (other !== body) {\n                            result.push(other);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Query bodies within a radius (for larger entities that span multiple cells).\n     */\n    queryRadius(x: number, y: number, radius: number): RigidBody2D[] {\n        const cellRadius = Math.ceil(radius * this.invCellSize);\n        const cellX = Math.floor(x * this.invCellSize);\n        const cellY = Math.floor(y * this.invCellSize);\n\n        const result: RigidBody2D[] = [];\n        const seen = new Set<RigidBody2D>();\n\n        for (let dx = -cellRadius; dx <= cellRadius; dx++) {\n            for (let dy = -cellRadius; dy <= cellRadius; dy++) {\n                const nx = (cellX + dx) & 0xFFFF;\n                const ny = (cellY + dy) & 0xFFFF;\n                const key = (nx << 16) | ny;\n                const cell = this.cells.get(key);\n                if (cell) {\n                    for (const body of cell) {\n                        if (!seen.has(body)) {\n                            seen.add(body);\n                            result.push(body);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Iterate over potential collision pairs, calling the callback for each.\n     * Each pair is visited exactly once. No Set or deduplication needed -\n     * the algorithm structure guarantees uniqueness.\n     */\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\n        for (const [key, cell] of this.cells) {\n            // Check within same cell - pairs (i, j) where i < j are unique\n            for (let i = 0; i < cell.length; i++) {\n                for (let j = i + 1; j < cell.length; j++) {\n                    callback(cell[i], cell[j]);\n                }\n            }\n\n            // Check against neighbor cells with HIGHER keys only\n            // This ensures each cross-cell pair is checked exactly once\n            const cellX = (key >> 16) & 0xFFFF;\n            const cellY = key & 0xFFFF;\n\n            // Only check neighbors with higher cell keys to avoid duplicates\n            const neighbors = [\n                ((cellX + 1) & 0xFFFF) << 16 | cellY,           // Right (+x)\n                (cellX << 16) | ((cellY + 1) & 0xFFFF),         // Below (+y)\n                (((cellX + 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF), // Below-right (+x,+y)\n            ];\n\n            for (const neighborKey of neighbors) {\n                // Only process if neighbor key > current key (avoids duplicates)\n                if (neighborKey <= key) continue;\n\n                const neighborCell = this.cells.get(neighborKey);\n                if (!neighborCell) continue;\n\n                for (const a of cell) {\n                    for (const b of neighborCell) {\n                        callback(a, b);\n                    }\n                }\n            }\n\n            // Below-left neighbor needs special handling (has lower x but higher y)\n            const belowLeftKey = (((cellX - 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF);\n            const belowLeftCell = this.cells.get(belowLeftKey);\n            if (belowLeftCell) {\n                for (const a of cell) {\n                    for (const b of belowLeftCell) {\n                        callback(a, b);\n                    }\n                }\n            }\n        }\n\n        // Handle oversized entities - check against ALL other entities\n        // This is O(oversized * total) but there are typically very few oversized entities\n        const oversized = this.oversized;\n        const allRegular = this.allRegular;\n\n        // Oversized vs oversized\n        for (let i = 0; i < oversized.length; i++) {\n            for (let j = i + 1; j < oversized.length; j++) {\n                callback(oversized[i], oversized[j]);\n            }\n        }\n\n        // Oversized vs all regular entities\n        for (const big of oversized) {\n            for (const small of allRegular) {\n                callback(big, small);\n            }\n        }\n    }\n\n    /**\n     * Get potential collision pairs as an array.\n     * For large body counts, prefer forEachPair() to avoid array allocation.\n     */\n    getPotentialPairs(): Array<[RigidBody2D, RigidBody2D]> {\n        const pairs: Array<[RigidBody2D, RigidBody2D]> = [];\n        this.forEachPair((a, b) => pairs.push([a, b]));\n        return pairs;\n    }\n\n    /**\n     * Get statistics for debugging.\n     */\n    getStats(): { cellCount: number; maxPerCell: number; avgPerCell: number; oversizedCount: number } {\n        let maxPerCell = 0;\n        let totalBodies = 0;\n\n        for (const cell of this.cells.values()) {\n            maxPerCell = Math.max(maxPerCell, cell.length);\n            totalBodies += cell.length;\n        }\n\n        return {\n            cellCount: this.cells.size,\n            maxPerCell,\n            avgPerCell: this.cells.size > 0 ? totalBodies / this.cells.size : 0,\n            oversizedCount: this.oversized.length\n        };\n    }\n}\n", "/**\n * 2D Physics World\n *\n * Manages the 2D physics simulation including gravity, collision detection,\n * and integration of velocities and positions.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, toFloat, fpMul, fpDiv, fpAbs } from '../../math/fixed';\nimport { aabb2DOverlap, Shape2D, Shape2DType, CircleShape, BoxShape2D } from './shapes';\nimport { RigidBody2D, BodyType2D, Vec2, vec2, vec2Zero, vec2Add, vec2Scale, vec2LengthSq, createBody2D, setBody2DIdCounter, getBody2DIdCounter } from './rigid-body';\nimport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\nimport { shouldCollide, CollisionFilter, DEFAULT_FILTER } from './layers';\nimport { TriggerState, TriggerEvent } from './trigger';\nimport { SpatialHash2D } from './spatial-hash';\n\n// ============================================\n// Constants\n// ============================================\n\nconst GRAVITY_2D: Vec2 = { x: 0, y: toFixed(-30) };  // -30 units/s\u00B2 (down in Y)\nconst LINEAR_DAMPING = toFixed(0.1);\nconst ANGULAR_DAMPING = toFixed(0.1);\nconst SLEEP_THRESHOLD = toFixed(0.12);\nconst SLEEP_FRAMES_REQUIRED = 20;\n\n// Default spatial hash cell size - should be >= largest entity diameter\nconst DEFAULT_CELL_SIZE = 64;\n\n// ============================================\n// Trigger Event 2D\n// ============================================\n\nexport interface TriggerEvent2D {\n    trigger: RigidBody2D;\n    other: RigidBody2D;\n}\n\n// ============================================\n// Contact Listener\n// ============================================\n\nexport interface ContactListener2D {\n    onContact(bodyA: RigidBody2D, bodyB: RigidBody2D): void;\n}\n\n// ============================================\n// World Interface\n// ============================================\n\nexport interface World2D {\n    bodies: RigidBody2D[];\n    gravity: Vec2;\n    dt: Fixed;\n    contactListener?: ContactListener2D;\n    /** Reference to Physics2D system for type-based collision handling */\n    physics2d?: any;\n    /** Step the physics simulation */\n    step(): void;\n}\n\nexport function createWorld2D(dt: number = 1 / 60): World2D {\n    const world: World2D = {\n        bodies: [],\n        gravity: { x: GRAVITY_2D.x, y: GRAVITY_2D.y },\n        dt: toFixed(dt),\n        step() {\n            stepWorld2D(world);\n        }\n    };\n    return world;\n}\n\nexport function addBody2D(world: World2D, body: RigidBody2D): void {\n    world.bodies.push(body);\n}\n\nexport function removeBody2D(world: World2D, body: RigidBody2D): void {\n    const index = world.bodies.indexOf(body);\n    if (index >= 0) {\n        world.bodies.splice(index, 1);\n    }\n}\n\n// ============================================\n// World Step\n// ============================================\n\nexport function stepWorld2D(world: World2D): { contacts: Contact2D[]; triggers: TriggerEvent2D[] } {\n    const { gravity, dt } = world;\n    const contacts: Contact2D[] = [];\n    const triggerOverlaps: TriggerEvent2D[] = [];\n\n    // Collect collision pairs for deterministic callback firing AFTER detection\n    const collisionPairs: Array<{ entityA: any; entityB: any; labelA: string; labelB: string }> = [];\n\n    // Sort bodies by label (eid) NUMERICALLY for deterministic collision processing\n    // CRITICAL: Labels are eid.toString(), so we must parse them as numbers!\n    // localeCompare would sort \"1\", \"10\", \"2\" instead of 1, 2, 10\n    const bodies = [...world.bodies].sort((a, b) => {\n        const eidA = parseInt(a.label, 10) || 0;\n        const eidB = parseInt(b.label, 10) || 0;\n        return eidA - eidB;\n    });\n\n    // Integrate velocities (apply gravity)\n    for (const body of bodies) {\n        if (body.type !== BodyType2D.Dynamic) continue;\n        if (body.isSleeping) continue;\n\n        // Apply gravity\n        body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(gravity, dt));\n\n        // Apply damping\n        const linearDamp = (FP_ONE - LINEAR_DAMPING) as Fixed;\n        const angularDamp = (FP_ONE - ANGULAR_DAMPING) as Fixed;\n\n        body.linearVelocity = vec2Scale(body.linearVelocity, linearDamp);\n        body.angularVelocity = fpMul(body.angularVelocity, angularDamp);\n    }\n\n    // Collision detection using spatial hash for O(1) broad phase\n    // Cell size should be >= largest entity diameter for optimal performance\n    const spatialHash = new SpatialHash2D(DEFAULT_CELL_SIZE);\n    spatialHash.insertAll(bodies);\n\n    // CRITICAL: Collect ALL contacts first, then sort and resolve in deterministic order.\n    // The spatial hash forEachPair iterates in Map insertion order, which can differ\n    // between authority (bodies added over time) and late joiners (bodies added sorted).\n    // If we resolve collisions inside the callback, resolution order is non-deterministic,\n    // causing simulation divergence.\n    const pendingContacts: Array<{ contact: Contact2D; labelA: string; labelB: string }> = [];\n\n    // Process potential collision pairs - DETECT only, don't resolve yet\n    spatialHash.forEachPair((bodyA, bodyB) => {\n        // Skip static-static (no collision needed)\n        if (bodyA.type === BodyType2D.Static && bodyB.type === BodyType2D.Static) return;\n        if (!shouldCollide(bodyA.filter, bodyB.filter)) return;\n\n        // Broad phase: AABB overlap test (spatial hash gives candidates, still need precise AABB)\n        const aabbA = computeAABB2D(bodyA);\n        const aabbB = computeAABB2D(bodyB);\n        if (!aabb2DOverlap(aabbA, aabbB)) return;\n\n        // Narrow phase: precise collision detection\n        const contact = detectCollision2D(bodyA, bodyB);\n\n        if (!contact) return;\n\n        // CRITICAL: Normalize pair order so smaller label (eid) is always first.\n        // Without this, spatial hash iteration order determines (A,B) vs (B,A),\n        // causing different sort results between authority and late joiner.\n        // Use numeric comparison since labels are eid.toString()\n        const eidA = parseInt(bodyA.label, 10) || 0;\n        const eidB = parseInt(bodyB.label, 10) || 0;\n        const shouldSwap = eidA > eidB;\n\n        // Collect entity pairs for callback firing (all collisions including sensors)\n        const entityA = bodyA.userData;\n        const entityB = bodyB.userData;\n        if (entityA || entityB) {\n            collisionPairs.push({\n                entityA: shouldSwap ? entityB : entityA,\n                entityB: shouldSwap ? entityA : entityB,\n                labelA: shouldSwap ? bodyB.label : bodyA.label,\n                labelB: shouldSwap ? bodyA.label : bodyB.label\n            });\n        }\n\n        // Sensors: detect overlap but skip physics response\n        if (bodyA.isSensor || bodyB.isSensor) {\n            if (bodyA.isSensor) triggerOverlaps.push({ trigger: bodyA, other: bodyB });\n            if (bodyB.isSensor) triggerOverlaps.push({ trigger: bodyB, other: bodyA });\n            return;\n        }\n\n        // Store contact for later resolution (don't resolve inside callback!)\n        // Use normalized labels (smaller first) for deterministic sorting\n        const normLabelA = shouldSwap ? bodyB.label : bodyA.label;\n        const normLabelB = shouldSwap ? bodyA.label : bodyB.label;\n        pendingContacts.push({ contact, labelA: normLabelA, labelB: normLabelB });\n        contacts.push(contact);\n        // NOTE: contactListener.onContact was removed here - it was firing collision handlers\n        // in non-deterministic (spatial hash iteration) order, causing multiplayer desync.\n        // Collision handlers are now called only via collisionPairs (sorted) below.\n    });\n\n    // CRITICAL: Sort contacts by body labels (eids) NUMERICALLY for deterministic resolution order\n    pendingContacts.sort((a, b) => {\n        const eidA1 = parseInt(a.labelA, 10) || 0;\n        const eidB1 = parseInt(b.labelA, 10) || 0;\n        const cmp = eidA1 - eidB1;\n        if (cmp !== 0) return cmp;\n        const eidA2 = parseInt(a.labelB, 10) || 0;\n        const eidB2 = parseInt(b.labelB, 10) || 0;\n        return eidA2 - eidB2;\n    });\n\n    // Now resolve all collisions in sorted order\n    for (const { contact } of pendingContacts) {\n        resolveCollision2D(contact);\n    }\n\n    // Fire entity collision callbacks AFTER all detection is complete\n    // Sort by both labels (eids) NUMERICALLY to ensure deterministic ordering across clients\n    collisionPairs.sort((a, b) => {\n        const eidA1 = parseInt(a.labelA, 10) || 0;\n        const eidB1 = parseInt(b.labelA, 10) || 0;\n        const cmp = eidA1 - eidB1;\n        if (cmp !== 0) return cmp;\n        const eidA2 = parseInt(a.labelB, 10) || 0;\n        const eidB2 = parseInt(b.labelB, 10) || 0;\n        return eidA2 - eidB2;\n    });\n\n    for (const pair of collisionPairs) {\n        // Check active status at callback time (may have changed during earlier callbacks)\n        if (pair.entityA?.active === false || pair.entityB?.active === false) continue;\n\n        // Try Physics2D type-based handlers first (preferred - auto-restored)\n        if (world.physics2d?.handleCollision?.(pair.entityA, pair.entityB)) {\n            continue; // Handler found and called, skip entity.onCollision\n        }\n\n        // Fall back to entity.onCollision (legacy - requires manual restore in onSnapshot)\n        if (pair.entityA?.onCollision) {\n            pair.entityA.onCollision(pair.entityB);\n        }\n        if (pair.entityB?.onCollision) {\n            pair.entityB.onCollision(pair.entityA);\n        }\n    }\n\n    // Integrate positions\n    for (const body of bodies) {\n        if (body.type === BodyType2D.Static) continue;\n        if (body.isSleeping) continue;\n\n        // Clamp tiny velocities\n        const linearClamp = toFixed(0.05);\n        const angularClamp = toFixed(0.01);\n\n        if (fpAbs(body.linearVelocity.x) < linearClamp) body.linearVelocity.x = 0;\n        if (fpAbs(body.linearVelocity.y) < linearClamp) body.linearVelocity.y = 0;\n        if (fpAbs(body.angularVelocity) < angularClamp) body.angularVelocity = 0;\n\n        // Update position\n        body.position = vec2Add(body.position, vec2Scale(body.linearVelocity, dt));\n\n        // Update angle\n        if (!body.lockRotation && body.angularVelocity !== 0) {\n            body.angle = (body.angle + fpMul(body.angularVelocity, dt)) as Fixed;\n        }\n\n        // Sleep detection\n        const speedSq = vec2LengthSq(body.linearVelocity);\n        const angSpeedSq = fpMul(body.angularVelocity, body.angularVelocity);\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\n\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\n            body.sleepFrames++;\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\n                body.isSleeping = true;\n                body.linearVelocity = vec2Zero();\n                body.angularVelocity = 0;\n            }\n        } else {\n            body.sleepFrames = 0;\n            body.isSleeping = false;\n        }\n    }\n\n    return { contacts, triggers: triggerOverlaps };\n}\n\n// ============================================\n// State Serialization\n// ============================================\n\n/**\n * Serialized shape data for snapshots.\n * Contains all information needed to recreate a shape.\n */\nexport interface ShapeState2D {\n    type: Shape2DType;\n    // Circle\n    radius?: Fixed;\n    // Box\n    halfWidth?: Fixed;\n    halfHeight?: Fixed;\n}\n\n/**\n * Complete body state for snapshots.\n * Contains ALL information needed to recreate a body from scratch.\n * This is critical for late joiners who have an empty world.\n */\nexport interface BodyState2D {\n    // Identity\n    id: number;\n    label: string;\n    bodyType: BodyType2D;\n\n    // Shape (required for body creation)\n    shape: ShapeState2D;\n\n    // Transform\n    px: Fixed;\n    py: Fixed;\n    angle: Fixed;\n\n    // Velocity\n    vx: Fixed;\n    vy: Fixed;\n    av: Fixed;\n\n    // Material properties\n    mass: Fixed;\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State flags\n    isSleeping: boolean;\n    sleepFrames: number;\n    lockRotation: boolean;\n    isSensor: boolean;\n    isBullet: boolean;\n\n    // Collision filter\n    filter: CollisionFilter;\n\n    // User data (game-specific)\n    userData?: any;\n}\n\nexport interface WorldState2D {\n    bodies: BodyState2D[];\n}\n\nexport interface WorldStateWithHash2D {\n    state: WorldState2D;\n    hash: number;\n}\n\n/**\n * Serialize a shape to ShapeState2D.\n */\nfunction serializeShape(shape: Shape2D): ShapeState2D {\n    if (shape.type === Shape2DType.Circle) {\n        return {\n            type: Shape2DType.Circle,\n            radius: (shape as CircleShape).radius,\n        };\n    } else {\n        const box = shape as BoxShape2D;\n        return {\n            type: Shape2DType.Box,\n            halfWidth: box.halfWidth,\n            halfHeight: box.halfHeight,\n        };\n    }\n}\n\n/**\n * Deserialize ShapeState2D back to Shape2D.\n */\nfunction deserializeShape(state: ShapeState2D): Shape2D {\n    if (state.type === Shape2DType.Circle) {\n        return {\n            type: Shape2DType.Circle,\n            radius: state.radius!,\n        } as CircleShape;\n    } else {\n        return {\n            type: Shape2DType.Box,\n            halfWidth: state.halfWidth!,\n            halfHeight: state.halfHeight!,\n        } as BoxShape2D;\n    }\n}\n\n/**\n * Serialize a single body to BodyState2D.\n * Contains ALL information needed to recreate the body.\n */\nfunction serializeBody(b: RigidBody2D): BodyState2D {\n    return {\n        id: b.id,\n        label: b.label,\n        bodyType: b.type,\n        shape: serializeShape(b.shape),\n        px: b.position.x,\n        py: b.position.y,\n        angle: b.angle,\n        vx: b.linearVelocity.x,\n        vy: b.linearVelocity.y,\n        av: b.angularVelocity,\n        mass: b.mass,\n        restitution: b.restitution,\n        friction: b.friction,\n        isSleeping: b.isSleeping,\n        sleepFrames: b.sleepFrames,\n        lockRotation: b.lockRotation,\n        isSensor: b.isSensor,\n        isBullet: b.isBullet,\n        filter: { ...b.filter },\n        userData: b.userData,\n    };\n}\n\n/**\n * Save world state - use saveWorldStateWithHash2D for efficiency when you need both\n */\nexport function saveWorldState2D(world: World2D): WorldState2D {\n    return {\n        bodies: world.bodies.map(serializeBody)\n    };\n}\n\n/**\n * Save world state AND compute hash in a single pass.\n * More efficient than calling saveWorldState2D + separate hash function.\n */\nexport function saveWorldStateWithHash2D(world: World2D): WorldStateWithHash2D {\n    const bodies: BodyState2D[] = [];\n    let hash = 0;\n\n    // Single pass: serialize and hash simultaneously\n    for (const b of world.bodies) {\n        const bs = serializeBody(b);\n        bodies.push(bs);\n\n        // Compute hash inline - include all determinism-relevant state\n        hash = ((hash << 5) - hash + bs.id) >>> 0;\n        hash = ((hash << 5) - hash + bs.bodyType) >>> 0;\n        hash = ((hash << 5) - hash + bs.shape.type) >>> 0;\n        if (bs.shape.radius !== undefined) {\n            hash = ((hash << 5) - hash + bs.shape.radius) >>> 0;\n        }\n        if (bs.shape.halfWidth !== undefined) {\n            hash = ((hash << 5) - hash + bs.shape.halfWidth) >>> 0;\n            hash = ((hash << 5) - hash + bs.shape.halfHeight!) >>> 0;\n        }\n        hash = ((hash << 5) - hash + bs.px) >>> 0;\n        hash = ((hash << 5) - hash + bs.py) >>> 0;\n        hash = ((hash << 5) - hash + bs.vx) >>> 0;\n        hash = ((hash << 5) - hash + bs.vy) >>> 0;\n        hash = ((hash << 5) - hash + bs.angle) >>> 0;\n        hash = ((hash << 5) - hash + bs.av) >>> 0;\n        hash = ((hash << 5) - hash + bs.mass) >>> 0;\n    }\n\n    return { state: { bodies }, hash };\n}\n\n/**\n * Create a body from serialized state.\n * This is used for late joiners who need to recreate bodies from scratch.\n */\nfunction createBodyFromState(bs: BodyState2D): RigidBody2D {\n    const shape = deserializeShape(bs.shape);\n\n    // We need to create the body with the correct ID\n    // Temporarily set the counter to ensure consistent IDs\n    const savedCounter = getBody2DIdCounter();\n\n    // Create body at position (0, 0) - we'll set exact position after\n    // Use toFloat to convert fixed-point back to float for createBody2D\n    const body = createBody2D(bs.bodyType, shape, 0, 0, bs.label);\n\n    // Override the auto-generated ID with the snapshot ID\n    body.id = bs.id;\n\n    // Restore the counter (createBody2D incremented it)\n    // The next new body will use the max ID from snapshot + 1\n    setBody2DIdCounter(savedCounter);\n\n    // Set all properties from snapshot\n    body.position = { x: bs.px, y: bs.py };\n    body.angle = bs.angle;\n    body.linearVelocity = { x: bs.vx, y: bs.vy };\n    body.angularVelocity = bs.av;\n\n    // Mass properties - need to recalculate invMass and inertia\n    body.mass = bs.mass;\n    body.invMass = bs.mass > 0 ? fpDiv(FP_ONE, bs.mass) : 0;\n\n    // Recalculate inertia based on shape and mass\n    if (bs.bodyType === BodyType2D.Dynamic && bs.mass > 0) {\n        if (shape.type === Shape2DType.Circle) {\n            const r = (shape as CircleShape).radius;\n            body.inertia = fpMul(fpMul(bs.mass, FP_HALF), fpMul(r, r));\n        } else {\n            const box = shape as BoxShape2D;\n            const w = (box.halfWidth << 1) as Fixed;\n            const h = (box.halfHeight << 1) as Fixed;\n            const FP_ONE_TWELFTH = 5461 as Fixed;\n            body.inertia = fpMul(fpMul(bs.mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\n        }\n        body.invInertia = body.inertia > 0 ? fpDiv(FP_ONE, body.inertia) : 0;\n    }\n\n    // Material\n    body.restitution = bs.restitution;\n    body.friction = bs.friction;\n\n    // State\n    body.isSleeping = bs.isSleeping;\n    body.sleepFrames = bs.sleepFrames;\n    body.lockRotation = bs.lockRotation;\n    body.isSensor = bs.isSensor;\n    body.isBullet = bs.isBullet ?? false;\n\n    // Collision filter\n    body.filter = { ...bs.filter };\n\n    // User data\n    body.userData = bs.userData;\n\n    return body;\n}\n\n/**\n * Load world state from snapshot.\n *\n * IMPORTANT: This function fully recreates the world from the snapshot.\n * It handles both:\n * 1. Existing worlds (rollback) - updates existing bodies, removes/adds as needed\n * 2. Empty worlds (late joiners) - creates all bodies from scratch\n *\n * The snapshot contains complete body information including shape data,\n * so bodies can be fully recreated without any prior state.\n */\nexport function loadWorldState2D(world: World2D, state: WorldState2D): void {\n    // Sort snapshot bodies by label (eid) NUMERICALLY for deterministic iteration\n    const sortedBodies = [...state.bodies].sort((a, b) => {\n        const eidA = parseInt(a.label, 10) || 0;\n        const eidB = parseInt(b.label, 10) || 0;\n        return eidA - eidB;\n    });\n\n    // Build a set of labels in the snapshot\n    const snapshotLabels = new Set(sortedBodies.map(bs => bs.label));\n\n    // Remove bodies not in snapshot\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\n        if (!snapshotLabels.has(world.bodies[i].label)) {\n            world.bodies.splice(i, 1);\n        }\n    }\n\n    // Build map of existing bodies\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\n\n    // Track the highest ID we see to update the counter\n    let maxId = 0;\n\n    for (const bs of sortedBodies) {\n        if (bs.id > maxId) maxId = bs.id;\n\n        const existingBody = bodyMap.get(bs.label);\n\n        if (existingBody) {\n            // Update existing body\n            existingBody.position = { x: bs.px, y: bs.py };\n            existingBody.angle = bs.angle;\n            existingBody.linearVelocity = { x: bs.vx, y: bs.vy };\n            existingBody.angularVelocity = bs.av;\n            existingBody.isSleeping = bs.isSleeping;\n            existingBody.sleepFrames = bs.sleepFrames;\n            existingBody.lockRotation = bs.lockRotation;\n            existingBody.isSensor = bs.isSensor;\n            existingBody.restitution = bs.restitution;\n            existingBody.friction = bs.friction;\n            existingBody.filter = { ...bs.filter };\n            if (bs.userData !== undefined) {\n                existingBody.userData = bs.userData;\n            }\n        } else {\n            // Create new body from snapshot - this is critical for late joiners\n            const newBody = createBodyFromState(bs);\n            world.bodies.push(newBody);\n        }\n    }\n\n    // Update the body ID counter to be higher than any ID in the snapshot\n    // This ensures new bodies created after loading won't have conflicting IDs\n    const currentCounter = getBody2DIdCounter();\n    if (maxId >= currentCounter) {\n        setBody2DIdCounter(maxId + 1);\n    }\n\n    // Sort world bodies by label (eid) NUMERICALLY for deterministic order\n    world.bodies.sort((a, b) => {\n        const eidA = parseInt(a.label, 10) || 0;\n        const eidB = parseInt(b.label, 10) || 0;\n        return eidA - eidB;\n    });\n}\n", "/**\n * QuadTree for Dynamic Spatial Partitioning\n *\n * Recursively subdivides space based on entity density.\n * Adapts to mixed entity sizes and non-uniform distributions.\n * Ideal for .io games where players grow from tiny to huge.\n */\n\nimport { RigidBody2D } from './rigid-body';\nimport { computeAABB2D } from './collision';\nimport { toFloat } from '../../math/fixed';\n\n// ============================================\n// Configuration\n// ============================================\n\nconst DEFAULT_MAX_ENTITIES = 8;   // Max entities before subdivision\nconst DEFAULT_MAX_DEPTH = 8;      // Max tree depth (prevents infinite subdivision)\n\n// ============================================\n// AABB Helpers\n// ============================================\n\ninterface Bounds {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nfunction boundsContains(bounds: Bounds, x: number, y: number): boolean {\n    return x >= bounds.minX && x <= bounds.maxX &&\n           y >= bounds.minY && y <= bounds.maxY;\n}\n\nfunction boundsIntersects(a: Bounds, b: Bounds): boolean {\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\n           a.minY <= b.maxY && a.maxY >= b.minY;\n}\n\nfunction getBodyBounds(body: RigidBody2D): Bounds {\n    const aabb = computeAABB2D(body);\n    return {\n        minX: toFloat(aabb.minX),\n        minY: toFloat(aabb.minY),\n        maxX: toFloat(aabb.maxX),\n        maxY: toFloat(aabb.maxY)\n    };\n}\n\n// ============================================\n// QuadTree Node\n// ============================================\n\nclass QuadTreeNode {\n    bounds: Bounds;\n    depth: number;\n    maxEntities: number;\n    maxDepth: number;\n\n    // Entities stored in this node (entities that span multiple children stay here)\n    entities: RigidBody2D[] = [];\n\n    // Child quadrants: NW, NE, SW, SE (null until subdivided)\n    children: [QuadTreeNode, QuadTreeNode, QuadTreeNode, QuadTreeNode] | null = null;\n\n    constructor(bounds: Bounds, depth: number, maxEntities: number, maxDepth: number) {\n        this.bounds = bounds;\n        this.depth = depth;\n        this.maxEntities = maxEntities;\n        this.maxDepth = maxDepth;\n    }\n\n    /**\n     * Insert an entity into the tree.\n     */\n    insert(body: RigidBody2D, bodyBounds: Bounds): void {\n        // If we have children, try to insert into a child\n        if (this.children) {\n            const index = this.getChildIndex(bodyBounds);\n            if (index !== -1) {\n                this.children[index].insert(body, bodyBounds);\n                return;\n            }\n            // Entity spans multiple quadrants - store in this node\n            this.entities.push(body);\n            return;\n        }\n\n        // No children yet - store in this node\n        this.entities.push(body);\n\n        // Subdivide if we have too many entities and haven't reached max depth\n        if (this.entities.length > this.maxEntities && this.depth < this.maxDepth) {\n            this.subdivide();\n        }\n    }\n\n    /**\n     * Subdivide this node into 4 children.\n     */\n    private subdivide(): void {\n        const { minX, minY, maxX, maxY } = this.bounds;\n        const midX = (minX + maxX) / 2;\n        const midY = (minY + maxY) / 2;\n\n        this.children = [\n            new QuadTreeNode({ minX, minY, maxX: midX, maxY: midY }, this.depth + 1, this.maxEntities, this.maxDepth),           // NW (top-left)\n            new QuadTreeNode({ minX: midX, minY, maxX, maxY: midY }, this.depth + 1, this.maxEntities, this.maxDepth),           // NE (top-right)\n            new QuadTreeNode({ minX, minY: midY, maxX: midX, maxY }, this.depth + 1, this.maxEntities, this.maxDepth),           // SW (bottom-left)\n            new QuadTreeNode({ minX: midX, minY: midY, maxX, maxY }, this.depth + 1, this.maxEntities, this.maxDepth),           // SE (bottom-right)\n        ];\n\n        // Re-insert entities into children\n        const oldEntities = this.entities;\n        this.entities = [];\n\n        for (const body of oldEntities) {\n            const bodyBounds = getBodyBounds(body);\n            const index = this.getChildIndex(bodyBounds);\n            if (index !== -1) {\n                this.children[index].insert(body, bodyBounds);\n            } else {\n                // Entity spans multiple quadrants - keep in this node\n                this.entities.push(body);\n            }\n        }\n    }\n\n    /**\n     * Get the child index for an entity, or -1 if it spans multiple children.\n     */\n    private getChildIndex(bodyBounds: Bounds): number {\n        const { minX, minY, maxX, maxY } = this.bounds;\n        const midX = (minX + maxX) / 2;\n        const midY = (minY + maxY) / 2;\n\n        const inTop = bodyBounds.maxY <= midY;\n        const inBottom = bodyBounds.minY >= midY;\n        const inLeft = bodyBounds.maxX <= midX;\n        const inRight = bodyBounds.minX >= midX;\n\n        if (inTop && inLeft) return 0;  // NW\n        if (inTop && inRight) return 1; // NE\n        if (inBottom && inLeft) return 2; // SW\n        if (inBottom && inRight) return 3; // SE\n\n        return -1; // Spans multiple quadrants\n    }\n\n    /**\n     * Query all entities that might collide with the given bounds.\n     */\n    query(queryBounds: Bounds, result: RigidBody2D[]): void {\n        // Check entities in this node\n        for (const body of this.entities) {\n            result.push(body);\n        }\n\n        // Check children\n        if (this.children) {\n            for (const child of this.children) {\n                if (boundsIntersects(child.bounds, queryBounds)) {\n                    child.query(queryBounds, result);\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate all potential collision pairs (iterative version).\n     * Uses stack-based traversal to avoid recursive overhead.\n     */\n    forEachPairIterative(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\n        // Stack entries: [node, ancestorStartIndex]\n        const stack: Array<{ node: QuadTreeNode; ancestorStart: number }> = [];\n        const ancestors: RigidBody2D[] = [];\n\n        stack.push({ node: this, ancestorStart: 0 });\n\n        while (stack.length > 0) {\n            const { node, ancestorStart } = stack.pop()!;\n\n            // Trim ancestors to correct level\n            ancestors.length = ancestorStart;\n\n            // Check pairs within this node's entities\n            const entities = node.entities;\n            for (let i = 0; i < entities.length; i++) {\n                for (let j = i + 1; j < entities.length; j++) {\n                    callback(entities[i], entities[j]);\n                }\n            }\n\n            // Check this node's entities against ancestors\n            for (let i = 0; i < ancestorStart; i++) {\n                for (const entity of entities) {\n                    callback(ancestors[i], entity);\n                }\n            }\n\n            // Add this node's entities to ancestors for children\n            const newAncestorStart = ancestors.length;\n            for (const entity of entities) {\n                ancestors.push(entity);\n            }\n\n            // Push children in reverse order (so NW is processed first)\n            if (node.children) {\n                for (let i = 3; i >= 0; i--) {\n                    stack.push({ node: node.children[i], ancestorStart: ancestors.length });\n                }\n            }\n        }\n    }\n\n    /**\n     * Iterate all potential collision pairs.\n     * Callback receives each unique pair exactly once.\n     */\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void, ancestors: RigidBody2D[] = []): void {\n        this.forEachPairIterative(callback);\n    }\n\n    /**\n     * Get statistics about this subtree.\n     */\n    getStats(): { nodeCount: number; maxDepth: number; entityCount: number } {\n        let nodeCount = 1;\n        let maxDepth = this.depth;\n        let entityCount = this.entities.length;\n\n        if (this.children) {\n            for (const child of this.children) {\n                const childStats = child.getStats();\n                nodeCount += childStats.nodeCount;\n                maxDepth = Math.max(maxDepth, childStats.maxDepth);\n                entityCount += childStats.entityCount;\n            }\n        }\n\n        return { nodeCount, maxDepth, entityCount };\n    }\n}\n\n// ============================================\n// QuadTree2D Public API\n// ============================================\n\nexport class QuadTree2D {\n    private root: QuadTreeNode | null = null;\n    private maxEntities: number;\n    private maxDepth: number;\n\n    constructor(maxEntities: number = DEFAULT_MAX_ENTITIES, maxDepth: number = DEFAULT_MAX_DEPTH) {\n        this.maxEntities = maxEntities;\n        this.maxDepth = maxDepth;\n    }\n\n    /**\n     * Clear the tree.\n     */\n    clear(): void {\n        this.root = null;\n    }\n\n    /**\n     * Insert all bodies into the tree.\n     * Automatically computes world bounds from entities.\n     */\n    insertAll(bodies: RigidBody2D[]): void {\n        if (bodies.length === 0) return;\n\n        // Compute world bounds from all entities (with padding)\n        let minX = Infinity, minY = Infinity;\n        let maxX = -Infinity, maxY = -Infinity;\n\n        for (const body of bodies) {\n            const bounds = getBodyBounds(body);\n            minX = Math.min(minX, bounds.minX);\n            minY = Math.min(minY, bounds.minY);\n            maxX = Math.max(maxX, bounds.maxX);\n            maxY = Math.max(maxY, bounds.maxY);\n        }\n\n        // Add small padding to avoid edge cases\n        const padding = 1;\n        this.root = new QuadTreeNode(\n            { minX: minX - padding, minY: minY - padding, maxX: maxX + padding, maxY: maxY + padding },\n            0,\n            this.maxEntities,\n            this.maxDepth\n        );\n\n        // Insert all bodies\n        for (const body of bodies) {\n            const bounds = getBodyBounds(body);\n            this.root.insert(body, bounds);\n        }\n    }\n\n    /**\n     * Query entities that might collide with the given body.\n     */\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\n        if (!this.root) return [];\n        const result: RigidBody2D[] = [];\n        const bounds = getBodyBounds(body);\n        this.root.query(bounds, result);\n        return result.filter(b => b !== body);\n    }\n\n    /**\n     * Iterate all potential collision pairs.\n     * Each pair is visited exactly once.\n     * Order is deterministic (depth-first, NW\u2192NE\u2192SW\u2192SE).\n     */\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\n        if (!this.root) return;\n        this.root.forEachPair(callback);\n    }\n\n    /**\n     * Get tree statistics for debugging.\n     */\n    getStats(): { nodeCount: number; maxDepth: number; entityCount: number } {\n        if (!this.root) return { nodeCount: 0, maxDepth: 0, entityCount: 0 };\n        return this.root.getStats();\n    }\n}\n", "/**\n * Trigger System\n *\n * Handles trigger (sensor) bodies that detect overlap without physics response.\n * Generic implementation shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Body Interface (minimal contract)\n// ============================================\n\n/**\n * Minimal interface for a physics body used by triggers.\n * Both RigidBody (3D) and RigidBody2D implement this.\n */\nexport interface TriggerBody {\n    label: string;\n    isSensor: boolean;\n}\n\n// ============================================\n// Trigger Event\n// ============================================\n\nexport interface TriggerEvent<T extends TriggerBody = TriggerBody> {\n    trigger: T;\n    other: T;\n}\n\ntype TriggerCallback<T extends TriggerBody> = (event: TriggerEvent<T>) => void;\n\n// ============================================\n// Trigger State\n// ============================================\n\nexport class TriggerState<T extends TriggerBody = TriggerBody> {\n    private overlaps = new Map<string, { trigger: T; other: T }>();\n    private enterCallbacks: TriggerCallback<T>[] = [];\n    private stayCallbacks: TriggerCallback<T>[] = [];\n    private exitCallbacks: TriggerCallback<T>[] = [];\n\n    onEnter(cb: TriggerCallback<T>): void { this.enterCallbacks.push(cb); }\n    onStay(cb: TriggerCallback<T>): void { this.stayCallbacks.push(cb); }\n    onExit(cb: TriggerCallback<T>): void { this.exitCallbacks.push(cb); }\n\n    processOverlaps(currentOverlaps: TriggerEvent<T>[]): void {\n        const currentKeys = new Set<string>();\n        // Sort by trigger and other labels (eids) NUMERICALLY for determinism\n        const sortedOverlaps = [...currentOverlaps].sort((a, b) => {\n            const eidTriggerA = parseInt(a.trigger.label, 10) || 0;\n            const eidTriggerB = parseInt(b.trigger.label, 10) || 0;\n            const cmp = eidTriggerA - eidTriggerB;\n            if (cmp !== 0) return cmp;\n            const eidOtherA = parseInt(a.other.label, 10) || 0;\n            const eidOtherB = parseInt(b.other.label, 10) || 0;\n            return eidOtherA - eidOtherB;\n        });\n\n        for (const overlap of sortedOverlaps) {\n            const key = this.makeKey(overlap.trigger, overlap.other);\n            currentKeys.add(key);\n\n            if (this.overlaps.has(key)) {\n                for (const cb of this.stayCallbacks) cb(overlap);\n            } else {\n                this.overlaps.set(key, overlap);\n                for (const cb of this.enterCallbacks) cb(overlap);\n            }\n        }\n\n        const sortedExistingKeys = [...this.overlaps.keys()].sort();\n        for (const key of sortedExistingKeys) {\n            if (!currentKeys.has(key)) {\n                const overlap = this.overlaps.get(key)!;\n                this.overlaps.delete(key);\n                for (const cb of this.exitCallbacks) cb(overlap);\n            }\n        }\n    }\n\n    clear(): void {\n        this.overlaps.clear();\n    }\n\n    removeBody(body: T): void {\n        const keysToRemove: string[] = [];\n        for (const [key, overlap] of this.overlaps) {\n            if (overlap.trigger === body || overlap.other === body) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.sort();\n        for (const key of keysToRemove) {\n            const overlap = this.overlaps.get(key)!;\n            this.overlaps.delete(key);\n            for (const cb of this.exitCallbacks) cb(overlap);\n        }\n    }\n\n    getOverlappingBodies(trigger: T): T[] {\n        const bodies: T[] = [];\n        for (const overlap of this.overlaps.values()) {\n            if (overlap.trigger === trigger) {\n                bodies.push(overlap.other);\n            }\n        }\n        // Sort by label (eid) NUMERICALLY for determinism\n        return bodies.sort((a, b) => {\n            const eidA = parseInt(a.label, 10) || 0;\n            const eidB = parseInt(b.label, 10) || 0;\n            return eidA - eidB;\n        });\n    }\n\n    isBodyInTrigger(trigger: T, body: T): boolean {\n        return this.overlaps.has(this.makeKey(trigger, body));\n    }\n\n    overlapCount(): number {\n        return this.overlaps.size;\n    }\n\n    saveState(): [string, string][] {\n        const pairs: [string, string][] = [];\n        for (const overlap of this.overlaps.values()) {\n            pairs.push([overlap.trigger.label, overlap.other.label]);\n        }\n        // Sort by labels (eids) NUMERICALLY for determinism\n        return pairs.sort((a, b) => {\n            const eid1A = parseInt(a[0], 10) || 0;\n            const eid1B = parseInt(b[0], 10) || 0;\n            const cmp = eid1A - eid1B;\n            if (cmp !== 0) return cmp;\n            const eid2A = parseInt(a[1], 10) || 0;\n            const eid2B = parseInt(b[1], 10) || 0;\n            return eid2A - eid2B;\n        });\n    }\n\n    private pendingPairs: [string, string][] = [];\n\n    loadState(pairs: [string, string][]): void {\n        this.overlaps.clear();\n        this.pendingPairs = pairs;\n    }\n\n    syncWithWorld(bodies: T[]): void {\n        const bodyByLabel = new Map<string, T>();\n        for (const body of bodies) bodyByLabel.set(body.label, body);\n\n        for (const [triggerLabel, otherLabel] of this.pendingPairs) {\n            const trigger = bodyByLabel.get(triggerLabel);\n            const other = bodyByLabel.get(otherLabel);\n            if (trigger && other) {\n                this.overlaps.set(this.makeKey(trigger, other), { trigger, other });\n            }\n        }\n        this.pendingPairs = [];\n    }\n\n    private makeKey(trigger: T, other: T): string {\n        return `${trigger.label}:${other.label}`;\n    }\n}\n\n// ============================================\n// Helper Function\n// ============================================\n\n/**\n * Mark a body as a trigger (sensor).\n * Works with any body type that has an isSensor property.\n */\nexport function makeTrigger<T extends TriggerBody>(body: T): T {\n    body.isSensor = true;\n    return body;\n}\n", "/**\n * Physics2D System for ECS\n *\n * Integrates the deterministic 2D physics engine with the ECS.\n * This system:\n * - Reads Transform2D + Body2D components\n * - Creates/manages physics bodies internally\n * - Steps the physics simulation\n * - Writes results back to Transform2D component\n * - Handles collision callbacks\n */\n\nimport { World } from '../../core/world';\nimport { Entity } from '../../core/entity';\nimport { ComponentType, hasComponent } from '../../core/component';\nimport { Transform2D, Body2D, BODY_DYNAMIC, BODY_STATIC, BODY_KINEMATIC, SHAPE_CIRCLE, SHAPE_RECT } from '../../components';\nimport { INDEX_MASK } from '../../core/constants';\nimport { toFixed, toFloat } from '../../math';\n\n// Forward declaration for Game to avoid circular import\ninterface GameLike {\n    world: World;\n    physics: Physics2DSystem | null;\n}\n\n// Import physics engine primitives (same folder now)\nimport {\n    World2D,\n    createWorld2D,\n    stepWorld2D,\n    addBody2D,\n    removeBody2D,\n    RigidBody2D,\n    BodyType2D,\n    createBody2D,\n    createCircle,\n    createBox2DFromSize,\n    resetBody2DIdCounter\n} from '.';\n\n/**\n * Collision handler type.\n */\nexport type CollisionHandler = (entityA: Entity, entityB: Entity) => void;\n\n/**\n * Physics2D System configuration.\n */\nexport interface Physics2DSystemConfig {\n    gravity?: { x: number; y: number };\n    dt?: number;  // Timestep (default: 1/60)\n}\n\n/**\n * Physics2D System - manages physics simulation for ECS entities.\n *\n * Can be used as a plugin via game.addPlugin() or standalone via attach().\n *\n * @example\n * // Plugin pattern (recommended)\n * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n *\n * // Standalone pattern (legacy)\n * const physics = createPhysics2DSystem({ gravity: { x: 0, y: 0 } });\n * physics.attach(game.world);\n * game.physics = physics;\n */\nexport class Physics2DSystem {\n    /** Physics world */\n    readonly physicsWorld: World2D;\n\n    /** ECS World reference */\n    private world: World | null = null;\n\n    /** Map entity ID to physics body */\n    private entityToBody: Map<number, RigidBody2D> = new Map();\n\n    /** Map body ID to entity ID */\n    private bodyToEntity: Map<number, number> = new Map();\n\n    /** Collision handlers by type pair */\n    private collisionHandlers: Map<string, CollisionHandler> = new Map();\n\n    /** Entities pending body creation */\n    private pendingEntities: Set<number> = new Set();\n\n    /**\n     * Create a Physics2D system.\n     *\n     * @param gameOrConfig - Game instance (plugin mode) or config (standalone mode)\n     * @param config - Config when using plugin mode\n     */\n    constructor(gameOrConfig?: GameLike | Physics2DSystemConfig, config?: Physics2DSystemConfig) {\n        // Determine if first arg is a Game or config\n        let actualConfig: Physics2DSystemConfig;\n        let game: GameLike | null = null;\n\n        if (gameOrConfig && 'world' in gameOrConfig) {\n            // Plugin mode: first arg is Game\n            game = gameOrConfig;\n            actualConfig = config ?? {};\n        } else {\n            // Standalone mode: first arg is config\n            actualConfig = (gameOrConfig as Physics2DSystemConfig) ?? {};\n        }\n\n        this.physicsWorld = createWorld2D(actualConfig.dt ?? 1 / 60);\n\n        if (actualConfig.gravity) {\n            this.physicsWorld.gravity = {\n                x: toFixed(actualConfig.gravity.x),\n                y: toFixed(actualConfig.gravity.y)\n            };\n        }\n\n        // Set up collision callback via contactListener (for non-sensor collisions)\n        const system = this;\n        this.physicsWorld.contactListener = {\n            onContact(bodyA: RigidBody2D, bodyB: RigidBody2D) {\n                system.handleCollision(bodyA, bodyB);\n            }\n        };\n\n        // Set up physics2d reference for sensor collisions\n        // The physics world uses this for type-based collision handling\n        (this.physicsWorld as any).physics2d = {\n            handleCollision: (entityA: Entity, entityB: Entity) => {\n                return this.handleCollisionByType(entityA, entityB);\n            }\n        };\n\n        // Auto-attach if game was provided\n        if (game) {\n            this.attach(game.world);\n            game.physics = this;\n        }\n    }\n\n    /**\n     * Attach to an ECS World.\n     * Registers prePhysics and physics systems.\n     */\n    attach(world: World): this {\n        this.world = world;\n\n        // Register prePhysics system - sync component data to bodies\n        world.addSystem(() => this.syncBodiesToPhysics(), { phase: 'prePhysics', order: 0 });\n\n        // Register physics system - step simulation\n        world.addSystem(() => this.step(), { phase: 'physics', order: 0 });\n\n        // Register postPhysics system - sync results back to components\n        world.addSystem(() => this.syncPhysicsToComponents(), { phase: 'postPhysics', order: 0 });\n\n        return this;\n    }\n\n    /**\n     * Register collision handler for two entity types.\n     *\n     * For different types (e.g., 'cell', 'food'), the handler is called once\n     * with arguments in the registered order.\n     *\n     * For same types (e.g., 'cell', 'cell'), the handler is called twice -\n     * once as (A, B) and once as (B, A). This lets you write \"first acts on second\"\n     * logic without manually checking both directions.\n     *\n     * @example\n     * // Cell eats food - called once per collision\n     * physics.onCollision('cell', 'food', (cell, food) => {\n     *     food.destroy();\n     * });\n     *\n     * // Cell eats smaller cell - called twice, just check if first > second\n     * physics.onCollision('cell', 'cell', (eater, prey) => {\n     *     if (eater.get(Sprite).radius > prey.get(Sprite).radius * 1.2) {\n     *         prey.destroy();\n     *     }\n     * });\n     */\n    onCollision(typeA: string, typeB: string, handler: CollisionHandler): this {\n        const key1 = `${typeA}:${typeB}`;\n        const key2 = `${typeB}:${typeA}`;\n\n        this.collisionHandlers.set(key1, handler);\n\n        // For different types, register reverse lookup that swaps arguments\n        if (typeA !== typeB) {\n            this.collisionHandlers.set(key2, (a, b) => handler(b, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Set gravity.\n     */\n    setGravity(x: number, y: number): this {\n        this.physicsWorld.gravity = { x: toFixed(x), y: toFixed(y) };\n        return this;\n    }\n\n    /**\n     * Create or get physics body for entity.\n     */\n    private ensureBody(entity: Entity): RigidBody2D | null {\n        const eid = entity.eid;\n\n        // Check if body already exists\n        let body = this.entityToBody.get(eid);\n        if (body) return body;\n\n        // Check if entity has required components\n        if (!entity.has(Transform2D) || !entity.has(Body2D)) {\n            return null;\n        }\n\n        // Get component data\n        const transform = entity.get(Transform2D);\n        const bodyData = entity.get(Body2D);\n\n        // Determine body type\n        let bodyType: BodyType2D;\n        switch (bodyData.bodyType) {\n            case BODY_STATIC:\n                bodyType = BodyType2D.Static;\n                break;\n            case BODY_KINEMATIC:\n                bodyType = BodyType2D.Kinematic;\n                break;\n            default:\n                bodyType = BodyType2D.Dynamic;\n        }\n\n        // Determine shape\n        let shape;\n        if (bodyData.shapeType === SHAPE_CIRCLE || bodyData.radius > 0) {\n            shape = createCircle(bodyData.radius || 10);\n        } else {\n            shape = createBox2DFromSize(bodyData.width || 10, bodyData.height || 10);\n        }\n\n        // Create body\n        body = createBody2D(bodyType, shape, transform.x, transform.y);\n        body.angle = toFixed(transform.angle);\n        body.linearVelocity = { x: toFixed(bodyData.vx), y: toFixed(bodyData.vy) };\n        body.angularVelocity = toFixed(bodyData.angularVelocity);\n        body.isSensor = bodyData.isSensor;\n\n        // CRITICAL: All new bodies start awake for determinism\n        // Without this, late joiners would have awake bodies while existing clients\n        // have sleeping bodies, causing physics simulation divergence\n        body.isSleeping = false;\n        body.sleepFrames = 0;\n\n        // Store entity reference in body's userData\n        body.userData = entity;\n        body.label = eid.toString();\n\n        // Add to physics world\n        addBody2D(this.physicsWorld, body);\n\n        // Track mapping\n        this.entityToBody.set(eid, body);\n        this.bodyToEntity.set(body.id, eid);\n\n        return body;\n    }\n\n    /**\n     * Remove physics body for entity.\n     */\n    removeBody(entity: Entity): void {\n        const eid = entity.eid;\n        const body = this.entityToBody.get(eid);\n\n        if (body) {\n            removeBody2D(this.physicsWorld, body);\n            this.entityToBody.delete(eid);\n            this.bodyToEntity.delete(body.id);\n        }\n    }\n\n    /**\n     * Sync component data to physics bodies (prePhysics).\n     */\n    private syncBodiesToPhysics(): void {\n        if (!this.world) return;\n\n        // Iterate all entities with Body2D\n        for (const entity of this.world.query(Body2D)) {\n            // Ensure body exists\n            const body = this.ensureBody(entity);\n            if (!body) continue;\n\n            // Sync position from component for kinematic and static bodies\n            // (both can be moved by game code, only dynamic bodies are physics-driven)\n            const bodyData = entity.get(Body2D);\n            if (bodyData.bodyType === BODY_KINEMATIC || bodyData.bodyType === BODY_STATIC) {\n                const transform = entity.get(Transform2D);\n                body.position.x = toFixed(transform.x);\n                body.position.y = toFixed(transform.y);\n                body.angle = toFixed(transform.angle);\n            }\n\n            // Apply impulses (instant velocity change)\n            if (bodyData.impulseX !== 0 || bodyData.impulseY !== 0) {\n                bodyData.vx += bodyData.impulseX;\n                bodyData.vy += bodyData.impulseY;\n                bodyData.impulseX = 0;\n                bodyData.impulseY = 0;\n            }\n\n            // Apply forces (add to velocity)\n            if (bodyData.forceX !== 0 || bodyData.forceY !== 0) {\n                bodyData.vx += bodyData.forceX;\n                bodyData.vy += bodyData.forceY;\n                bodyData.forceX = 0;\n                bodyData.forceY = 0;\n            }\n\n            // Apply damping\n            if (bodyData.damping > 0) {\n                const damp = 1 - bodyData.damping;\n                bodyData.vx *= damp;\n                bodyData.vy *= damp;\n            }\n\n            // Sync velocity for all body types\n            const newVelX = toFixed(bodyData.vx);\n            const newVelY = toFixed(bodyData.vy);\n            body.linearVelocity.x = newVelX;\n            body.linearVelocity.y = newVelY;\n\n            // Sync angular velocity\n            body.angularVelocity = toFixed(bodyData.angularVelocity);\n\n            // Wake up body if velocity is non-zero (prevents sleeping bodies from ignoring velocity)\n            if (newVelX !== 0 || newVelY !== 0) {\n                body.isSleeping = false;\n                body.sleepFrames = 0;\n            }\n\n            // Update shape radius if changed\n            if (body.shape.type === 0) { // Circle\n                const currentRadius = (body.shape as any).radius;\n                const newRadius = toFixed(bodyData.radius);\n                if (currentRadius !== newRadius) {\n                    (body.shape as any).radius = newRadius;\n                }\n            }\n        }\n\n        // Clean up bodies for destroyed entities\n        for (const [eid, body] of this.entityToBody) {\n            if (this.world.isDestroyed(eid)) {\n                removeBody2D(this.physicsWorld, body);\n                this.entityToBody.delete(eid);\n                this.bodyToEntity.delete(body.id);\n            }\n        }\n    }\n\n    /**\n     * Step physics simulation.\n     */\n    private step(): void {\n        stepWorld2D(this.physicsWorld);\n    }\n\n    /**\n     * Sync physics results back to components (postPhysics).\n     */\n    private syncPhysicsToComponents(): void {\n        for (const [eid, body] of this.entityToBody) {\n            const entity = this.world?.getEntity(eid);\n            if (!entity || entity.destroyed) continue;\n\n            const transform = entity.get(Transform2D);\n            const bodyData = entity.get(Body2D);\n\n            // Sync position and angle from physics\n            transform.x = toFloat(body.position.x);\n            transform.y = toFloat(body.position.y);\n            transform.angle = toFloat(body.angle);\n\n            // Sync velocity (linear and angular)\n            bodyData.vx = toFloat(body.linearVelocity.x);\n            bodyData.vy = toFloat(body.linearVelocity.y);\n            bodyData.angularVelocity = toFloat(body.angularVelocity);\n        }\n    }\n\n    /**\n     * Handle collision between two bodies.\n     */\n    private handleCollision(bodyA: RigidBody2D, bodyB: RigidBody2D): void {\n        const entityA = bodyA.userData as Entity;\n        const entityB = bodyB.userData as Entity;\n\n        if (!entityA || !entityB) return;\n        if (entityA.destroyed || entityB.destroyed) return;\n\n        this.handleCollisionByType(entityA, entityB);\n    }\n\n    /**\n     * Handle collision by entity types. Returns true if a handler was found.\n     * Used by physics world for both regular and sensor collisions.\n     */\n    private handleCollisionByType(entityA: Entity, entityB: Entity): boolean {\n        if (!entityA || !entityB) return false;\n        if (entityA.destroyed || entityB.destroyed) return false;\n\n        // Look up handler by type pair\n        const key = `${entityA.type}:${entityB.type}`;\n        const handler = this.collisionHandlers.get(key);\n\n        if (handler) {\n            handler(entityA, entityB);\n\n            // For same-type collisions, call handler in reverse direction too\n            // This lets handlers assume \"first arg acts on second\" without manual checks\n            if (entityA.type === entityB.type && !entityA.destroyed && !entityB.destroyed) {\n                handler(entityB, entityA);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get body for entity (for advanced use).\n     */\n    getBody(entity: Entity): RigidBody2D | undefined {\n        return this.entityToBody.get(entity.eid);\n    }\n\n    /**\n     * Get entity for body (for advanced use).\n     */\n    getEntityForBody(body: RigidBody2D): Entity | null {\n        const eid = this.bodyToEntity.get(body.id);\n        if (eid === undefined) return null;\n        return this.world?.getEntity(eid) ?? null;\n    }\n\n    /**\n     * Clear all physics state.\n     * Used during snapshot restoration to ensure fresh physics state.\n     */\n    clear(): void {\n        const bodyCount = this.entityToBody.size;\n        for (const body of this.entityToBody.values()) {\n            removeBody2D(this.physicsWorld, body);\n        }\n        this.entityToBody.clear();\n        this.bodyToEntity.clear();\n\n        // CRITICAL: Reset body ID counter to ensure deterministic body IDs\n        // Without this, recreated bodies would have different IDs than the original,\n        // potentially causing collision order differences and simulation divergence\n        resetBody2DIdCounter();\n        console.log(`[PHYSICS-CLEAR] Cleared ${bodyCount} bodies`);\n    }\n\n    /**\n     * Wake all physics bodies.\n     * Used after snapshot load/send to ensure deterministic state.\n     * Without this, existing clients have sleeping bodies while late joiners\n     * have awake bodies, causing physics divergence.\n     */\n    wakeAllBodies(): void {\n        for (const body of this.physicsWorld.bodies) {\n            body.isSleeping = false;\n            body.sleepFrames = 0;\n        }\n    }\n\n    /**\n     * Force sync ALL physics bodies from ECS components.\n     * CRITICAL: Must be called after snapshot load to ensure physics world\n     * matches the restored ECS state.\n     *\n     * Normal syncBodiesToPhysics() only syncs kinematic/static bodies' positions.\n     * This function syncs ALL body types' positions AND velocities from ECS components.\n     *\n     * NOTE: If entityToBody is empty (bodies not yet created), this will first\n     * create all bodies via ensureBody() to ensure they exist before syncing.\n     */\n    syncAllFromComponents(): void {\n        if (!this.world) return;\n\n        // CRITICAL: If no bodies exist yet (e.g., after clear()), we need to create them first\n        // Otherwise this sync does nothing and bodies get created with possibly wrong state\n        // CRITICAL: Sort by entity ID to ensure deterministic body creation order\n        // Without sorting, iteration order may differ between room creator and late joiners\n        const entitiesWithBody2D = [...this.world.query(Body2D)].sort((a, b) => a.eid - b.eid);\n        const bodiesExistedBefore = this.entityToBody.size;\n        if (this.entityToBody.size === 0 && entitiesWithBody2D.length > 0) {\n            console.log(`[PHYSICS-SYNC] Creating ${entitiesWithBody2D.length} bodies from scratch`);\n            for (const entity of entitiesWithBody2D) {\n                this.ensureBody(entity);\n            }\n        }\n\n        // Now sync all bodies\n        let syncedCount = 0;\n        for (const [eid, body] of this.entityToBody) {\n            const entity = this.world.getEntity(eid);\n            if (!entity || entity.destroyed) continue;\n\n            const transform = entity.get(Transform2D);\n            const bodyData = entity.get(Body2D);\n\n            // Log first few bodies for debugging\n            if (syncedCount < 3) {\n                console.log(`[PHYSICS-SYNC] Body ${eid}: pos(${transform.x.toFixed(1)},${transform.y.toFixed(1)}) -> physics`);\n            }\n\n            // Sync position and angle from Transform2D\n            body.position.x = toFixed(transform.x);\n            body.position.y = toFixed(transform.y);\n            body.angle = toFixed(transform.angle);\n\n            // Sync velocity (linear and angular) from Body2D\n            body.linearVelocity.x = toFixed(bodyData.vx);\n            body.linearVelocity.y = toFixed(bodyData.vy);\n            body.angularVelocity = toFixed(bodyData.angularVelocity);\n\n            // Wake the body to ensure it's active\n            body.isSleeping = false;\n            body.sleepFrames = 0;\n            syncedCount++;\n        }\n\n        console.log(`[PHYSICS-SYNC] Synced ${syncedCount} bodies (existed before: ${bodiesExistedBefore})`);\n    }\n}\n\n/**\n * Create a Physics2D system.\n */\nexport function createPhysics2DSystem(config: Physics2DSystemConfig = {}): Physics2DSystem {\n    return new Physics2DSystem(config);\n}\n", "/**\n * Physics Module\n *\n * Deterministic 3D physics engine with fixed-point math.\n * All components use 16.16 fixed-point integers for 100% determinism.\n */\n\n// Shapes and AABB\nexport { ShapeType, BoxShape, SphereShape, Shape, createBox, createSphere, AABB, aabbOverlap } from './shapes';\n\n// Collision Layers\nexport { CollisionFilter, Layers, DEFAULT_FILTER, createFilter, shouldCollide, filterCollidingWith, filterExcluding } from './layers';\n\n// Rigid Body\nexport { BodyType, RigidBody, resetBodyIdCounter, getBodyIdCounter, setBodyIdCounter, createBody, setBodyMass, setBodyVelocity, applyImpulse, applyForce } from './rigid-body';\n\n// Collision Detection and Response\nexport { ContactPoint, Contact, computeAABB, detectCollision, resolveCollision } from './collision';\n\n// Physics World\nexport { World, createWorld, addBody, removeBody, isGrounded, stepWorld } from './world';\n\n// Raycasting\nexport { RayHit, raycast } from './raycast';\n\n// State Serialization\nexport { BodyState, WorldState, saveWorldState, loadWorldState } from './state';\n\n// Triggers/Sensors\nexport { TriggerEvent, TriggerState, makeTrigger } from './trigger';\n", "/**\n * Collision Shapes\n *\n * Defines shape types for rigid body collision detection.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, toFixed } from '../../math/fixed';\nimport { Vec3, vec3FromFloats } from '../../math/vec';\n\n// ============================================\n// Shape Types\n// ============================================\n\nexport enum ShapeType {\n    Box = 0,\n    Sphere = 1,\n}\n\nexport interface BoxShape {\n    type: ShapeType.Box;\n    halfExtents: Vec3;  // Half-size in each dimension\n}\n\nexport interface SphereShape {\n    type: ShapeType.Sphere;\n    radius: Fixed;\n}\n\nexport type Shape = BoxShape | SphereShape;\n\nexport function createBox(hx: number, hy: number, hz: number): BoxShape {\n    return { type: ShapeType.Box, halfExtents: vec3FromFloats(hx, hy, hz) };\n}\n\nexport function createSphere(radius: number): SphereShape {\n    return { type: ShapeType.Sphere, radius: toFixed(radius) };\n}\n\n// ============================================\n// AABB (Axis-Aligned Bounding Box)\n// ============================================\n\nexport interface AABB {\n    min: Vec3;\n    max: Vec3;\n}\n\nexport function aabbOverlap(a: AABB, b: AABB): boolean {\n    return a.max.x >= b.min.x && a.min.x <= b.max.x &&\n        a.max.y >= b.min.y && a.min.y <= b.max.y &&\n        a.max.z >= b.min.z && a.min.z <= b.max.z;\n}\n", "/**\n * Collision Layers\n *\n * Controls which bodies can collide with each other using bitmasks.\n * Layer = \"what am I\", Mask = \"what do I collide with\"\n *\n * Shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Collision Filter\n// ============================================\n\nexport interface CollisionFilter {\n    /** Which layer this body belongs to (single bit) */\n    layer: number;\n    /** Which layers this body collides with (bitmask) */\n    mask: number;\n}\n\n// ============================================\n// Default Layers\n// ============================================\n\nexport const Layers = {\n    NONE: 0,\n    DEFAULT: 1 << 0,      // 1\n    PLAYER: 1 << 1,       // 2\n    ENEMY: 1 << 2,        // 4\n    PROJECTILE: 1 << 3,   // 8\n    ITEM: 1 << 4,         // 16\n    TRIGGER: 1 << 5,      // 32\n    WORLD: 1 << 6,        // 64\n    PROP: 1 << 7,         // 128\n    // Layers 8-15 reserved for game-specific use\n    CUSTOM_1: 1 << 8,\n    CUSTOM_2: 1 << 9,\n    CUSTOM_3: 1 << 10,\n    CUSTOM_4: 1 << 11,\n    CUSTOM_5: 1 << 12,\n    CUSTOM_6: 1 << 13,\n    CUSTOM_7: 1 << 14,\n    CUSTOM_8: 1 << 15,\n    ALL: 0xFFFF           // All layers\n} as const;\n\n// ============================================\n// Default Filter\n// ============================================\n\n/**\n * Default collision filter - collides with everything\n */\nexport const DEFAULT_FILTER: CollisionFilter = {\n    layer: Layers.DEFAULT,\n    mask: Layers.ALL\n};\n\n// ============================================\n// Filter Helpers\n// ============================================\n\n/**\n * Create a collision filter\n */\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\n    return { layer, mask };\n}\n\n/**\n * Check if two filters allow collision\n * Both must have the other in their mask\n */\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\n}\n\n/**\n * Create a filter that collides with specific layers\n */\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\n    let mask = 0;\n    for (const l of collidesWithLayers) {\n        mask |= l;\n    }\n    return { layer, mask };\n}\n\n/**\n * Create a filter that collides with everything except specific layers\n */\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\n    let mask = Layers.ALL;\n    for (const l of excludeLayers) {\n        mask &= ~l;\n    }\n    return { layer, mask };\n}\n", "/**\n * Rigid Body\n *\n * Defines rigid body types and operations for physics simulation.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv } from '../../math/fixed';\nimport { Vec3, vec3Zero, vec3FromFloats, vec3Add, vec3Scale, vec3Sub, vec3Cross } from '../../math/vec';\nimport { Quat, quatIdentity } from '../../math/quat';\nimport { Shape, ShapeType, SphereShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);  // No bounce for stable resting\nconst FRICTION_DEFAULT = toFixed(0.5);      // Moderate friction\n\n// ============================================\n// Body Types\n// ============================================\n\nexport enum BodyType {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody {\n    id: number;\n    type: BodyType;\n    shape: Shape;\n\n    // Label for deterministic ordering - MUST be unique and consistent across all clients\n    // Examples: \"ground\", \"box_0\", \"box_1\", \"player_abc123\"\n    label: string;\n\n    // Transform\n    position: Vec3;\n    rotation: Quat;\n\n    // Velocity\n    linearVelocity: Vec3;\n    angularVelocity: Vec3;\n\n    // Mass properties\n    mass: Fixed;           // 0 for static/kinematic\n    invMass: Fixed;        // 1/mass, 0 for static/kinematic\n    inertia: Fixed;        // Moment of inertia (simplified scalar)\n    invInertia: Fixed;     // 1/inertia\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotationX: boolean;\n    lockRotationY: boolean;\n    lockRotationZ: boolean;\n    isTrigger: boolean;  // If true, detects overlap but doesn't apply physics response\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId = 1;\n\nexport function resetBodyIdCounter(): void {\n    nextBodyId = 1;\n}\n\nexport function getBodyIdCounter(): number {\n    return nextBodyId;\n}\n\nexport function setBodyIdCounter(value: number): void {\n    nextBodyId = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody(type: BodyType, shape: Shape, x: number, y: number, z: number, label?: string): RigidBody {\n    const mass = type === BodyType.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType.Dynamic ? FP_ONE : 0;\n\n    // Simplified inertia calculation\n    let inertia = 0;\n    if (type === BodyType.Dynamic) {\n        if (shape.type === ShapeType.Box) {\n            // I = (1/12) * m * (h\u00B2 + d\u00B2) for each axis - use average\n            const h = shape.halfExtents;\n            inertia = fpMul(mass, fpMul(toFixed(1 / 6),\n                fpMul(h.x, h.x) + fpMul(h.y, h.y) + fpMul(h.z, h.z)));\n        } else {\n            // I = (2/5) * m * r\u00B2 for solid sphere\n            const r = (shape as SphereShape).radius;\n            inertia = fpMul(mass, fpMul(toFixed(0.4), fpMul(r, r)));\n        }\n    }\n\n    const bodyLabel = label || 'body_' + nextBodyId;\n    const bodyId = nextBodyId++;\n\n    return {\n        id: bodyId,\n        label: bodyLabel,\n        type,\n        shape,\n        position: vec3FromFloats(x, y, z),\n        rotation: quatIdentity(),\n        linearVelocity: vec3Zero(),\n        angularVelocity: vec3Zero(),\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotationX: false,\n        lockRotationY: false,\n        lockRotationZ: false,\n        isTrigger: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBodyMass(body: RigidBody, mass: number): void {\n    if (body.type !== BodyType.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBodyVelocity(body: RigidBody, vx: number, vy: number, vz: number): void {\n    body.linearVelocity = vec3FromFloats(vx, vy, vz);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse(body: RigidBody, impulse: Vec3, point?: Vec3): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(impulse, body.invMass));\n\n    if (point) {\n        const r = vec3Sub(point, body.position);\n        const torque = vec3Cross(r, impulse);\n        body.angularVelocity = vec3Add(body.angularVelocity, vec3Scale(torque, body.invInertia));\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce(body: RigidBody, force: Vec3, dt: Fixed): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n    const impulse = vec3Scale(force, dt);\n    applyImpulse(body, impulse);\n}\n", "/**\n * Collision Detection and Response\n *\n * Handles narrow-phase collision detection between shapes and\n * impulse-based collision response.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpMin, fpSqrt, fpClamp } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Sub, vec3Add, vec3Scale, vec3Neg, vec3Dot, vec3Cross, vec3LengthSq, vec3Normalize } from '../../math/vec';\nimport { quatRotateVec3, quatConjugate } from '../../math/quat';\nimport { ShapeType, SphereShape, BoxShape, AABB } from './shapes';\nimport { RigidBody, BodyType, applyImpulse } from './rigid-body';\n\n// ============================================\n// Constants\n// ============================================\n\nconst POSITION_CORRECTION = toFixed(0.6);  // Slightly less aggressive correction\nconst SLOP = toFixed(0.05);                 // Penetration allowance to reduce jitter\nconst WAKE_VELOCITY_THRESHOLD = toFixed(1.5);  // Threshold for waking sleeping bodies\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB(body: RigidBody): AABB {\n    const pos = body.position;\n    const shape = body.shape;\n\n    if (shape.type === ShapeType.Sphere) {\n        const r = shape.radius;\n        return {\n            min: { x: pos.x - r, y: pos.y - r, z: pos.z - r },\n            max: { x: pos.x + r, y: pos.y + r, z: pos.z + r }\n        };\n    } else {\n        // For rotated boxes, compute world-space AABB by projecting onto each world axis\n        const h = shape.halfExtents;\n\n        // Get the box axes in world space\n        const axisX = quatRotateVec3(body.rotation, vec3(FP_ONE, 0, 0));\n        const axisY = quatRotateVec3(body.rotation, vec3(0, FP_ONE, 0));\n        const axisZ = quatRotateVec3(body.rotation, vec3(0, 0, FP_ONE));\n\n        // Compute the extent along each world axis\n        const extentX = fpAbs(fpMul(axisX.x, h.x)) + fpAbs(fpMul(axisY.x, h.y)) + fpAbs(fpMul(axisZ.x, h.z));\n        const extentY = fpAbs(fpMul(axisX.y, h.x)) + fpAbs(fpMul(axisY.y, h.y)) + fpAbs(fpMul(axisZ.y, h.z));\n        const extentZ = fpAbs(fpMul(axisX.z, h.x)) + fpAbs(fpMul(axisY.z, h.y)) + fpAbs(fpMul(axisZ.z, h.z));\n\n        return {\n            min: { x: pos.x - extentX, y: pos.y - extentY, z: pos.z - extentZ },\n            max: { x: pos.x + extentX, y: pos.y + extentY, z: pos.z + extentZ }\n        };\n    }\n}\n\n// ============================================\n// Contact Types\n// ============================================\n\nexport interface ContactPoint {\n    point: Vec3;\n    penetration: Fixed;\n}\n\nexport interface Contact {\n    bodyA: RigidBody;\n    bodyB: RigidBody;\n    normal: Vec3;          // Points from B toward A (standard convention)\n    points: ContactPoint[]; // Multiple contact points (contact manifold)\n}\n\n// ============================================\n// Collision Detection Functions\n// ============================================\n\nfunction sphereSphereCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as SphereShape;\n    const shapeB = b.shape as SphereShape;\n\n    const diff = vec3Sub(a.position, b.position);  // Points from B to A\n    const distSq = vec3LengthSq(diff);\n    const minDist = shapeA.radius + shapeB.radius;\n    const minDistSq = fpMul(minDist, minDist);\n\n    if (distSq >= minDistSq) return null;\n\n    const dist = fpSqrt(distSq);\n    const normal = dist > 0 ? vec3Scale(diff, fpDiv(FP_ONE, dist)) : vec3(FP_ONE, 0, 0);\n    const penetration = minDist - dist;\n    const point = vec3Sub(a.position, vec3Scale(normal, shapeA.radius));\n\n    return { bodyA: a, bodyB: b, normal, points: [{ point, penetration }] };\n}\n\nfunction sphereBoxCollision(sphere: RigidBody, box: RigidBody): Contact | null {\n    const sphereShape = sphere.shape as SphereShape;\n    const boxShape = box.shape as BoxShape;\n\n    // Transform sphere center into box's local space (accounting for rotation)\n    const worldDiff = vec3Sub(sphere.position, box.position);\n    const invRotation = quatConjugate(box.rotation);\n    const localSphere = quatRotateVec3(invRotation, worldDiff);\n    const h = boxShape.halfExtents;\n\n    // Find closest point on box to sphere center (in local space)\n    const closestLocal: Vec3 = {\n        x: fpClamp(localSphere.x, -h.x, h.x),\n        y: fpClamp(localSphere.y, -h.y, h.y),\n        z: fpClamp(localSphere.z, -h.z, h.z)\n    };\n\n    const diffLocal = vec3Sub(localSphere, closestLocal);\n    const distSq = vec3LengthSq(diffLocal);\n    const radiusSq = fpMul(sphereShape.radius, sphereShape.radius);\n\n    if (distSq >= radiusSq) return null;\n\n    const dist = fpSqrt(distSq);\n\n    let normalLocal: Vec3;\n    let penetration: Fixed;\n\n    if (dist > 0) {\n        normalLocal = vec3Scale(diffLocal, fpDiv(FP_ONE, dist));\n        penetration = sphereShape.radius - dist;\n    } else {\n        // Sphere center inside box - find shortest axis to push out\n        const dx = h.x - fpAbs(localSphere.x);\n        const dy = h.y - fpAbs(localSphere.y);\n        const dz = h.z - fpAbs(localSphere.z);\n\n        if (dx <= dy && dx <= dz) {\n            normalLocal = localSphere.x >= 0 ? vec3(FP_ONE, 0, 0) : vec3(-FP_ONE, 0, 0);\n            penetration = dx + sphereShape.radius;\n        } else if (dy <= dz) {\n            normalLocal = localSphere.y >= 0 ? vec3(0, FP_ONE, 0) : vec3(0, -FP_ONE, 0);\n            penetration = dy + sphereShape.radius;\n        } else {\n            normalLocal = localSphere.z >= 0 ? vec3(0, 0, FP_ONE) : vec3(0, 0, -FP_ONE);\n            penetration = dz + sphereShape.radius;\n        }\n    }\n\n    // Transform contact point and normal back to world space\n    const worldClosest = vec3Add(box.position, quatRotateVec3(box.rotation, closestLocal));\n    const worldNormal = quatRotateVec3(box.rotation, normalLocal);\n\n    return { bodyA: sphere, bodyB: box, normal: worldNormal, points: [{ point: worldClosest, penetration }] };\n}\n\nfunction boxBoxCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as BoxShape;\n    const shapeB = b.shape as BoxShape;\n    const hA = shapeA.halfExtents;\n    const hB = shapeB.halfExtents;\n\n    // Get rotated axes for both boxes\n    const axesA = [\n        quatRotateVec3(a.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(a.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(a.rotation, vec3(0, 0, FP_ONE))\n    ];\n    const axesB = [\n        quatRotateVec3(b.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(b.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(b.rotation, vec3(0, 0, FP_ONE))\n    ];\n\n    const extentsA = [hA.x, hA.y, hA.z];\n    const extentsB = [hB.x, hB.y, hB.z];\n    const d = vec3Sub(b.position, a.position);\n\n    let minPen = 0x7FFFFFFF as Fixed;\n    let bestNormal = vec3(0, FP_ONE, 0);\n\n    // Project extent onto axis\n    function project(axes: Vec3[], extents: Fixed[], axis: Vec3): Fixed {\n        return fpAbs(fpMul(vec3Dot(axes[0], axis), extents[0])) +\n               fpAbs(fpMul(vec3Dot(axes[1], axis), extents[1])) +\n               fpAbs(fpMul(vec3Dot(axes[2], axis), extents[2]));\n    }\n\n    // Test separation on axis, returns false if separated\n    function testAxis(axis: Vec3): boolean {\n        const lenSq = vec3LengthSq(axis);\n        if (lenSq < toFixed(0.0001)) return true; // Skip degenerate\n\n        const len = fpSqrt(lenSq);\n        const n = vec3Scale(axis, fpDiv(FP_ONE, len));\n\n        const pA = project(axesA, extentsA, n);\n        const pB = project(axesB, extentsB, n);\n        const dist = fpAbs(vec3Dot(d, n));\n        const pen = (pA + pB) - dist;\n\n        if (pen <= 0) return false;\n        if (pen < minPen) {\n            minPen = pen;\n            bestNormal = vec3Dot(d, n) < 0 ? n : vec3Neg(n);\n        }\n        return true;\n    }\n\n    // Test 15 SAT axes\n    for (let i = 0; i < 3; i++) {\n        if (!testAxis(axesA[i])) return null;\n        if (!testAxis(axesB[i])) return null;\n    }\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (!testAxis(vec3Cross(axesA[i], axesB[j]))) return null;\n        }\n    }\n\n    // Generate proper contact manifold based on the type of contact\n    const contactPoints: ContactPoint[] = [];\n\n    // Determine which body's face is the reference (the one whose normal we're using)\n    const volumeA = fpMul(fpMul(hA.x, hA.y), hA.z);\n    const volumeB = fpMul(fpMul(hB.x, hB.y), hB.z);\n\n    // Find all vertices of the incident body (smaller one) that are below the reference face\n    const incidentBody = volumeB <= volumeA ? b : a;\n    const incidentHalf = volumeB <= volumeA ? hB : hA;\n    const referenceBody = volumeB <= volumeA ? a : b;\n\n    // For each vertex of the incident body, project onto reference face and check penetration\n    const signs: [number, number, number][] = [\n        [-1, -1, -1], [-1, -1, 1], [-1, 1, -1], [-1, 1, 1],\n        [1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]\n    ];\n\n    // Calculate reference face plane normal\n    const refFaceNormal = volumeB <= volumeA ? bestNormal : vec3Neg(bestNormal);\n\n    interface VertexContact {\n        point: Vec3;\n        depth: Fixed;\n    }\n    const vertexContacts: VertexContact[] = [];\n\n    const refAxes = volumeB <= volumeA ? axesA : axesB;\n    const refHalf = volumeB <= volumeA ? hA : hB;\n\n    for (const [sx, sy, sz] of signs) {\n        const localV = vec3(\n            fpMul(incidentHalf.x, toFixed(sx)),\n            fpMul(incidentHalf.y, toFixed(sy)),\n            fpMul(incidentHalf.z, toFixed(sz))\n        );\n        const worldV = vec3Add(incidentBody.position, quatRotateVec3(incidentBody.rotation, localV));\n\n        // Calculate how deep this vertex is along the collision normal direction\n        const toVertex = vec3Sub(worldV, referenceBody.position);\n        const normalDist = vec3Dot(toVertex, refFaceNormal);\n\n        // Get the reference body's extent along the normal\n        const refExtent = fpMul(fpAbs(vec3Dot(refAxes[0], refFaceNormal)), refHalf.x) +\n                          fpMul(fpAbs(vec3Dot(refAxes[1], refFaceNormal)), refHalf.y) +\n                          fpMul(fpAbs(vec3Dot(refAxes[2], refFaceNormal)), refHalf.z);\n\n        const depth = normalDist + refExtent;\n\n        if (depth > 0) {\n            vertexContacts.push({ point: worldV, depth });\n        }\n    }\n\n    // Sort by depth and take the deepest vertices (up to 4 for face contact)\n    // Use position as tiebreaker for deterministic stable sort\n    vertexContacts.sort((a, b) => {\n        const depthDiff = b.depth - a.depth;\n        if (depthDiff !== 0) return depthDiff;\n        // Tiebreaker using point position for determinism\n        return (a.point.x - b.point.x) || (a.point.y - b.point.y) || (a.point.z - b.point.z);\n    });\n\n    // Use vertices with similar depth (within threshold of deepest)\n    const DEPTH_THRESHOLD = toFixed(0.05);\n    const maxDepth = vertexContacts.length > 0 ? vertexContacts[0].depth : 0 as Fixed;\n\n    for (const vc of vertexContacts) {\n        if (vc.depth > maxDepth - DEPTH_THRESHOLD) {\n            contactPoints.push({ point: vc.point, penetration: vc.depth });\n        }\n        if (contactPoints.length >= 4) break; // Max 4 contact points\n    }\n\n    // Fallback: use the SAT penetration point\n    if (contactPoints.length === 0) {\n        const midPoint = vec3Scale(vec3Add(a.position, b.position), FP_HALF);\n        contactPoints.push({ point: midPoint, penetration: minPen });\n    }\n\n    return { bodyA: a, bodyB: b, normal: bestNormal, points: contactPoints };\n}\n\nexport function detectCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const typeA = a.shape.type;\n    const typeB = b.shape.type;\n\n    if (typeA === ShapeType.Sphere && typeB === ShapeType.Sphere) {\n        return sphereSphereCollision(a, b);\n    } else if (typeA === ShapeType.Sphere && typeB === ShapeType.Box) {\n        return sphereBoxCollision(a, b);\n    } else if (typeA === ShapeType.Box && typeB === ShapeType.Sphere) {\n        const contact = sphereBoxCollision(b, a);\n        if (contact) {\n            // Swap bodies and flip normal\n            return {\n                bodyA: a,\n                bodyB: b,\n                normal: vec3Neg(contact.normal),\n                points: contact.points\n            };\n        }\n        return null;\n    } else {\n        return boxBoxCollision(a, b);\n    }\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\nexport function resolveCollision(contact: Contact): void {\n    const { bodyA, bodyB, normal, points } = contact;\n\n    // Skip if both are static/kinematic or no contact points\n    if (bodyA.invMass === 0 && bodyB.invMass === 0) return;\n    if (points.length === 0) return;\n\n    // Calculate relative velocity along collision normal to determine wake conditions\n    const relVelForWake = vec3Sub(bodyA.linearVelocity, bodyB.linearVelocity);\n    const impactVelocity = fpAbs(vec3Dot(relVelForWake, normal));\n\n    // Check if this is a resting contact (bodies gently settling, not impacting)\n    const isRestingContact = impactVelocity < WAKE_VELOCITY_THRESHOLD;\n\n    // If one body is sleeping and this is a resting contact, keep it sleeping\n    // Apply position correction only without waking\n    if (isRestingContact && (bodyA.isSleeping || bodyB.isSleeping)) {\n        for (const cp of points) {\n            const penetration = cp.penetration;\n            if (penetration > SLOP) {\n                const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n                if (pureInvMassSum > 0) {\n                    const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n                    const correctionVec = vec3Scale(normal, correction);\n\n                    // Only move non-sleeping bodies\n                    if (bodyA.invMass > 0 && !bodyA.isSleeping) {\n                        bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n                    }\n                    if (bodyB.invMass > 0 && !bodyB.isSleeping) {\n                        bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    const numContacts = points.length;\n    const invNumContacts = fpDiv(FP_ONE, toFixed(numContacts));\n\n    // Restitution (use minimum)\n    const e = fpMin(bodyA.restitution, bodyB.restitution);\n    const frictionCoeff = fpDiv(bodyA.friction + bodyB.friction, toFixed(2));\n\n    // Process each contact point\n    for (const cp of points) {\n        const point = cp.point;\n        const penetration = cp.penetration;\n\n        // Calculate radius vectors from center of mass to contact point\n        const rA = vec3Sub(point, bodyA.position);\n        const rB = vec3Sub(point, bodyB.position);\n\n        // Calculate velocity at contact point (including rotation)\n        const velA = vec3Add(bodyA.linearVelocity, vec3Cross(bodyA.angularVelocity, rA));\n        const velB = vec3Add(bodyB.linearVelocity, vec3Cross(bodyB.angularVelocity, rB));\n        const relVel = vec3Sub(velA, velB);\n\n        const velAlongNormal = vec3Dot(relVel, normal);\n\n        // Only resolve if approaching\n        if (velAlongNormal < 0) {\n            // Calculate impulse magnitude\n            const rACrossN = vec3Cross(rA, normal);\n            const rBCrossN = vec3Cross(rB, normal);\n\n            const angularInertiaA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rACrossN, rACrossN), bodyA.invInertia);\n            const angularInertiaB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rBCrossN, rBCrossN), bodyB.invInertia);\n\n            const invMassSum = bodyA.invMass + bodyB.invMass + angularInertiaA + angularInertiaB;\n            let j = fpMul(-(FP_ONE + e), velAlongNormal);\n            j = fpDiv(j, invMassSum);\n            j = fpMul(j, invNumContacts);  // Distribute across contacts\n\n            const impulse = vec3Scale(normal, j);\n\n            if (bodyA.invMass > 0) {\n                applyImpulse(bodyA, impulse, point);\n            }\n            if (bodyB.invMass > 0) {\n                applyImpulse(bodyB, vec3Neg(impulse), point);\n            }\n\n            // Friction\n            const tangent = vec3Sub(relVel, vec3Scale(normal, velAlongNormal));\n            const tangentLenSq = vec3LengthSq(tangent);\n\n            if (tangentLenSq > toFixed(0.0001)) {\n                const tangentNorm = vec3Normalize(tangent);\n                const rACrossT = vec3Cross(rA, tangentNorm);\n                const rBCrossT = vec3Cross(rB, tangentNorm);\n\n                const angularInertiaTA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rACrossT, rACrossT), bodyA.invInertia);\n                const angularInertiaTB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rBCrossT, rBCrossT), bodyB.invInertia);\n\n                const invMassSumT = bodyA.invMass + bodyB.invMass + angularInertiaTA + angularInertiaTB;\n                const tangentSpeed = fpSqrt(tangentLenSq);\n                let jt = fpDiv(tangentSpeed, invMassSumT);\n                jt = fpMul(jt, invNumContacts);  // Distribute\n\n                const maxFriction = fpMul(fpAbs(j), frictionCoeff);\n                if (jt > maxFriction) jt = maxFriction;\n\n                const frictionImpulse = vec3Scale(tangentNorm, -jt);\n\n                if (bodyA.invMass > 0) {\n                    applyImpulse(bodyA, frictionImpulse, point);\n                }\n                if (bodyB.invMass > 0) {\n                    applyImpulse(bodyB, vec3Neg(frictionImpulse), point);\n                }\n            }\n        }\n\n        // Position correction for this contact\n        if (penetration > SLOP) {\n            const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n            const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n            const scaledCorrection = fpMul(correction, invNumContacts);  // Distribute\n            const correctionVec = vec3Scale(normal, scaledCorrection);\n\n            if (bodyA.invMass > 0) {\n                bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n            }\n            if (bodyB.invMass > 0) {\n                bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n            }\n        }\n    }\n}\n", "/**\n * Trigger System\n *\n * Handles trigger (sensor) bodies that detect overlap without physics response.\n * Generic implementation shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Body Interface (minimal contract)\n// ============================================\n\n/**\n * Minimal interface for a physics body used by triggers.\n * Both RigidBody (3D) and RigidBody2D implement this.\n */\nexport interface TriggerBody {\n    label: string;\n    isTrigger: boolean;\n}\n\n// ============================================\n// Trigger Event\n// ============================================\n\nexport interface TriggerEvent<T extends TriggerBody = TriggerBody> {\n    trigger: T;\n    other: T;\n}\n\ntype TriggerCallback<T extends TriggerBody> = (event: TriggerEvent<T>) => void;\n\n// ============================================\n// Trigger State\n// ============================================\n\nexport class TriggerState<T extends TriggerBody = TriggerBody> {\n    private overlaps = new Map<string, { trigger: T; other: T }>();\n    private enterCallbacks: TriggerCallback<T>[] = [];\n    private stayCallbacks: TriggerCallback<T>[] = [];\n    private exitCallbacks: TriggerCallback<T>[] = [];\n\n    onEnter(cb: TriggerCallback<T>): void { this.enterCallbacks.push(cb); }\n    onStay(cb: TriggerCallback<T>): void { this.stayCallbacks.push(cb); }\n    onExit(cb: TriggerCallback<T>): void { this.exitCallbacks.push(cb); }\n\n    processOverlaps(currentOverlaps: TriggerEvent<T>[]): void {\n        const currentKeys = new Set<string>();\n        const sortedOverlaps = [...currentOverlaps].sort((a, b) => {\n            return this.makeKey(a.trigger, a.other).localeCompare(this.makeKey(b.trigger, b.other));\n        });\n\n        for (const overlap of sortedOverlaps) {\n            const key = this.makeKey(overlap.trigger, overlap.other);\n            currentKeys.add(key);\n\n            if (this.overlaps.has(key)) {\n                for (const cb of this.stayCallbacks) cb(overlap);\n            } else {\n                this.overlaps.set(key, overlap);\n                for (const cb of this.enterCallbacks) cb(overlap);\n            }\n        }\n\n        const sortedExistingKeys = [...this.overlaps.keys()].sort();\n        for (const key of sortedExistingKeys) {\n            if (!currentKeys.has(key)) {\n                const overlap = this.overlaps.get(key)!;\n                this.overlaps.delete(key);\n                for (const cb of this.exitCallbacks) cb(overlap);\n            }\n        }\n    }\n\n    clear(): void {\n        this.overlaps.clear();\n    }\n\n    removeBody(body: T): void {\n        const keysToRemove: string[] = [];\n        for (const [key, overlap] of this.overlaps) {\n            if (overlap.trigger === body || overlap.other === body) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.sort();\n        for (const key of keysToRemove) {\n            const overlap = this.overlaps.get(key)!;\n            this.overlaps.delete(key);\n            for (const cb of this.exitCallbacks) cb(overlap);\n        }\n    }\n\n    getOverlappingBodies(trigger: T): T[] {\n        const bodies: T[] = [];\n        for (const overlap of this.overlaps.values()) {\n            if (overlap.trigger === trigger) {\n                bodies.push(overlap.other);\n            }\n        }\n        return bodies.sort((a, b) => a.label.localeCompare(b.label));\n    }\n\n    isBodyInTrigger(trigger: T, body: T): boolean {\n        return this.overlaps.has(this.makeKey(trigger, body));\n    }\n\n    overlapCount(): number {\n        return this.overlaps.size;\n    }\n\n    saveState(): [string, string][] {\n        const pairs: [string, string][] = [];\n        for (const overlap of this.overlaps.values()) {\n            pairs.push([overlap.trigger.label, overlap.other.label]);\n        }\n        return pairs.sort((a, b) => a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]));\n    }\n\n    private pendingPairs: [string, string][] = [];\n\n    loadState(pairs: [string, string][]): void {\n        this.overlaps.clear();\n        this.pendingPairs = pairs;\n    }\n\n    syncWithWorld(bodies: T[]): void {\n        const bodyByLabel = new Map<string, T>();\n        for (const body of bodies) bodyByLabel.set(body.label, body);\n\n        for (const [triggerLabel, otherLabel] of this.pendingPairs) {\n            const trigger = bodyByLabel.get(triggerLabel);\n            const other = bodyByLabel.get(otherLabel);\n            if (trigger && other) {\n                this.overlaps.set(this.makeKey(trigger, other), { trigger, other });\n            }\n        }\n        this.pendingPairs = [];\n    }\n\n    private makeKey(trigger: T, other: T): string {\n        return `${trigger.label}:${other.label}`;\n    }\n}\n\n// ============================================\n// Helper Function\n// ============================================\n\n/**\n * Mark a body as a trigger (sensor).\n * Works with any body type that has an isTrigger property.\n */\nexport function makeTrigger<T extends TriggerBody>(body: T): T {\n    body.isTrigger = true;\n    return body;\n}\n", "/**\n * Physics World\n *\n * Manages the physics simulation including gravity, collision detection,\n * and integration of velocities and positions.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Clone, vec3Add, vec3Scale, vec3LengthSq } from '../../math/vec';\nimport { quatFromAxisAngle, quatMul, quatNormalize } from '../../math/quat';\nimport { aabbOverlap } from './shapes';\nimport { RigidBody, BodyType } from './rigid-body';\nimport { Contact, computeAABB, detectCollision, resolveCollision } from './collision';\nimport { shouldCollide } from './layers';\nimport { TriggerState, TriggerEvent } from './trigger';\n\n// ============================================\n// Constants\n// ============================================\n\nconst GRAVITY: Vec3 = { x: 0, y: toFixed(-30), z: 0 };  // -30 units/s\u00B2\nconst LINEAR_DAMPING = toFixed(0.1);      // 10% velocity loss per frame\nconst ANGULAR_DAMPING = toFixed(0.1);     // 10% angular velocity loss per frame\nconst SLEEP_THRESHOLD = toFixed(0.12);    // Sleep when nearly stopped\nconst SLEEP_FRAMES_REQUIRED = 20;         // ~0.33 seconds at 60fps before sleeping\nconst CONTACT_SLEEP_BONUS = 10;           // Extra sleep frames when in stable contact\nconst COLLISION_ITERATIONS = 8;           // Multiple iterations for stability\n\n// ============================================\n// World Interface\n// ============================================\n\nexport interface World {\n    bodies: RigidBody[];\n    gravity: Vec3;\n    dt: Fixed;  // Fixed timestep\n    triggers: TriggerState;  // Trigger/sensor event tracking\n    /** Step the physics simulation */\n    step(): Contact[];\n}\n\nexport function createWorld(dt: number = 1 / 60): World {\n    const world: World = {\n        bodies: [],\n        gravity: vec3Clone(GRAVITY),\n        dt: toFixed(dt),\n        triggers: new TriggerState(),\n        step() {\n            return stepWorld(world);\n        }\n    };\n    return world;\n}\n\nexport function addBody(world: World, body: RigidBody): void {\n    world.bodies.push(body);\n}\n\nexport function removeBody(world: World, body: RigidBody): void {\n    const index = world.bodies.indexOf(body);\n    if (index >= 0) {\n        world.bodies.splice(index, 1);\n        // Clean up trigger overlaps involving this body\n        world.triggers.removeBody(body);\n    }\n}\n\n// ============================================\n// Ground Check\n// ============================================\n\n/**\n * Check if a body is grounded (has a surface below it within threshold)\n * @param world The physics world\n * @param body The body to check\n * @param threshold Distance below to check (default 0.15)\n * @returns true if grounded\n */\nexport function isGrounded(world: World, body: RigidBody, threshold: number = 0.15): boolean {\n    const thresholdFP = toFixed(threshold);\n\n    for (const other of world.bodies) {\n        if (other === body) continue;\n\n        // Check if there's collision contact with normal pointing up\n        const contact = detectCollision(body, other);\n        if (contact && contact.normal.y > FP_HALF) {\n            // Normal pointing up means surface is below\n            return true;\n        }\n\n        // Also check slightly below current position\n        const savedY = body.position.y;\n        body.position.y = body.position.y - thresholdFP;\n        const contactBelow = detectCollision(body, other);\n        body.position.y = savedY;\n\n        if (contactBelow && contactBelow.normal.y > FP_HALF) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// ============================================\n// World Step\n// ============================================\n\nexport function stepWorld(world: World): Contact[] {\n    const { gravity, dt, triggers } = world;\n    const contacts: Contact[] = [];\n    const triggerOverlaps: TriggerEvent[] = [];\n\n    // CRITICAL: Sort bodies by label for deterministic collision processing order\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\n\n    // Track which bodies are in stable resting contact (for island sleeping)\n    const restingContactBodies = new Set<RigidBody>();\n    const sleepingContactBodies = new Set<RigidBody>();\n\n    // First pass: identify resting contacts and sleeping contact pairs\n    for (let i = 0; i < bodies.length; i++) {\n        for (let j = i + 1; j < bodies.length; j++) {\n            const a = bodies[i];\n            const b = bodies[j];\n\n            if (a.invMass === 0 && b.invMass === 0) continue;\n            if (!shouldCollide(a.filter, b.filter)) continue;\n\n            const aabbA = computeAABB(a);\n            const aabbB = computeAABB(b);\n            if (!aabbOverlap(aabbA, aabbB)) continue;\n\n            const contact = detectCollision(a, b);\n            if (contact) {\n                if (fpAbs(contact.normal.y) > FP_HALF) {\n                    restingContactBodies.add(a);\n                    restingContactBodies.add(b);\n\n                    if (a.isSleeping && b.type === BodyType.Dynamic) {\n                        const bSpeedSq = vec3LengthSq(b.linearVelocity) + vec3LengthSq(b.angularVelocity);\n                        if (bSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(b);\n                        }\n                    }\n                    if (b.isSleeping && a.type === BodyType.Dynamic) {\n                        const aSpeedSq = vec3LengthSq(a.linearVelocity) + vec3LengthSq(a.angularVelocity);\n                        if (aSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(a);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Integrate velocities (apply gravity)\n    for (const body of bodies) {\n        if (body.type !== BodyType.Dynamic) continue;\n        if (body.isSleeping) continue;\n\n        body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(gravity, dt));\n\n        let linearDamp = FP_ONE - LINEAR_DAMPING;\n        let angularDamp = FP_ONE - ANGULAR_DAMPING;\n\n        if (restingContactBodies.has(body)) {\n            linearDamp = fpMul(linearDamp, toFixed(0.95));\n            angularDamp = fpMul(angularDamp, toFixed(0.9));\n        }\n\n        body.linearVelocity = vec3Scale(body.linearVelocity, linearDamp);\n        body.angularVelocity = vec3Scale(body.angularVelocity, angularDamp);\n    }\n\n    // Multiple collision iterations for stability\n    for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {\n        for (let i = 0; i < bodies.length; i++) {\n            for (let j = i + 1; j < bodies.length; j++) {\n                const a = bodies[i];\n                const b = bodies[j];\n\n                if (a.invMass === 0 && b.invMass === 0) continue;\n                if (!shouldCollide(a.filter, b.filter)) continue;\n\n                const aabbA = computeAABB(a);\n                const aabbB = computeAABB(b);\n                if (!aabbOverlap(aabbA, aabbB)) continue;\n\n                const contact = detectCollision(a, b);\n                if (contact) {\n                    // Check if either body is a trigger\n                    const isTriggerCollision = a.isTrigger || b.isTrigger;\n\n                    if (isTriggerCollision) {\n                        // Record trigger overlap (only on first iteration)\n                        if (iter === 0) {\n                            // Determine which is the trigger\n                            if (a.isTrigger) {\n                                triggerOverlaps.push({ trigger: a, other: b });\n                            }\n                            if (b.isTrigger) {\n                                triggerOverlaps.push({ trigger: b, other: a });\n                            }\n                        }\n                        // Skip physics response for triggers\n                    } else {\n                        // Normal collision - apply physics response\n                        if (iter === 0) contacts.push(contact);\n                        resolveCollision(contact);\n                    }\n                }\n            }\n        }\n    }\n\n    // Process trigger events after collision detection\n    triggers.processOverlaps(triggerOverlaps);\n\n    // Integrate positions\n    for (const body of bodies) {\n        if (body.type === BodyType.Static) continue;\n        if (body.isSleeping) continue;\n\n        // Clamp tiny linear velocities to zero\n        const linearClampThreshold = toFixed(0.05);\n        if (fpAbs(body.linearVelocity.x) < linearClampThreshold) body.linearVelocity.x = 0;\n        if (fpAbs(body.linearVelocity.y) < linearClampThreshold) body.linearVelocity.y = 0;\n        if (fpAbs(body.linearVelocity.z) < linearClampThreshold) body.linearVelocity.z = 0;\n\n        body.position = vec3Add(body.position, vec3Scale(body.linearVelocity, dt));\n\n        // Skip rotation integration if all rotations are locked\n        if (body.lockRotationX && body.lockRotationY && body.lockRotationZ) {\n            continue;\n        }\n\n        // Apply rotation locks\n        let angVelX = body.lockRotationX ? 0 : body.angularVelocity.x;\n        let angVelY = body.lockRotationY ? 0 : body.angularVelocity.y;\n        let angVelZ = body.lockRotationZ ? 0 : body.angularVelocity.z;\n\n        // Clamp tiny angular velocities to zero\n        const angularClampThreshold = toFixed(0.01);\n        if (fpAbs(angVelX) < angularClampThreshold) angVelX = 0;\n        if (fpAbs(angVelY) < angularClampThreshold) angVelY = 0;\n        if (fpAbs(angVelZ) < angularClampThreshold) angVelZ = 0;\n\n        body.angularVelocity.x = angVelX;\n        body.angularVelocity.y = angVelY;\n        body.angularVelocity.z = angVelZ;\n\n        const angVelLengthSq = fpMul(angVelX, angVelX) + fpMul(angVelY, angVelY) + fpMul(angVelZ, angVelZ);\n\n        if (angVelLengthSq > 0) {\n            const angSpeed = fpSqrt(angVelLengthSq);\n            const angle = fpMul(angSpeed, dt);\n            const invSpeed = fpDiv(FP_ONE, angSpeed);\n            const axis = {\n                x: fpMul(angVelX, invSpeed),\n                y: fpMul(angVelY, invSpeed),\n                z: fpMul(angVelZ, invSpeed)\n            };\n            const rotDelta = quatFromAxisAngle(axis, angle);\n            body.rotation = quatNormalize(quatMul(rotDelta, body.rotation));\n        }\n\n        // Sleep detection\n        const speedSq = vec3LengthSq(body.linearVelocity);\n        const angSpeedSq = vec3LengthSq(body.angularVelocity);\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\n\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\n            const sleepIncrement = sleepingContactBodies.has(body) ? (1 + CONTACT_SLEEP_BONUS) : 1;\n            body.sleepFrames += sleepIncrement;\n\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\n                body.isSleeping = true;\n                body.linearVelocity = vec3Zero();\n                body.angularVelocity = vec3Zero();\n            }\n        } else {\n            body.sleepFrames = 0;\n            body.isSleeping = false;\n        }\n    }\n\n    return contacts;\n}\n", "/**\n * Raycasting\n *\n * Ray-body intersection tests for visibility checks,\n * hit detection, and other line-of-sight queries.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Add, vec3Sub, vec3Scale, vec3Dot, vec3Normalize } from '../../math/vec';\nimport { ShapeType, SphereShape, BoxShape } from './shapes';\nimport { RigidBody } from './rigid-body';\nimport { World } from './world';\n\n// ============================================\n// Ray Hit Result\n// ============================================\n\nexport interface RayHit {\n    body: RigidBody;\n    point: Vec3;\n    normal: Vec3;\n    distance: Fixed;\n}\n\n// ============================================\n// Raycast Functions\n// ============================================\n\nexport function raycast(world: World, origin: Vec3, direction: Vec3, maxDistance: Fixed): RayHit | null {\n    const dir = vec3Normalize(direction);\n    let closestHit: RayHit | null = null;\n    let closestDist = maxDistance;\n\n    for (const body of world.bodies) {\n        const hit = raycastBody(body, origin, dir, closestDist);\n        if (hit && hit.distance < closestDist) {\n            closestDist = hit.distance;\n            closestHit = hit;\n        }\n    }\n\n    return closestHit;\n}\n\nfunction raycastBody(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    if (body.shape.type === ShapeType.Sphere) {\n        return raycastSphere(body, origin, dir, maxDist);\n    } else {\n        return raycastBox(body, origin, dir, maxDist);\n    }\n}\n\nfunction raycastSphere(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    const shape = body.shape as SphereShape;\n    const oc = vec3Sub(origin, body.position);\n\n    const a = vec3Dot(dir, dir);\n    const b = fpMul(toFixed(2), vec3Dot(oc, dir));\n    const c = vec3Dot(oc, oc) - fpMul(shape.radius, shape.radius);\n\n    const discriminant = fpMul(b, b) - fpMul(fpMul(toFixed(4), a), c);\n    if (discriminant < 0) return null;\n\n    const sqrtD = fpSqrt(discriminant);\n    let t = fpDiv(-b - sqrtD, fpMul(toFixed(2), a));\n\n    if (t < 0) {\n        t = fpDiv(-b + sqrtD, fpMul(toFixed(2), a));\n        if (t < 0) return null;\n    }\n\n    if (t > maxDist) return null;\n\n    const point = vec3Add(origin, vec3Scale(dir, t));\n    const normal = vec3Normalize(vec3Sub(point, body.position));\n\n    return { body, point, normal, distance: t };\n}\n\nfunction raycastBox(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    const shape = body.shape as BoxShape;\n    const h = shape.halfExtents;\n    const pos = body.position;\n\n    // AABB ray intersection\n    let tMin = -0x7FFFFFFF;\n    let tMax = 0x7FFFFFFF;\n    let normalAxis = 0;\n    let normalSign = 1;\n\n    // X axis\n    {\n        const invD = dir.x !== 0 ? fpDiv(FP_ONE, dir.x) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.x - h.x) - origin.x, invD);\n        let t1 = fpMul((pos.x + h.x) - origin.x, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 0; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    // Y axis\n    {\n        const invD = dir.y !== 0 ? fpDiv(FP_ONE, dir.y) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.y - h.y) - origin.y, invD);\n        let t1 = fpMul((pos.y + h.y) - origin.y, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 1; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    // Z axis\n    {\n        const invD = dir.z !== 0 ? fpDiv(FP_ONE, dir.z) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.z - h.z) - origin.z, invD);\n        let t1 = fpMul((pos.z + h.z) - origin.z, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 2; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    if (tMin < 0 || tMin > maxDist) return null;\n\n    const point = vec3Add(origin, vec3Scale(dir, tMin));\n    const normal = vec3(\n        normalAxis === 0 ? toFixed(normalSign) : 0,\n        normalAxis === 1 ? toFixed(normalSign) : 0,\n        normalAxis === 2 ? toFixed(normalSign) : 0\n    );\n\n    return { body, point, normal, distance: tMin };\n}\n", "/**\n * State Serialization\n *\n * Functions for saving and loading world state for rollback netcode.\n * Uses labels for body matching to ensure determinism across clients.\n */\n\nimport { Fixed } from '../../math/fixed';\nimport { World } from './world';\n\n// ============================================\n// State Interfaces\n// ============================================\n\nexport interface BodyState {\n    id: number;\n    label: string;  // Used for matching bodies across clients with different IDs\n    px: Fixed; py: Fixed; pz: Fixed;\n    qx: Fixed; qy: Fixed; qz: Fixed; qw: Fixed;\n    vx: Fixed; vy: Fixed; vz: Fixed;\n    avx: Fixed; avy: Fixed; avz: Fixed;\n    isSleeping: boolean;\n    sleepFrames: number;\n}\n\nexport interface WorldState {\n    bodies: BodyState[];\n}\n\n// ============================================\n// State Functions\n// ============================================\n\nexport function saveWorldState(world: World): WorldState {\n    return {\n        bodies: world.bodies.map(b => ({\n            id: b.id,\n            label: b.label,\n            px: b.position.x, py: b.position.y, pz: b.position.z,\n            qx: b.rotation.x, qy: b.rotation.y, qz: b.rotation.z, qw: b.rotation.w,\n            vx: b.linearVelocity.x, vy: b.linearVelocity.y, vz: b.linearVelocity.z,\n            avx: b.angularVelocity.x, avy: b.angularVelocity.y, avz: b.angularVelocity.z,\n            isSleeping: b.isSleeping,\n            sleepFrames: b.sleepFrames,\n        }))\n    };\n}\n\nexport function loadWorldState(world: World, state: WorldState): void {\n    // Build set of labels that should exist\n    const snapshotLabels = new Set(state.bodies.map(bs => bs.label));\n\n    // Remove bodies that exist in world but not in snapshot (created after snapshot was taken)\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\n        if (!snapshotLabels.has(world.bodies[i].label)) {\n            world.bodies.splice(i, 1);\n        }\n    }\n\n    // Use label for matching - body IDs may differ across clients\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\n\n    for (const bs of state.bodies) {\n        const body = bodyMap.get(bs.label);\n        if (!body) continue;\n\n        body.position = { x: bs.px, y: bs.py, z: bs.pz };\n        body.rotation = { x: bs.qx, y: bs.qy, z: bs.qz, w: bs.qw };\n        body.linearVelocity = { x: bs.vx, y: bs.vy, z: bs.vz };\n        body.angularVelocity = { x: bs.avx, y: bs.avy, z: bs.avz };\n        body.isSleeping = bs.isSleeping;\n        body.sleepFrames = bs.sleepFrames;\n    }\n}\n"],
  "mappings": "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;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EACzG;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;AAAA,EAAO;A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",
  "names": ["buffer", "def", "syncFieldsSet", "vec2", "vec2Add", "vec2Clone", "vec2Cross", "vec2Dot", "vec2LengthSq", "vec2Scale", "vec2Sub", "vec2Zero", "Shape2DType", "BodyType2D", "vec2Zero", "vec2", "vec2Clone", "vec2Add", "vec2Sub", "vec2Scale", "vec2Dot", "vec2LengthSq", "vec2Cross", "vec2Add", "vec2Scale", "vec2LengthSq", "vec2Zero", "FP_ONE_TWELFTH", "DEFAULT_FILTER", "Layers", "TriggerState", "createFilter", "filterCollidingWith", "filterExcluding", "makeTrigger", "shouldCollide", "ShapeType", "Layers", "DEFAULT_FILTER", "createFilter", "shouldCollide", "filterCollidingWith", "filterExcluding", "RESTITUTION_DEFAULT", "FRICTION_DEFAULT", "BodyType", "DEFAULT_FILTER", "a", "b", "TriggerState", "makeTrigger", "LINEAR_DAMPING", "ANGULAR_DAMPING", "SLEEP_THRESHOLD", "SLEEP_FRAMES_REQUIRED", "TriggerState", "shouldCollide"]
}
