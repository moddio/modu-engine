{
  "version": 3,
  "sources": ["../src/index.ts", "../src/math/fixed.ts", "../src/math/vec.ts", "../src/math/quat.ts", "../src/math/random.ts", "../src/core/constants.ts", "../src/core/component.ts", "../src/core/entity-id.ts", "../src/components/index.ts", "../src/core/entity.ts", "../src/core/query.ts", "../src/core/system.ts", "../src/core/snapshot.ts", "../src/core/string-registry.ts", "../src/core/input-history.ts", "../src/core/world.ts", "../src/codec/index.ts", "../src/codec/binary.ts", "../src/game.ts", "../src/plugins/simple-2d-renderer.ts", "../src/plugins/input-plugin.ts", "../src/plugins/camera-system.ts", "../src/plugins/determinism-guard.ts", "../src/version.ts", "../src/plugins/debug-ui.ts", "../src/plugins/physics2d/index.ts", "../src/plugins/physics2d/shapes.ts", "../src/plugins/physics2d/layers.ts", "../src/plugins/physics2d/rigid-body.ts", "../src/plugins/physics2d/collision.ts", "../src/plugins/physics2d/spatial-hash.ts", "../src/plugins/physics2d/world.ts", "../src/plugins/physics2d/quad-tree.ts", "../src/plugins/physics2d/trigger.ts", "../src/plugins/physics2d/system.ts", "../src/plugins/physics3d/index.ts", "../src/plugins/physics3d/shapes.ts", "../src/plugins/physics3d/layers.ts", "../src/plugins/physics3d/rigid-body.ts", "../src/plugins/physics3d/collision.ts", "../src/plugins/physics3d/trigger.ts", "../src/plugins/physics3d/world.ts", "../src/plugins/physics3d/raycast.ts", "../src/plugins/physics3d/state.ts", "../src/sync/rollback.ts"],
  "sourcesContent": ["/**\n * Modu Engine - Deterministic Multiplayer Sync Engine\n *\n * Features:\n * - Fixed-point math for 100% cross-platform determinism\n * - 2D/3D physics with ECS architecture\n * - Entity-Component-System with typed components\n * - Ordered input processing from modu-network\n */\n\n// ============================================\n// Math (Fixed-Point)\n// ============================================\nexport * from './math';\n\n// ============================================\n// Core ECS (Low-level primitives)\n// ============================================\nexport {\n    World,\n    EntityBuilder,\n    Entity,\n    EntityPool,\n    EntityIdAllocator,\n    defineComponent,\n    FieldType,\n    QueryEngine,\n    QueryIterator,\n    SystemScheduler,\n    RollbackBuffer,\n    SparseSnapshotCodec,\n    MAX_ENTITIES,\n    SYSTEM_PHASES,\n    SystemPhase,\n    INDEX_MASK\n} from './core';\n\nexport type {\n    WorldState,\n    EntityState,\n    NetworkInput,\n    ComponentSchema,\n    ComponentType,\n    SystemFn,\n    SystemOptions,\n    QueryableEntity,\n    SparseSnapshot,\n    EntityMeta\n} from './core';\n\n// ============================================\n// Components (Built-in ECS Components)\n// ============================================\nexport {\n    Transform2D,\n    Body2D,\n    Player,\n    Sprite,\n    Camera2D,\n    // Body type constants\n    BODY_DYNAMIC,\n    BODY_STATIC,\n    BODY_KINEMATIC,\n    // Shape type constants\n    SHAPE_RECT,\n    SHAPE_CIRCLE,\n    SPRITE_IMAGE\n} from './components';\n\n// ============================================\n// Game (High-level API)\n// ============================================\nexport { Game, createGame, Prefab } from './game';\nexport type { GameCallbacks } from './game';\n\n// ============================================\n// Plugins\n// ============================================\nexport { Simple2DRenderer, Simple2DRenderer as AutoRenderer, Simple2DRendererOptions } from './plugins/simple-2d-renderer';\nexport { InputPlugin } from './plugins/input-plugin';\nexport { CameraSystem, CameraSystemOptions } from './plugins/camera-system';\nexport { enableDebugUI, DebugUITarget } from './plugins/debug-ui';\nexport { enableDeterminismGuard, disableDeterminismGuard } from './plugins/determinism-guard';\nexport { Physics2DSystem, createPhysics2DSystem } from './plugins/physics2d/system';\nexport type { Physics2DSystemConfig } from './plugins/physics2d/system';\n\n// Physics engines (low-level)\nexport * as physics2d from './plugins/physics2d';\nexport * as physics3d from './plugins/physics3d';\n\n// ============================================\n// Sync (Rollback Networking)\n// ============================================\nexport * from './sync';\n\n// ============================================\n// Codec (Binary Encoding)\n// ============================================\nexport * as codec from './codec';\n", "/**\n * Fixed-Point Math Library for Deterministic Physics\n *\n * Uses 32-bit integers with 16.16 fixed-point format:\n * - 16 bits for integer part (-32768 to 32767)\n * - 16 bits for fractional part (precision ~0.000015)\n *\n * All operations are 100% deterministic across platforms.\n */\n\n// Fixed-point constants\nexport const FP_SHIFT = 16;\nexport const FP_ONE = 1 << FP_SHIFT;  // 65536\nexport const FP_HALF = FP_ONE >> 1;    // 32768\nexport const FP_PI = 205887;           // PI * 65536\nexport const FP_2PI = 411775;          // 2*PI * 65536\nexport const FP_HALF_PI = 102944;      // PI/2 * 65536\n\n// Type alias for fixed-point numbers (just integers)\nexport type Fixed = number;\n\n// ============================================\n// Basic Fixed-Point Operations\n// ============================================\n\n/** Convert float to fixed-point */\nexport function toFixed(f: number): Fixed {\n    return Math.round(f * FP_ONE);\n}\n\n/** Convert fixed-point to float (for rendering only) */\nexport function toFloat(fp: Fixed): number {\n    return fp / FP_ONE;\n}\n\n/** Fixed-point multiplication */\nexport function fpMul(a: Fixed, b: Fixed): Fixed {\n    // Use BigInt for intermediate to avoid overflow\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\n    // (e.g., distance calculations on a 1400x900 canvas can overflow)\n    // JavaScript numbers can safely represent integers up to 2^53\n    return Number((BigInt(a) * BigInt(b)) >> BigInt(FP_SHIFT));\n}\n\n/** Fixed-point division */\nexport function fpDiv(a: Fixed, b: Fixed): Fixed {\n    if (b === 0) return a >= 0 ? 0x7FFFFFFF : -0x7FFFFFFF;\n    // NOTE: Do NOT use | 0 here - it causes 32-bit overflow for large values\n    return Number((BigInt(a) << BigInt(FP_SHIFT)) / BigInt(b));\n}\n\n/** Fixed-point absolute value */\nexport function fpAbs(a: Fixed): Fixed {\n    return a < 0 ? -a : a;\n}\n\n/** Fixed-point sign */\nexport function fpSign(a: Fixed): Fixed {\n    return a > 0 ? FP_ONE : a < 0 ? -FP_ONE : 0;\n}\n\n/** Fixed-point min */\nexport function fpMin(a: Fixed, b: Fixed): Fixed {\n    return a < b ? a : b;\n}\n\n/** Fixed-point max */\nexport function fpMax(a: Fixed, b: Fixed): Fixed {\n    return a > b ? a : b;\n}\n\n/** Fixed-point clamp */\nexport function fpClamp(v: Fixed, min: Fixed, max: Fixed): Fixed {\n    return v < min ? min : v > max ? max : v;\n}\n\n/** Fixed-point floor */\nexport function fpFloor(a: Fixed): Fixed {\n    return a & ~(FP_ONE - 1);\n}\n\n/** Fixed-point ceil */\nexport function fpCeil(a: Fixed): Fixed {\n    return (a + FP_ONE - 1) & ~(FP_ONE - 1);\n}\n\n// ============================================\n// Square Root (using Newton-Raphson)\n// ============================================\n\n/** Fixed-point square root using Newton-Raphson iteration */\nexport function fpSqrt(a: Fixed): Fixed {\n    if (a <= 0) return 0;\n\n    // For 16.16 fixed-point: if a = v * 65536, we want sqrt(v) * 65536\n    // sqrt(a) would give sqrt(v) * 256, which is 256x too small!\n    // Solution: compute sqrt(a * 65536) = sqrt(a) * 256 = sqrt(v) * 65536\n    const scaled = BigInt(a) * BigInt(FP_ONE);\n    if (scaled <= 0n) return 0;\n\n    // Better initial guess using bit length\n    let bitLen = 0n;\n    let temp = scaled;\n    while (temp > 0n) {\n        bitLen++;\n        temp >>= 1n;\n    }\n\n    let x = 1n << (bitLen >> 1n);\n    if (x === 0n) x = 1n;\n\n    // Newton-Raphson with proper convergence check\n    let prevX = 0n;\n    for (let i = 0; i < 30; i++) {\n        const xNew = (x + scaled / x) >> 1n;\n        // Check for true convergence (oscillating between x and x+1)\n        if (xNew === x || xNew === prevX) break;\n        prevX = x;\n        x = xNew;\n    }\n\n    // Final adjustment: ensure x*x <= scaled < (x+1)*(x+1)\n    while (x * x > scaled) x--;\n    while ((x + 1n) * (x + 1n) <= scaled) x++;\n\n    return Number(x);\n}\n\n/**\n * Deterministic square root (float API).\n * Takes a float, returns a float, but uses fixed-point internally for determinism.\n *\n * @example\n * const dist = dSqrt(dx * dx + dy * dy);  // Deterministic!\n */\nexport function dSqrt(x: number): number {\n    return toFloat(fpSqrt(toFixed(x)));\n}\n\n// ============================================\n// Trigonometry (Lookup Tables)\n// ============================================\n\n// Sine lookup table (257 entries for 0 to PI/2, inclusive)\n// PRE-COMPUTED for cross-platform determinism - DO NOT use Math.sin() at runtime!\n// Math.sin() produces different results across browsers/CPUs, breaking determinism.\nconst SIN_TABLE_SIZE = 256;\nconst SIN_TABLE: Fixed[] = [\n    0, 402, 804, 1206, 1608, 2010, 2412, 2814, 3216, 3617, 4019, 4420, 4821, 5222, 5623, 6023,\n    6424, 6824, 7224, 7623, 8022, 8421, 8820, 9218, 9616, 10014, 10411, 10808, 11204, 11600, 11996, 12391,\n    12785, 13180, 13573, 13966, 14359, 14751, 15143, 15534, 15924, 16314, 16703, 17091, 17479, 17867, 18253, 18639,\n    19024, 19409, 19792, 20175, 20557, 20939, 21320, 21699, 22078, 22457, 22834, 23210, 23586, 23961, 24335, 24708,\n    25080, 25451, 25821, 26190, 26558, 26925, 27291, 27656, 28020, 28383, 28745, 29106, 29466, 29824, 30182, 30538,\n    30893, 31248, 31600, 31952, 32303, 32652, 33000, 33347, 33692, 34037, 34380, 34721, 35062, 35401, 35738, 36075,\n    36410, 36744, 37076, 37407, 37736, 38064, 38391, 38716, 39040, 39362, 39683, 40002, 40320, 40636, 40951, 41264,\n    41576, 41886, 42194, 42501, 42806, 43110, 43412, 43713, 44011, 44308, 44604, 44898, 45190, 45480, 45769, 46056,\n    46341, 46624, 46906, 47186, 47464, 47741, 48015, 48288, 48559, 48828, 49095, 49361, 49624, 49886, 50146, 50404,\n    50660, 50914, 51166, 51417, 51665, 51911, 52156, 52398, 52639, 52878, 53114, 53349, 53581, 53812, 54040, 54267,\n    54491, 54714, 54934, 55152, 55368, 55582, 55794, 56004, 56212, 56418, 56621, 56823, 57022, 57219, 57414, 57607,\n    57798, 57986, 58172, 58356, 58538, 58718, 58896, 59071, 59244, 59415, 59583, 59750, 59914, 60075, 60235, 60392,\n    60547, 60700, 60851, 60999, 61145, 61288, 61429, 61568, 61705, 61839, 61971, 62101, 62228, 62353, 62476, 62596,\n    62714, 62830, 62943, 63054, 63162, 63268, 63372, 63473, 63572, 63668, 63763, 63854, 63944, 64031, 64115, 64197,\n    64277, 64354, 64429, 64501, 64571, 64639, 64704, 64766, 64827, 64884, 64940, 64993, 65043, 65091, 65137, 65180,\n    65220, 65259, 65294, 65328, 65358, 65387, 65413, 65436, 65457, 65476, 65492, 65505, 65516, 65525, 65531, 65535,\n    65536  // sin(PI/2) = 1.0 = FP_ONE\n];\n\n// Pre-computed constant: (SIN_TABLE_SIZE * 2 / PI) in fixed-point\n// Used to map angles to table indices. Pre-computed to avoid Math.PI at runtime.\nconst FP_ANGLE_TO_INDEX = 10680707;  // = round(162.9746617261 * 65536)\n\n/** Fixed-point sine using lookup table with linear interpolation */\nexport function fpSin(angle: Fixed): Fixed {\n    // Normalize angle to 0 to 2PI using modulo (avoids infinite loops)\n    // First handle negative angles\n    if (angle < 0) {\n        const periods = ((-angle / FP_2PI) | 0) + 1;\n        angle += periods * FP_2PI;\n    }\n    // Then reduce to 0..2PI range\n    if (angle >= FP_2PI) {\n        angle = angle % FP_2PI;\n    }\n\n    // Determine quadrant\n    let quadrant = 0;\n    if (angle >= FP_PI) {\n        angle -= FP_PI;\n        quadrant = 2;\n    }\n    if (angle >= FP_HALF_PI) {\n        angle = FP_PI - angle;\n        quadrant += 1;\n    }\n\n    // Map angle to table index (0 to 256)\n    const indexFp = fpMul(angle, FP_ANGLE_TO_INDEX);\n    const index = indexFp >> FP_SHIFT;\n    const frac = indexFp & (FP_ONE - 1);\n\n    // Linear interpolation with safe bounds clamping\n    const clampedIndex = index < 0 ? 0 : (index > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : index);\n    const nextIndex = index + 1;\n    const clampedIndexNext = nextIndex < 0 ? 0 : (nextIndex > SIN_TABLE_SIZE ? SIN_TABLE_SIZE : nextIndex);\n    const a = SIN_TABLE[clampedIndex] ?? 0;\n    const b = SIN_TABLE[clampedIndexNext] ?? FP_ONE;\n    let result = a + fpMul(b - a, frac);\n\n    // Apply quadrant sign\n    if (quadrant >= 2) result = -result;\n\n    return result;\n}\n\n/** Fixed-point cosine */\nexport function fpCos(angle: Fixed): Fixed {\n    return fpSin(angle + FP_HALF_PI);\n}\n\n/** Fixed-point atan2 using CORDIC-style approximation */\nexport function fpAtan2(y: Fixed, x: Fixed): Fixed {\n    if (x === 0 && y === 0) return 0;\n\n    const absX = fpAbs(x);\n    const absY = fpAbs(y);\n\n    // Use approximation: atan(y/x) = (PI/4) * (y/x) for |y/x| <= 1\n    let angle: Fixed;\n    if (absX >= absY) {\n        const ratio = fpDiv(absY, absX);\n        // atan approximation for small angles\n        angle = fpMul(ratio, 51472); // PI/4 * 65536 = 51472\n    } else {\n        const ratio = fpDiv(absX, absY);\n        angle = FP_HALF_PI - fpMul(ratio, 51472);\n    }\n\n    // Adjust for quadrant\n    if (x < 0) angle = FP_PI - angle;\n    if (y < 0) angle = -angle;\n\n    return angle;\n}\n", "/**\r\n * Fixed-Point Vector Types\r\n *\r\n * 2D and 3D vectors using fixed-point arithmetic for deterministic physics.\r\n */\r\n\r\nimport { Fixed, FP_ONE, toFixed, toFloat, fpMul, fpDiv, fpSqrt } from './fixed';\r\n\r\n// ============================================\r\n// 2D Vector (Fixed-Point)\r\n// ============================================\r\n\r\nexport interface Vec2 {\r\n    x: Fixed;\r\n    y: Fixed;\r\n}\r\n\r\nexport function vec2(x: number, y: number): Vec2 {\r\n    return { x: toFixed(x), y: toFixed(y) };\r\n}\r\n\r\nexport function vec2Zero(): Vec2 {\r\n    return { x: 0, y: 0 };\r\n}\r\n\r\nexport function vec2FromFixed(x: Fixed, y: Fixed): Vec2 {\r\n    return { x, y };\r\n}\r\n\r\nexport function vec2Clone(v: Vec2): Vec2 {\r\n    return { x: v.x, y: v.y };\r\n}\r\n\r\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\r\n    return { x: a.x + b.x, y: a.y + b.y };\r\n}\r\n\r\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\r\n    return { x: a.x - b.x, y: a.y - b.y };\r\n}\r\n\r\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\r\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\r\n}\r\n\r\nexport function vec2Neg(v: Vec2): Vec2 {\r\n    return { x: -v.x, y: -v.y };\r\n}\r\n\r\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\r\n    return fpMul(a.x, b.x) + fpMul(a.y, b.y);\r\n}\r\n\r\n/** 2D cross product (returns z component of 3D cross) */\r\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\r\n    return fpMul(a.x, b.y) - fpMul(a.y, b.x);\r\n}\r\n\r\nexport function vec2LengthSq(v: Vec2): Fixed {\r\n    return fpMul(v.x, v.x) + fpMul(v.y, v.y);\r\n}\r\n\r\nexport function vec2Length(v: Vec2): Fixed {\r\n    return fpSqrt(vec2LengthSq(v));\r\n}\r\n\r\nexport function vec2Normalize(v: Vec2): Vec2 {\r\n    const len = vec2Length(v);\r\n    if (len === 0) return vec2Zero();\r\n    return { x: fpDiv(v.x, len), y: fpDiv(v.y, len) };\r\n}\r\n\r\nexport function vec2Lerp(a: Vec2, b: Vec2, t: Fixed): Vec2 {\r\n    const oneMinusT = FP_ONE - t;\r\n    return {\r\n        x: fpMul(a.x, oneMinusT) + fpMul(b.x, t),\r\n        y: fpMul(a.y, oneMinusT) + fpMul(b.y, t)\r\n    };\r\n}\r\n\r\nexport function vec2Distance(a: Vec2, b: Vec2): Fixed {\r\n    return vec2Length(vec2Sub(b, a));\r\n}\r\n\r\nexport function vec2DistanceSq(a: Vec2, b: Vec2): Fixed {\r\n    return vec2LengthSq(vec2Sub(b, a));\r\n}\r\n\r\n// ============================================\r\n// 3D Vector (Fixed-Point)\r\n// ============================================\r\n\r\nexport interface Vec3 {\r\n    x: Fixed;\r\n    y: Fixed;\r\n    z: Fixed;\r\n}\r\n\r\nexport function vec3(x: Fixed, y: Fixed, z: Fixed): Vec3 {\r\n    return { x, y, z };\r\n}\r\n\r\nexport function vec3Zero(): Vec3 {\r\n    return { x: 0, y: 0, z: 0 };\r\n}\r\n\r\nexport function vec3FromFloats(x: number, y: number, z: number): Vec3 {\r\n    return { x: toFixed(x), y: toFixed(y), z: toFixed(z) };\r\n}\r\n\r\nexport function vec3ToFloats(v: Vec3): { x: number; y: number; z: number } {\r\n    return { x: toFloat(v.x), y: toFloat(v.y), z: toFloat(v.z) };\r\n}\r\n\r\nexport function vec3Clone(v: Vec3): Vec3 {\r\n    return { x: v.x, y: v.y, z: v.z };\r\n}\r\n\r\nexport function vec3Add(a: Vec3, b: Vec3): Vec3 {\r\n    return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\r\n}\r\n\r\nexport function vec3Sub(a: Vec3, b: Vec3): Vec3 {\r\n    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\r\n}\r\n\r\nexport function vec3Scale(v: Vec3, s: Fixed): Vec3 {\r\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s), z: fpMul(v.z, s) };\r\n}\r\n\r\nexport function vec3Neg(v: Vec3): Vec3 {\r\n    return { x: -v.x, y: -v.y, z: -v.z };\r\n}\r\n\r\nexport function vec3Dot(a: Vec3, b: Vec3): Fixed {\r\n    return fpMul(a.x, b.x) + fpMul(a.y, b.y) + fpMul(a.z, b.z);\r\n}\r\n\r\nexport function vec3Cross(a: Vec3, b: Vec3): Vec3 {\r\n    return {\r\n        x: fpMul(a.y, b.z) - fpMul(a.z, b.y),\r\n        y: fpMul(a.z, b.x) - fpMul(a.x, b.z),\r\n        z: fpMul(a.x, b.y) - fpMul(a.y, b.x)\r\n    };\r\n}\r\n\r\nexport function vec3LengthSq(v: Vec3): Fixed {\r\n    return fpMul(v.x, v.x) + fpMul(v.y, v.y) + fpMul(v.z, v.z);\r\n}\r\n\r\nexport function vec3Length(v: Vec3): Fixed {\r\n    return fpSqrt(vec3LengthSq(v));\r\n}\r\n\r\nexport function vec3Normalize(v: Vec3): Vec3 {\r\n    const len = vec3Length(v);\r\n    if (len === 0) return vec3Zero();\r\n    return { x: fpDiv(v.x, len), y: fpDiv(v.y, len), z: fpDiv(v.z, len) };\r\n}\r\n\r\nexport function vec3Lerp(a: Vec3, b: Vec3, t: Fixed): Vec3 {\r\n    const oneMinusT = FP_ONE - t;\r\n    return {\r\n        x: fpMul(a.x, oneMinusT) + fpMul(b.x, t),\r\n        y: fpMul(a.y, oneMinusT) + fpMul(b.y, t),\r\n        z: fpMul(a.z, oneMinusT) + fpMul(b.z, t)\r\n    };\r\n}\r\n\r\nexport function vec3Distance(a: Vec3, b: Vec3): Fixed {\r\n    return vec3Length(vec3Sub(b, a));\r\n}\r\n\r\nexport function vec3DistanceSq(a: Vec3, b: Vec3): Fixed {\r\n    return vec3LengthSq(vec3Sub(b, a));\r\n}\r\n", "/**\r\n * Fixed-Point Quaternion Operations\r\n *\r\n * Quaternion math for 3D rotations using fixed-point arithmetic.\r\n */\r\n\r\nimport { Fixed, FP_ONE, fpMul, fpDiv, fpSqrt, fpSin, fpCos } from './fixed';\r\nimport { Vec3, vec3, vec3Normalize, vec3Cross, vec3Add, vec3Scale } from './vec';\r\n\r\n// ============================================\r\n// Quaternion (Fixed-Point)\r\n// ============================================\r\n\r\nexport interface Quat {\r\n    x: Fixed;\r\n    y: Fixed;\r\n    z: Fixed;\r\n    w: Fixed;\r\n}\r\n\r\nexport function quatIdentity(): Quat {\r\n    return { x: 0, y: 0, z: 0, w: FP_ONE };\r\n}\r\n\r\nexport function quatFromAxisAngle(axis: Vec3, angle: Fixed): Quat {\r\n    const halfAngle = angle >> 1;\r\n    const s = fpSin(halfAngle);\r\n    const c = fpCos(halfAngle);\r\n    const normAxis = vec3Normalize(axis);\r\n    return {\r\n        x: fpMul(normAxis.x, s),\r\n        y: fpMul(normAxis.y, s),\r\n        z: fpMul(normAxis.z, s),\r\n        w: c\r\n    };\r\n}\r\n\r\nexport function quatFromEulerY(yaw: Fixed): Quat {\r\n    const halfAngle = yaw >> 1;\r\n    return {\r\n        x: 0,\r\n        y: fpSin(halfAngle),\r\n        z: 0,\r\n        w: fpCos(halfAngle)\r\n    };\r\n}\r\n\r\nexport function quatMul(a: Quat, b: Quat): Quat {\r\n    return {\r\n        x: fpMul(a.w, b.x) + fpMul(a.x, b.w) + fpMul(a.y, b.z) - fpMul(a.z, b.y),\r\n        y: fpMul(a.w, b.y) - fpMul(a.x, b.z) + fpMul(a.y, b.w) + fpMul(a.z, b.x),\r\n        z: fpMul(a.w, b.z) + fpMul(a.x, b.y) - fpMul(a.y, b.x) + fpMul(a.z, b.w),\r\n        w: fpMul(a.w, b.w) - fpMul(a.x, b.x) - fpMul(a.y, b.y) - fpMul(a.z, b.z)\r\n    };\r\n}\r\n\r\nexport function quatRotateVec3(q: Quat, v: Vec3): Vec3 {\r\n    // q * v * q^-1 (optimized)\r\n    const qv = vec3(q.x, q.y, q.z);\r\n    const uv = vec3Cross(qv, v);\r\n    const uuv = vec3Cross(qv, uv);\r\n    return vec3Add(v, vec3Add(vec3Scale(uv, q.w << 1), vec3Scale(uuv, FP_ONE << 1)));\r\n}\r\n\r\nexport function quatNormalize(q: Quat): Quat {\r\n    const lenSq = fpMul(q.x, q.x) + fpMul(q.y, q.y) + fpMul(q.z, q.z) + fpMul(q.w, q.w);\r\n    const len = fpSqrt(lenSq);\r\n    if (len === 0) return quatIdentity();\r\n    return {\r\n        x: fpDiv(q.x, len),\r\n        y: fpDiv(q.y, len),\r\n        z: fpDiv(q.z, len),\r\n        w: fpDiv(q.w, len)\r\n    };\r\n}\r\n\r\n/** Quaternion conjugate (inverse for unit quaternions) */\r\nexport function quatConjugate(q: Quat): Quat {\r\n    return { x: -q.x as Fixed, y: -q.y as Fixed, z: -q.z as Fixed, w: q.w };\r\n}\r\n\r\n/** Clone a quaternion */\r\nexport function quatClone(q: Quat): Quat {\r\n    return { x: q.x, y: q.y, z: q.z, w: q.w };\r\n}\r\n", "/**\r\n * Deterministic Random\r\n *\r\n * Simple, deterministic random function. Same seed = same sequence.\r\n * Automatically overrides Math.random() on import for full determinism.\r\n */\r\n\r\n// ============================================\r\n// Internal State\r\n// ============================================\r\n\r\nlet s0 = 1;\r\nlet s1 = 2;\r\n\r\n// ============================================\r\n// Core Random Function\r\n// ============================================\r\n\r\nfunction next(): number {\r\n    let x = s0;\r\n    const y = s1;\r\n    s0 = y;\r\n    x ^= (x << 23) >>> 0;\r\n    x ^= x >>> 17;\r\n    x ^= y;\r\n    x ^= y >>> 26;\r\n    s1 = x >>> 0;\r\n    return (s0 + s1) >>> 0;\r\n}\r\n\r\n// ============================================\r\n// Public API\r\n// ============================================\r\n\r\n/**\r\n * Set the random seed (internal use).\r\n */\r\nfunction setSeed(seed: number): void {\r\n    seed = seed >>> 0;\r\n    if (seed === 0) seed = 1;\r\n\r\n    // Mix the seed into two state values\r\n    let s = seed;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s0 = ((s >>> 16) ^ s) >>> 0;\r\n\r\n    s = (seed * 0x9e3779b9) >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s = ((s >>> 16) ^ s) * 0x45d9f3b >>> 0;\r\n    s1 = ((s >>> 16) ^ s) >>> 0;\r\n\r\n    if (s0 === 0 && s1 === 0) s0 = 1;\r\n}\r\n\r\n/**\r\n * Get random float between 0 (inclusive) and 1 (exclusive).\r\n * Works like Math.random() but deterministic.\r\n */\r\nexport function dRandom(): number {\r\n    return next() / 0x100000000;\r\n}\r\n\r\n// ============================================\r\n// State Save/Load (for rollback)\r\n// ============================================\r\n\r\nexport interface RandomState {\r\n    s0: number;\r\n    s1: number;\r\n}\r\n\r\nexport function saveRandomState(): RandomState {\r\n    return { s0, s1 };\r\n}\r\n\r\nexport function loadRandomState(state: RandomState): void {\r\n    s0 = state.s0;\r\n    s1 = state.s1;\r\n}\r\n\r\n// Initialize with default seed\r\nsetSeed(1);\r\n", "/**\r\n * ECS Constants\r\n *\r\n * Core constants for the Entity-Component-System architecture.\r\n */\r\n\r\n/**\r\n * Maximum number of concurrent entities.\r\n *\r\n * This is a hard limit due to TypedArray storage. Exceeding this will\r\n * throw an error. For most games, 10,000 is far more than needed.\r\n *\r\n * Memory usage per component field: MAX_ENTITIES \u00D7 4 bytes = 40 KB\r\n * With 10 components \u00D7 5 fields average = 2 MB total\r\n */\r\nexport const MAX_ENTITIES = 10_000;\r\n\r\n/**\r\n * Entity ID format: [12 bits generation][20 bits index]\r\n * - Generation: Prevents ABA problem when IDs are recycled\r\n * - Index: Direct array index for O(1) component access\r\n */\r\nexport const GENERATION_BITS = 12;\r\nexport const INDEX_BITS = 20;\r\nexport const INDEX_MASK = (1 << INDEX_BITS) - 1;\r\nexport const MAX_GENERATION = (1 << GENERATION_BITS) - 1;\r\n\r\n/**\r\n * System execution phases (in order)\r\n */\r\nexport const SYSTEM_PHASES = [\r\n    'input',\r\n    'update',\r\n    'prePhysics',\r\n    'physics',\r\n    'postPhysics',\r\n    'render'\r\n] as const;\r\n\r\nexport type SystemPhase = typeof SYSTEM_PHASES[number];\r\n", "/**\r\n * Component System\r\n *\r\n * Components are pure data containers. This module handles:\r\n * - Component type definitions with schemas\r\n * - Type inference from default values\r\n * - SoA (Structure of Arrays) storage allocation\r\n * - Pre-generated accessor class creation\r\n */\r\n\r\nimport { MAX_ENTITIES } from './constants';\r\nimport { toFixed, toFloat } from '../math';\r\n\r\n/**\r\n * Supported field types for components.\r\n * - i32: 32-bit integer (default for numbers, uses fixed-point for physics)\r\n * - u8: 8-bit unsigned (for flags, enums)\r\n * - bool: boolean (stored as u8)\r\n * - f32: 32-bit float (ONLY for render-only data, NON-DETERMINISTIC)\r\n */\r\nexport type FieldType = 'i32' | 'u8' | 'bool' | 'f32';\r\n\r\nexport interface FieldDefinition {\r\n    type: FieldType;\r\n    default: number | boolean;\r\n}\r\n\r\nexport interface ComponentSchema {\r\n    [fieldName: string]: FieldDefinition;\r\n}\r\n\r\n/**\r\n * Component storage using Structure of Arrays (SoA) pattern.\r\n * Each field is stored in a separate TypedArray for cache efficiency.\r\n */\r\nexport interface ComponentStorage {\r\n    /** Bitmask tracking which entities have this component */\r\n    mask: Uint32Array;\r\n\r\n    /** Field arrays indexed by entity index */\r\n    fields: Record<string, Int32Array | Uint8Array | Float32Array>;\r\n\r\n    /** Schema defining field types */\r\n    schema: ComponentSchema;\r\n}\r\n\r\n/**\r\n * Options for defining a component.\r\n */\r\nexport interface ComponentOptions {\r\n    /**\r\n     * Whether this component should be synchronized across the network.\r\n     * When false, the component is excluded from:\r\n     * - Network snapshots (not sent to other clients)\r\n     * - State hash computation (doesn't affect determinism checks)\r\n     * - Rollback state (not saved/restored during rollback)\r\n     *\r\n     * Use sync: false for client-only state like cameras, UI, local effects.\r\n     * @default true\r\n     */\r\n    sync?: boolean;\r\n}\r\n\r\n/**\r\n * Component type definition.\r\n */\r\nexport interface ComponentType<T extends Record<string, any> = any> {\r\n    readonly name: string;\r\n    readonly schema: ComponentSchema;\r\n    readonly storage: ComponentStorage;\r\n    readonly AccessorClass: new (index: number) => T;\r\n    readonly fieldNames: string[];\r\n    /** Whether this component is synchronized across network. Default: true */\r\n    readonly sync: boolean;\r\n}\r\n\r\n/**\r\n * Infer field definition from a default value.\r\n * ALL numbers default to i32 for determinism.\r\n * f32 requires explicit declaration and logs a warning.\r\n */\r\nexport function inferFieldDef(value: any): FieldDefinition {\r\n    // Explicit type definition\r\n    if (typeof value === 'object' && value !== null && 'type' in value) {\r\n        const def = value as { type: FieldType; default?: number | boolean };\r\n\r\n        if (def.type === 'f32') {\r\n            console.warn(\r\n                `Component field uses f32 which is NON-DETERMINISTIC. ` +\r\n                `Only use for render-only data, never for synced state.`\r\n            );\r\n        }\r\n\r\n        return {\r\n            type: def.type,\r\n            default: def.default ?? (def.type === 'bool' ? false : 0)\r\n        };\r\n    }\r\n\r\n    // Boolean inference\r\n    if (typeof value === 'boolean') {\r\n        return { type: 'bool', default: value };\r\n    }\r\n\r\n    // Number inference - ALL default to i32 for determinism\r\n    if (typeof value === 'number') {\r\n        return { type: 'i32', default: value };\r\n    }\r\n\r\n    // Null/undefined treated as i32 with 0 default\r\n    if (value === null || value === undefined) {\r\n        return { type: 'i32', default: 0 };\r\n    }\r\n\r\n    throw new Error(\r\n        `Unsupported field type: ${typeof value}. ` +\r\n        `Components can only contain numbers and booleans. ` +\r\n        `Use game.internString() for string values.`\r\n    );\r\n}\r\n\r\n/**\r\n * Create TypedArray for a field type.\r\n */\r\nfunction createFieldArray(type: FieldType): Int32Array | Uint8Array | Float32Array {\r\n    switch (type) {\r\n        case 'i32':\r\n            return new Int32Array(MAX_ENTITIES);\r\n        case 'u8':\r\n        case 'bool':\r\n            return new Uint8Array(MAX_ENTITIES);\r\n        case 'f32':\r\n            return new Float32Array(MAX_ENTITIES);\r\n        default:\r\n            throw new Error(`Unknown field type: ${type}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Create SoA storage for a component schema.\r\n */\r\nexport function createComponentStorage(schema: ComponentSchema): ComponentStorage {\r\n    const fields: Record<string, Int32Array | Uint8Array | Float32Array> = {};\r\n\r\n    for (const [name, def] of Object.entries(schema)) {\r\n        fields[name] = createFieldArray(def.type);\r\n    }\r\n\r\n    return {\r\n        mask: new Uint32Array(Math.ceil(MAX_ENTITIES / 32)),\r\n        fields,\r\n        schema\r\n    };\r\n}\r\n\r\n/**\r\n * Generate an accessor class for a component type.\r\n * Uses Object.defineProperty for optimal V8 performance (not Proxy).\r\n */\r\nexport function generateAccessorClass<T>(\r\n    name: string,\r\n    schema: ComponentSchema,\r\n    storage: ComponentStorage\r\n): new (index: number) => T {\r\n    // Create a class dynamically\r\n    const AccessorClass = function(this: any, index: number) {\r\n        this._index = index;\r\n    } as any;\r\n\r\n    AccessorClass.prototype = {};\r\n\r\n    // Add getter/setter for each field\r\n    for (const [fieldName, fieldDef] of Object.entries(schema)) {\r\n        const fieldArray = storage.fields[fieldName];\r\n        const isFixedPoint = fieldDef.type === 'i32';\r\n        const isBool = fieldDef.type === 'bool';\r\n\r\n        Object.defineProperty(AccessorClass.prototype, fieldName, {\r\n            get: function(this: { _index: number }) {\r\n                const value = fieldArray[this._index];\r\n                if (isBool) return value !== 0;\r\n                if (isFixedPoint) return toFloat(value as number);\r\n                return value;\r\n            },\r\n            set: function(this: { _index: number }, value: any) {\r\n                if (isBool) {\r\n                    fieldArray[this._index] = value ? 1 : 0;\r\n                } else if (isFixedPoint) {\r\n                    fieldArray[this._index] = toFixed(value);\r\n                } else {\r\n                    fieldArray[this._index] = value;\r\n                }\r\n            },\r\n            enumerable: true,\r\n            configurable: false\r\n        });\r\n    }\r\n\r\n    // Add _index property definition\r\n    Object.defineProperty(AccessorClass.prototype, '_index', {\r\n        value: 0,\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    return AccessorClass as new (index: number) => T;\r\n}\r\n\r\n/**\r\n * Component registry - stores all defined components.\r\n */\r\nconst componentRegistry = new Map<string, ComponentType>();\r\n\r\n/**\r\n * Define a new component type.\r\n *\r\n * @param name Unique component name\r\n * @param defaults Default values (type inferred from values)\r\n * @param options Optional configuration (sync, etc.)\r\n * @returns ComponentType for use in entity definitions\r\n *\r\n * @example\r\n * const Health = defineComponent('health', { current: 100, max: 100 });\r\n * const Position = defineComponent('position', { x: 0, y: 0 });\r\n *\r\n * // Client-only component (not synced)\r\n * const Camera2D = defineComponent('camera2d', { zoom: 1, targetZoom: 1 }, { sync: false });\r\n */\r\nexport function defineComponent<T extends Record<string, any>>(\r\n    name: string,\r\n    defaults: T,\r\n    options?: ComponentOptions\r\n): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\r\n    if (componentRegistry.has(name)) {\r\n        throw new Error(`Component '${name}' is already defined`);\r\n    }\r\n\r\n    // Build schema from defaults\r\n    const schema: ComponentSchema = {};\r\n    for (const [fieldName, defaultValue] of Object.entries(defaults)) {\r\n        schema[fieldName] = inferFieldDef(defaultValue);\r\n    }\r\n\r\n    // Create storage\r\n    const storage = createComponentStorage(schema);\r\n\r\n    // Generate accessor class\r\n    const AccessorClass = generateAccessorClass<any>(name, schema, storage);\r\n\r\n    const componentType: ComponentType = {\r\n        name,\r\n        schema,\r\n        storage,\r\n        AccessorClass,\r\n        fieldNames: Object.keys(schema),\r\n        sync: options?.sync !== false // Default to true\r\n    };\r\n\r\n    componentRegistry.set(name, componentType);\r\n\r\n    return componentType as any;\r\n}\r\n\r\n/**\r\n * Get a component type by name.\r\n */\r\nexport function getComponentType(name: string): ComponentType | undefined {\r\n    return componentRegistry.get(name);\r\n}\r\n\r\n/**\r\n * Check if entity has component (via bitmask).\r\n */\r\nexport function hasComponent(storage: ComponentStorage, index: number): boolean {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    return (storage.mask[word] & bit) !== 0;\r\n}\r\n\r\n/**\r\n * Add component to entity (set bit in mask).\r\n */\r\nexport function addComponentToEntity(storage: ComponentStorage, index: number): void {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    storage.mask[word] |= bit;\r\n}\r\n\r\n/**\r\n * Remove component from entity (clear bit in mask).\r\n */\r\nexport function removeComponentFromEntity(storage: ComponentStorage, index: number): void {\r\n    const word = index >>> 5;\r\n    const bit = 1 << (index & 31);\r\n    storage.mask[word] &= ~bit;\r\n}\r\n\r\n/**\r\n * Initialize component fields to defaults for an entity.\r\n */\r\nexport function initializeComponentDefaults(storage: ComponentStorage, index: number): void {\r\n    for (const [fieldName, fieldDef] of Object.entries(storage.schema)) {\r\n        const arr = storage.fields[fieldName];\r\n        if (fieldDef.type === 'i32') {\r\n            arr[index] = toFixed(fieldDef.default as number);\r\n        } else if (fieldDef.type === 'bool') {\r\n            arr[index] = fieldDef.default ? 1 : 0;\r\n        } else {\r\n            arr[index] = fieldDef.default as number;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Clear all component registrations (for testing).\r\n */\r\nexport function clearComponentRegistry(): void {\r\n    componentRegistry.clear();\r\n}\r\n\r\n/**\r\n * Get all registered components.\r\n */\r\nexport function getAllComponents(): Map<string, ComponentType> {\r\n    return componentRegistry;\r\n}\r\n", "/**\n * Entity ID Allocator\n *\n * Manages entity ID allocation with generation counters for ABA safety.\n * Entity ID format: [12 bits generation][20 bits index]\n */\n\nimport {\n    MAX_ENTITIES,\n    INDEX_MASK,\n    INDEX_BITS,\n    MAX_GENERATION,\n    GENERATION_BITS\n} from './constants';\n\nexport interface EntityIdAllocatorState {\n    nextIndex: number;\n    freeList: number[];\n    generations: number[];\n}\n\nexport class EntityIdAllocator {\n    /** Generation counter for each entity slot */\n    private generations: Uint16Array;\n\n    /** Free list of available indices (sorted ascending for determinism) */\n    private freeList: number[] = [];\n\n    /** Next index to allocate if free list is empty */\n    private nextIndex: number = 0;\n\n    constructor() {\n        this.generations = new Uint16Array(MAX_ENTITIES);\n    }\n\n    /**\n     * Allocate a new entity ID.\n     * Returns entity ID with generation encoded.\n     */\n    allocate(): number {\n        let index: number;\n\n        if (this.freeList.length > 0) {\n            // Always take the LOWEST available index for determinism\n            index = this.freeList.shift()!;\n        } else {\n            if (this.nextIndex >= MAX_ENTITIES) {\n                throw new Error(\n                    `Entity limit exceeded (MAX_ENTITIES=${MAX_ENTITIES}). ` +\n                    `Consider destroying unused entities or increasing the limit.`\n                );\n            }\n            index = this.nextIndex++;\n        }\n\n        const generation = this.generations[index];\n        return (generation << INDEX_BITS) | index;\n    }\n\n    /**\n     * Free an entity ID, returning it to the pool.\n     * Increments generation to invalidate stale references.\n     */\n    free(eid: number): void {\n        const index = eid & INDEX_MASK;\n\n        // Increment generation (wrap at max)\n        this.generations[index] = ((this.generations[index] + 1) & MAX_GENERATION) as number;\n\n        // Binary search insert to maintain sorted order (deterministic)\n        const insertIdx = this.findInsertIndex(index);\n        this.freeList.splice(insertIdx, 0, index);\n    }\n\n    /**\n     * Check if an entity ID is still valid (generation matches).\n     */\n    isValid(eid: number): boolean {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n        return index < this.nextIndex && this.generations[index] === generation;\n    }\n\n    /**\n     * Get the index portion of an entity ID.\n     */\n    getIndex(eid: number): number {\n        return eid & INDEX_MASK;\n    }\n\n    /**\n     * Get the generation portion of an entity ID.\n     */\n    getGeneration(eid: number): number {\n        return eid >>> INDEX_BITS;\n    }\n\n    /**\n     * Get current state for snapshotting.\n     */\n    getState(): EntityIdAllocatorState {\n        return {\n            nextIndex: this.nextIndex,\n            freeList: [...this.freeList],\n            generations: Array.from(this.generations.slice(0, this.nextIndex))\n        };\n    }\n\n    /**\n     * Restore state from snapshot.\n     */\n    setState(state: EntityIdAllocatorState): void {\n        this.nextIndex = state.nextIndex;\n        this.freeList = [...state.freeList];\n\n        // Restore generations\n        for (let i = 0; i < state.generations.length; i++) {\n            this.generations[i] = state.generations[i];\n        }\n    }\n\n    /**\n     * Reset allocator to initial state.\n     */\n    reset(): void {\n        this.nextIndex = 0;\n        this.freeList = [];\n        this.generations.fill(0);\n    }\n\n    /**\n     * Get number of active entities.\n     */\n    getActiveCount(): number {\n        return this.nextIndex - this.freeList.length;\n    }\n\n    /**\n     * Binary search to find insert position for sorted free list.\n     */\n    /**\n     * Get next ID that will be allocated (for snapshots).\n     */\n    getNextId(): number {\n        return this.nextIndex;\n    }\n\n    /**\n     * Set next ID (for snapshot restore).\n     */\n    setNextId(id: number): void {\n        this.nextIndex = id;\n    }\n\n    /**\n     * Allocate a specific entity ID (for snapshot restore).\n     * This bypasses normal allocation and marks the specific eid as used.\n     * Returns the requested eid.\n     */\n    allocateSpecific(eid: number): number {\n        const index = eid & INDEX_MASK;\n        const generation = eid >>> INDEX_BITS;\n\n        // Extend nextIndex if needed\n        if (index >= this.nextIndex) {\n            this.nextIndex = index + 1;\n        }\n\n        // Remove from free list if present\n        const freeIdx = this.freeList.indexOf(index);\n        if (freeIdx !== -1) {\n            this.freeList.splice(freeIdx, 1);\n        }\n\n        // Set the generation\n        this.generations[index] = generation;\n\n        return eid;\n    }\n\n    private findInsertIndex(index: number): number {\n        let lo = 0;\n        let hi = this.freeList.length;\n\n        while (lo < hi) {\n            const mid = (lo + hi) >>> 1;\n            if (this.freeList[mid] < index) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n}\n", "/**\r\n * Standard ECS Components\r\n *\r\n * Built-in components for common game functionality.\r\n * All numeric values use fixed-point (i32) for determinism.\r\n */\r\n\r\nimport { defineComponent, ComponentType } from '../core/component';\r\n\r\n/**\r\n * Transform2D - Position and rotation.\r\n */\r\nexport const Transform2D = defineComponent('Transform2D', {\r\n    x: 0,\r\n    y: 0,\r\n    angle: 0\r\n});\r\n\r\n/**\r\n * Body2D - Physics body properties.\r\n */\r\nexport const Body2D = defineComponent('Body2D', {\r\n    // Velocity\r\n    vx: 0,\r\n    vy: 0,\r\n\r\n    // Angular velocity\r\n    angularVelocity: 0,\r\n\r\n    // Force accumulator (added to velocity each frame, then cleared)\r\n    forceX: 0,\r\n    forceY: 0,\r\n\r\n    // Impulse accumulator (added to velocity once, then cleared)\r\n    impulseX: 0,\r\n    impulseY: 0,\r\n\r\n    // Size (use width/height OR radius)\r\n    width: 0,\r\n    height: 0,\r\n    radius: 0,\r\n\r\n    // Physics properties\r\n    mass: 1,\r\n    restitution: 0,    // Bounciness (0-1)\r\n    friction: 0,\r\n\r\n    // Body type: 0=dynamic, 1=static, 2=kinematic\r\n    bodyType: 0,\r\n\r\n    // Shape type: 0=rect, 1=circle\r\n    shapeType: 1,\r\n\r\n    // Is sensor (no collision response, just events)\r\n    damping: 0,\r\n    isSensor: false\r\n});\r\n\r\n/**\r\n * Player - Marks an entity as player-controlled.\r\n * This is the ownership component - attach to any entity a player controls.\r\n * clientId is stored as interned string ID (integer).\r\n */\r\nexport const Player = defineComponent('Player', {\r\n    clientId: 0    // Interned clientId string\r\n});\r\n\r\n/**\r\n * Sprite - Visual rendering component.\r\n *\r\n * Can render either:\r\n * - Simple shapes (circle, rect) with color\r\n * - Image sprites (via spriteId)\r\n */\r\nexport const Sprite = defineComponent('Sprite', {\r\n    // Shape type: 0=rect, 1=circle, 2=image\r\n    shape: 1,  // Default circle\r\n\r\n    // Size (for shapes)\r\n    width: 0,\r\n    height: 0,\r\n    radius: 10,\r\n\r\n    // Color (interned string ID, e.g., '#ff0000')\r\n    color: 0,\r\n\r\n    // Image sprite ID (interned string, for shape=SPRITE_IMAGE)\r\n    spriteId: 0,\r\n\r\n    // Render offset from transform position\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n\r\n    // Scale\r\n    scaleX: 1,\r\n    scaleY: 1,\r\n\r\n    // Layer for z-ordering (higher = in front)\r\n    layer: 0,\r\n\r\n    // Visibility\r\n    visible: true\r\n});\r\n\r\n// Sprite shape constants (reuse SHAPE_RECT, SHAPE_CIRCLE, add SPRITE_IMAGE)\r\nexport const SPRITE_IMAGE = 2;\r\n\r\n/**\r\n * Camera2D - 2D camera for viewport control.\r\n *\r\n * This is a client-only component (sync: false) - each client manages\r\n * their own camera independently. The camera is not included in:\r\n * - Network snapshots\r\n * - State hash computation\r\n * - Rollback state\r\n *\r\n * @example\r\n * // Define camera entity\r\n * game.defineEntity('camera')\r\n *     .with(Camera2D)\r\n *     .register();\r\n *\r\n * // Spawn and use camera\r\n * const cam = game.spawn('camera');\r\n * const camera = cam.get(Camera2D);\r\n * camera.x = player.x;\r\n * camera.y = player.y;\r\n * camera.zoom = 1.5;\r\n */\r\nexport const Camera2D = defineComponent('Camera2D', {\r\n    // Position (world coordinates the camera is centered on)\r\n    x: 0,\r\n    y: 0,\r\n\r\n    // Zoom level (1 = normal, >1 = zoomed in, <1 = zoomed out)\r\n    zoom: 1,\r\n\r\n    // Target zoom for smooth transitions\r\n    targetZoom: 1,\r\n\r\n    // Smoothing factor for position interpolation (0-1, higher = snappier)\r\n    smoothing: 0.1,\r\n\r\n    // Optional: follow entity ID (0 = no target)\r\n    followEntity: 0,\r\n\r\n    // Viewport bounds (set by renderer)\r\n    viewportWidth: 0,\r\n    viewportHeight: 0\r\n}, { sync: false });\r\n\r\n// Re-export types for convenience\r\nexport type Transform2DData = {\r\n    x: number;\r\n    y: number;\r\n    angle: number;\r\n};\r\n\r\nexport type Body2DData = {\r\n    vx: number;\r\n    vy: number;\r\n    angularVelocity: number;\r\n    forceX: number;\r\n    forceY: number;\r\n    impulseX: number;\r\n    impulseY: number;\r\n    width: number;\r\n    height: number;\r\n    radius: number;\r\n    mass: number;\r\n    restitution: number;\r\n    friction: number;\r\n    bodyType: number;\r\n    shapeType: number;\r\n    isSensor: boolean;\r\n};\r\n\r\nexport type PlayerType = {\r\n    clientId: number;\r\n};\r\n\r\n// Body type constants\r\nexport const BODY_DYNAMIC = 0;\r\nexport const BODY_STATIC = 1;\r\nexport const BODY_KINEMATIC = 2;\r\n\r\n// Shape type constants\r\nexport const SHAPE_RECT = 0;\r\nexport const SHAPE_CIRCLE = 1;\r\n\r\nexport type Camera2DData = {\r\n    x: number;\r\n    y: number;\r\n    zoom: number;\r\n    targetZoom: number;\r\n    smoothing: number;\r\n    followEntity: number;\r\n    viewportWidth: number;\r\n    viewportHeight: number;\r\n};\r\n", "/**\r\n * Entity Wrapper\r\n *\r\n * Provides an ergonomic API for entity access while using SoA storage internally.\r\n * Entity wrappers are pooled and reused to minimize allocations.\r\n */\r\n\r\nimport {\r\n    ComponentType,\r\n    hasComponent,\r\n    addComponentToEntity,\r\n    removeComponentFromEntity,\r\n    initializeComponentDefaults\r\n} from './component';\r\nimport { INDEX_MASK } from './constants';\r\nimport { toFixed, toFloat, fpMul, fpDiv, fpSqrt, FP_ONE } from '../math';\r\nimport { Transform2D, Body2D } from '../components';\r\n\r\n/**\r\n * Render-only state (client-only, never serialized).\r\n */\r\nexport interface RenderState {\r\n    /** Previous tick X position (for interpolation) */\r\n    prevX: number;\r\n    /** Previous tick Y position */\r\n    prevY: number;\r\n    /** Interpolated X (computed each render) */\r\n    interpX: number;\r\n    /** Interpolated Y */\r\n    interpY: number;\r\n    /** Screen X after camera transform */\r\n    screenX: number;\r\n    /** Screen Y after camera transform */\r\n    screenY: number;\r\n    /** Whether entity is visible */\r\n    visible: boolean;\r\n    /** Custom render properties */\r\n    [key: string]: any;\r\n}\r\n\r\n/**\r\n * Restore callback type - called after snapshot load to reconstruct derived fields.\r\n */\r\nexport type EntityRestoreCallback = (entity: Entity, game: any) => void;\r\n\r\n/**\r\n * Entity definition for spawning.\r\n */\r\nexport interface EntityDefinition {\r\n    name: string;\r\n    components: Array<{\r\n        type: ComponentType;\r\n        defaults?: Record<string, any>;\r\n    }>;\r\n    /** Optional: fields to sync in snapshots. If not set, all fields are synced. */\r\n    syncFields?: string[];\r\n    /** Optional: callback to reconstruct non-synced fields after snapshot load. */\r\n    onRestore?: EntityRestoreCallback;\r\n}\r\n\r\n/**\r\n * Entity wrapper - provides ergonomic access to SoA-stored entity data.\r\n */\r\nexport class Entity {\r\n    /** Entity ID (includes generation) */\r\n    eid: number = -1;\r\n\r\n    /** Entity type name */\r\n    type: string = '';\r\n\r\n    /** Whether entity is destroyed */\r\n    destroyed: boolean = false;\r\n\r\n    /** Render-only state (client-only, never serialized) */\r\n    render: RenderState = {\r\n        prevX: 0,\r\n        prevY: 0,\r\n        interpX: 0,\r\n        interpY: 0,\r\n        screenX: 0,\r\n        screenY: 0,\r\n        visible: true\r\n    };\r\n\r\n    /** Component types this entity has */\r\n    private _components: ComponentType[] = [];\r\n\r\n    /** Cached accessor instances */\r\n    private _accessors: Map<ComponentType, any> = new Map();\r\n\r\n    /** Reference to world for operations */\r\n    private _world: EntityWorld | null = null;\r\n\r\n    /** Current frame's input data (set during tick) */\r\n    private _inputData: Record<string, any> | null = null;\r\n\r\n    /**\r\n     * Get component accessor.\r\n     * Returns typed accessor for reading/writing component data.\r\n     */\r\n    get<T extends Record<string, any>>(component: ComponentType<T>): T {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        // Check if entity has this component\r\n        if (!hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} (type: ${this.type}) does not have component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Get or create accessor\r\n        let accessor = this._accessors.get(component);\r\n        if (!accessor) {\r\n            accessor = new component.AccessorClass(index);\r\n            this._accessors.set(component, accessor);\r\n        } else {\r\n            // Update index in case wrapper was reused\r\n            accessor._index = index;\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Check if entity has a component.\r\n     */\r\n    has(component: ComponentType): boolean {\r\n        return hasComponent(component.storage, this.eid & INDEX_MASK);\r\n    }\r\n\r\n    /**\r\n     * Add a component to this entity at runtime.\r\n     */\r\n    addComponent<T extends Record<string, any>>(component: ComponentType<T>, data?: Partial<T>): T {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        if (hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} already has component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Add to storage\r\n        addComponentToEntity(component.storage, index);\r\n        initializeComponentDefaults(component.storage, index);\r\n\r\n        // Track component\r\n        this._components.push(component);\r\n\r\n        // Update query indices\r\n        if (this._world) {\r\n            this._world.queryEngine.addComponent(this.eid, component);\r\n        }\r\n\r\n        // Get accessor and apply data\r\n        const accessor = this.get(component);\r\n        if (data) {\r\n            for (const [key, value] of Object.entries(data)) {\r\n                (accessor as any)[key] = value;\r\n            }\r\n        }\r\n\r\n        return accessor;\r\n    }\r\n\r\n    /**\r\n     * Remove a component from this entity at runtime.\r\n     */\r\n    removeComponent(component: ComponentType): void {\r\n        const index = this.eid & INDEX_MASK;\r\n\r\n        if (!hasComponent(component.storage, index)) {\r\n            throw new Error(\r\n                `Entity ${this.eid} does not have component '${component.name}'`\r\n            );\r\n        }\r\n\r\n        // Remove from storage\r\n        removeComponentFromEntity(component.storage, index);\r\n\r\n        // Remove from tracking\r\n        const idx = this._components.indexOf(component);\r\n        if (idx !== -1) {\r\n            this._components.splice(idx, 1);\r\n        }\r\n\r\n        // Update query indices\r\n        if (this._world) {\r\n            this._world.queryEngine.removeComponent(this.eid, component);\r\n        }\r\n\r\n        // Clear cached accessor\r\n        this._accessors.delete(component);\r\n    }\r\n\r\n    /**\r\n     * Destroy this entity.\r\n     */\r\n    destroy(): void {\r\n        if (this.destroyed) return;\r\n        this.destroyed = true;\r\n\r\n        if (this._world) {\r\n            this._world.destroyEntity(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all components on this entity.\r\n     */\r\n    getComponents(): ComponentType[] {\r\n        return [...this._components];\r\n    }\r\n\r\n    /**\r\n     * Get current frame's input data.\r\n     * Returns null if no input was received this tick.\r\n     */\r\n    get input(): Record<string, any> | null {\r\n        return this._inputData;\r\n    }\r\n\r\n    /**\r\n     * Set input data for this tick (called by World).\r\n     */\r\n    _setInputData(data: Record<string, any> | null): void {\r\n        this._inputData = data;\r\n    }\r\n\r\n    /**\r\n     * Save current position to render.prev* for interpolation.\r\n     * Should be called in prePhysics phase before physics updates position.\r\n     */\r\n    _savePreviousState(): void {\r\n        // Look for common position components (Body2D, Transform, etc.)\r\n        // Store current position as previous for interpolation\r\n        for (const component of this._components) {\r\n            const index = this.eid & INDEX_MASK;\r\n\r\n            // Check for x/y fields in component\r\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\r\n                const xArr = component.storage.fields['x'];\r\n                const yArr = component.storage.fields['y'];\r\n\r\n                // Convert from fixed-point to float for render state\r\n                this.render.prevX = toFloat(xArr[index]);\r\n                this.render.prevY = toFloat(yArr[index]);\r\n                return; // Found position component, done\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate interpolated position for rendering.\r\n     * @param alpha Interpolation factor (0-1) between previous and current state\r\n     */\r\n    interpolate(alpha: number): void {\r\n        // Get current position\r\n        for (const component of this._components) {\r\n            const index = this.eid & INDEX_MASK;\r\n\r\n            if ('x' in component.storage.fields && 'y' in component.storage.fields) {\r\n                const currentX = toFloat(component.storage.fields['x'][index]);\r\n                const currentY = toFloat(component.storage.fields['y'][index]);\r\n\r\n                // Linear interpolation between previous and current\r\n                this.render.interpX = this.render.prevX + (currentX - this.render.prevX) * alpha;\r\n                this.render.interpY = this.render.prevY + (currentY - this.render.prevY) * alpha;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize entity (called by world).\r\n     */\r\n    _init(\r\n        eid: number,\r\n        type: string,\r\n        components: ComponentType[],\r\n        world: EntityWorld\r\n    ): void {\r\n        this.eid = eid;\r\n        this.type = type;\r\n        this.destroyed = false;\r\n        this._components = components;\r\n        this._world = world;\r\n        this._accessors.clear();\r\n\r\n        // Reset render state\r\n        this.render.prevX = 0;\r\n        this.render.prevY = 0;\r\n        this.render.interpX = 0;\r\n        this.render.interpY = 0;\r\n        this.render.screenX = 0;\r\n        this.render.screenY = 0;\r\n        this.render.visible = true;\r\n\r\n        // Clear input data\r\n        this._inputData = null;\r\n    }\r\n\r\n    /**\r\n     * Clean up entity (called when returned to pool).\r\n     */\r\n    _cleanup(): void {\r\n        this._world = null;\r\n        this._components = [];\r\n        this._accessors.clear();\r\n        this._inputData = null;\r\n    }\r\n\r\n    // ==========================================\r\n    // Movement Helpers (Deterministic)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Set velocity toward a target point.\r\n     * Uses fixed-point math internally for determinism.\r\n     *\r\n     * @param target Target position {x, y}\r\n     * @param speed Speed in units per second\r\n     */\r\n    moveTowards(target: { x: number; y: number }, speed: number): void {\r\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const body = this.get(Body2D);\r\n\r\n        // All math in fixed-point for determinism\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n\r\n        // Distance squared (avoid sqrt if possible)\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        if (distSq === 0) {\r\n            body.vx = 0;\r\n            body.vy = 0;\r\n            return;\r\n        }\r\n\r\n        // Distance\r\n        const dist = fpSqrt(distSq);\r\n\r\n        // Normalize and scale by speed (speed is in units/sec, physics expects units/sec)\r\n        const speedFp = toFixed(speed * 60); // Convert to units per tick at 60fps base\r\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\r\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\r\n    }\r\n\r\n    /**\r\n     * Set velocity toward a target, but stop if within radius.\r\n     *\r\n     * @param target Target position {x, y}\r\n     * @param speed Speed in units per second\r\n     * @param stopRadius Stop moving when within this distance (default: 0)\r\n     */\r\n    moveTowardsWithStop(target: { x: number; y: number }, speed: number, stopRadius: number = 0): void {\r\n        if (!this.has(Transform2D) || !this.has(Body2D)) return;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const body = this.get(Body2D);\r\n\r\n        // All math in fixed-point for determinism\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        const stopRadiusFp = toFixed(stopRadius);\r\n        const stopRadiusSq = fpMul(stopRadiusFp, stopRadiusFp);\r\n\r\n        // Stop if within radius\r\n        if (distSq <= stopRadiusSq) {\r\n            body.vx = 0;\r\n            body.vy = 0;\r\n            return;\r\n        }\r\n\r\n        const dist = fpSqrt(distSq);\r\n        const speedFp = toFixed(speed * 60);\r\n        body.vx = toFloat(fpDiv(fpMul(dx, speedFp), dist));\r\n        body.vy = toFloat(fpDiv(fpMul(dy, speedFp), dist));\r\n    }\r\n\r\n    /**\r\n     * Stop all movement.\r\n     */\r\n    stop(): void {\r\n        if (!this.has(Body2D)) return;\r\n        const body = this.get(Body2D);\r\n        body.vx = 0;\r\n        body.vy = 0;\r\n    }\r\n\r\n    /**\r\n     * Set velocity directly.\r\n     *\r\n     * @param vx X velocity\r\n     * @param vy Y velocity\r\n     */\r\n    setVelocity(vx: number, vy: number): void {\r\n        if (!this.has(Body2D)) return;\r\n        const body = this.get(Body2D);\r\n        body.vx = vx;\r\n        body.vy = vy;\r\n    }\r\n\r\n    /**\r\n     * Get distance to a point (deterministic).\r\n     */\r\n    distanceTo(target: { x: number; y: number }): number {\r\n        if (!this.has(Transform2D)) return 0;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n\r\n        return toFloat(fpSqrt(distSq));\r\n    }\r\n\r\n    /**\r\n     * Check if within distance of a point (deterministic).\r\n     */\r\n    isWithin(target: { x: number; y: number }, distance: number): boolean {\r\n        if (!this.has(Transform2D)) return false;\r\n\r\n        const transform = this.get(Transform2D);\r\n        const dx = toFixed(target.x) - toFixed(transform.x);\r\n        const dy = toFixed(target.y) - toFixed(transform.y);\r\n        const distSq = fpMul(dx, dx) + fpMul(dy, dy);\r\n        const distFp = toFixed(distance);\r\n        const distSqThreshold = fpMul(distFp, distFp);\r\n\r\n        return distSq <= distSqThreshold;\r\n    }\r\n}\r\n\r\n/**\r\n * Forward declaration for EntityWorld (actual implementation in world.ts).\r\n */\r\nexport interface EntityWorld {\r\n    queryEngine: {\r\n        addComponent(eid: number, component: ComponentType): void;\r\n        removeComponent(eid: number, component: ComponentType): void;\r\n    };\r\n    destroyEntity(entity: Entity): void;\r\n}\r\n\r\n/**\r\n * Entity pool for reusing entity wrappers.\r\n */\r\nexport class EntityPool {\r\n    private pool: Entity[] = [];\r\n    private active: Map<number, Entity> = new Map();\r\n\r\n    /**\r\n     * Get or create an entity wrapper.\r\n     */\r\n    acquire(eid: number): Entity {\r\n        // Check if already have wrapper for this eid\r\n        let entity = this.active.get(eid);\r\n        if (entity) {\r\n            return entity;\r\n        }\r\n\r\n        // Get from pool or create new\r\n        entity = this.pool.pop() || new Entity();\r\n        this.active.set(eid, entity);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Return entity wrapper to pool.\r\n     */\r\n    release(eid: number): void {\r\n        const entity = this.active.get(eid);\r\n        if (entity) {\r\n            entity._cleanup();\r\n            this.active.delete(eid);\r\n            this.pool.push(entity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get entity by eid if it exists.\r\n     */\r\n    get(eid: number): Entity | undefined {\r\n        return this.active.get(eid);\r\n    }\r\n\r\n    /**\r\n     * Check if entity exists.\r\n     */\r\n    has(eid: number): boolean {\r\n        return this.active.has(eid);\r\n    }\r\n\r\n    /**\r\n     * Clear all entities.\r\n     */\r\n    clear(): void {\r\n        for (const entity of this.active.values()) {\r\n            entity._cleanup();\r\n            this.pool.push(entity);\r\n        }\r\n        this.active.clear();\r\n    }\r\n\r\n    /**\r\n     * Get count of active entities.\r\n     */\r\n    get size(): number {\r\n        return this.active.size;\r\n    }\r\n}\r\n", "/**\r\n * Query Engine\r\n *\r\n * Efficient entity queries with caching and iterator support.\r\n * Queries return iterators with snapshot semantics for safe mutation.\r\n */\r\n\r\nimport { ComponentType, hasComponent } from './component';\r\nimport { INDEX_MASK } from './constants';\r\n\r\n/**\r\n * Entity-like interface for query results.\r\n * Actual Entity class will implement this.\r\n */\r\nexport interface QueryableEntity {\r\n    readonly eid: number;\r\n    readonly type: string;\r\n    readonly destroyed: boolean;\r\n}\r\n\r\n/**\r\n * Function to get entity wrapper by eid.\r\n */\r\nexport type EntityGetter = (eid: number) => QueryableEntity | null;\r\n\r\n/**\r\n * Function to check if entity is destroyed.\r\n */\r\nexport type DestroyedChecker = (eid: number) => boolean;\r\n\r\n/**\r\n * Query iterator with snapshot semantics.\r\n * Captures eid list at creation time for safe iteration during mutation.\r\n */\r\nexport class QueryIterator<T extends QueryableEntity> implements Iterable<T> {\r\n    private eids: number[];\r\n    private index: number = 0;\r\n    private getEntity: EntityGetter;\r\n    private isDestroyed: DestroyedChecker;\r\n\r\n    constructor(\r\n        matchingEids: number[],\r\n        getEntity: EntityGetter,\r\n        isDestroyed: DestroyedChecker\r\n    ) {\r\n        // Copy eids at creation time - safe from mutation\r\n        this.eids = matchingEids.slice();\r\n        this.getEntity = getEntity;\r\n        this.isDestroyed = isDestroyed;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<T> {\r\n        this.index = 0;\r\n        return {\r\n            next: (): IteratorResult<T> => {\r\n                while (this.index < this.eids.length) {\r\n                    const eid = this.eids[this.index++];\r\n\r\n                    // Skip destroyed entities\r\n                    if (this.isDestroyed(eid)) continue;\r\n\r\n                    const entity = this.getEntity(eid);\r\n                    if (entity) {\r\n                        return { done: false, value: entity as T };\r\n                    }\r\n                }\r\n                return { done: true, value: undefined as any };\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert to array (allocates).\r\n     */\r\n    toArray(): T[] {\r\n        const result: T[] = [];\r\n        for (const entity of this) {\r\n            result.push(entity);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get first matching entity.\r\n     */\r\n    first(): T | null {\r\n        for (const entity of this) {\r\n            return entity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find entity matching predicate.\r\n     */\r\n    find(predicate: (entity: T) => boolean): T | null {\r\n        for (const entity of this) {\r\n            if (predicate(entity)) {\r\n                return entity;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Count entities without allocating array.\r\n     */\r\n    count(): number {\r\n        let count = 0;\r\n        for (const _ of this) {\r\n            count++;\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\n/**\r\n * Query engine - manages entity indices and cached queries.\r\n */\r\nexport class QueryEngine {\r\n    /** Type index: entity type -> set of eids */\r\n    private typeIndex: Map<string, Set<number>> = new Map();\r\n\r\n    /** Component index: component -> set of eids */\r\n    private componentIndex: Map<ComponentType, Set<number>> = new Map();\r\n\r\n    /** Client ID index: clientId -> eid (O(1) lookup) */\r\n    private clientIdIndex: Map<number, number> = new Map();\r\n\r\n    /** Entity getter function */\r\n    private getEntity: EntityGetter;\r\n\r\n    /** Destroyed checker function */\r\n    private isDestroyed: DestroyedChecker;\r\n\r\n    constructor(getEntity: EntityGetter, isDestroyed: DestroyedChecker) {\r\n        this.getEntity = getEntity;\r\n        this.isDestroyed = isDestroyed;\r\n    }\r\n\r\n    /**\r\n     * Register an entity in the indices.\r\n     */\r\n    addEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\r\n        // Add to type index\r\n        let typeSet = this.typeIndex.get(type);\r\n        if (!typeSet) {\r\n            typeSet = new Set();\r\n            this.typeIndex.set(type, typeSet);\r\n        }\r\n        typeSet.add(eid);\r\n\r\n        // Add to component indices\r\n        for (const component of components) {\r\n            let compSet = this.componentIndex.get(component);\r\n            if (!compSet) {\r\n                compSet = new Set();\r\n                this.componentIndex.set(component, compSet);\r\n            }\r\n            compSet.add(eid);\r\n        }\r\n\r\n        // Add to clientId index if provided\r\n        if (clientId !== undefined) {\r\n            this.clientIdIndex.set(clientId, eid);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an entity from all indices.\r\n     */\r\n    removeEntity(eid: number, type: string, components: ComponentType[], clientId?: number): void {\r\n        // Remove from type index\r\n        this.typeIndex.get(type)?.delete(eid);\r\n\r\n        // Remove from component indices\r\n        for (const component of components) {\r\n            this.componentIndex.get(component)?.delete(eid);\r\n        }\r\n\r\n        // Remove from clientId index\r\n        if (clientId !== undefined) {\r\n            this.clientIdIndex.delete(clientId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add component to an existing entity.\r\n     */\r\n    addComponent(eid: number, component: ComponentType): void {\r\n        let compSet = this.componentIndex.get(component);\r\n        if (!compSet) {\r\n            compSet = new Set();\r\n            this.componentIndex.set(component, compSet);\r\n        }\r\n        compSet.add(eid);\r\n    }\r\n\r\n    /**\r\n     * Remove component from an existing entity.\r\n     */\r\n    removeComponent(eid: number, component: ComponentType): void {\r\n        this.componentIndex.get(component)?.delete(eid);\r\n    }\r\n\r\n    /**\r\n     * Update clientId mapping for an entity.\r\n     */\r\n    setClientId(eid: number, clientId: number): void {\r\n        this.clientIdIndex.set(clientId, eid);\r\n    }\r\n\r\n    /**\r\n     * Remove clientId mapping.\r\n     */\r\n    removeClientId(clientId: number): void {\r\n        this.clientIdIndex.delete(clientId);\r\n    }\r\n\r\n    /**\r\n     * Query by entity type.\r\n     */\r\n    byType<T extends QueryableEntity>(type: string): QueryIterator<T> {\r\n        const typeSet = this.typeIndex.get(type);\r\n        const eids = typeSet ? this.sortedEids(typeSet) : [];\r\n        return new QueryIterator<T>(eids, this.getEntity, this.isDestroyed);\r\n    }\r\n\r\n    /**\r\n     * Query by component(s) - entities must have ALL specified components.\r\n     */\r\n    byComponents<T extends QueryableEntity>(...components: ComponentType[]): QueryIterator<T> {\r\n        if (components.length === 0) {\r\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n        }\r\n\r\n        // Start with the smallest set for efficiency\r\n        let smallestSet: Set<number> | undefined;\r\n        let smallestSize = Infinity;\r\n\r\n        for (const component of components) {\r\n            const compSet = this.componentIndex.get(component);\r\n            if (!compSet || compSet.size === 0) {\r\n                // One component has no entities, result is empty\r\n                return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n            }\r\n            if (compSet.size < smallestSize) {\r\n                smallestSize = compSet.size;\r\n                smallestSet = compSet;\r\n            }\r\n        }\r\n\r\n        if (!smallestSet) {\r\n            return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n        }\r\n\r\n        // Filter to entities that have ALL components\r\n        const result: number[] = [];\r\n        for (const eid of smallestSet) {\r\n            let hasAll = true;\r\n            for (const component of components) {\r\n                if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\r\n                    hasAll = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (hasAll) {\r\n                result.push(eid);\r\n            }\r\n        }\r\n\r\n        // Sort by eid for deterministic order\r\n        result.sort((a, b) => a - b);\r\n\r\n        return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\r\n    }\r\n\r\n    /**\r\n     * Query by type or component.\r\n     */\r\n    query<T extends QueryableEntity>(\r\n        typeOrComponent: string | ComponentType,\r\n        ...moreComponents: ComponentType[]\r\n    ): QueryIterator<T> {\r\n        if (typeof typeOrComponent === 'string') {\r\n            // Query by type\r\n            if (moreComponents.length > 0) {\r\n                // Type + components: filter type results by components\r\n                const typeSet = this.typeIndex.get(typeOrComponent);\r\n                if (!typeSet || typeSet.size === 0) {\r\n                    return new QueryIterator<T>([], this.getEntity, this.isDestroyed);\r\n                }\r\n\r\n                const result: number[] = [];\r\n                for (const eid of typeSet) {\r\n                    let hasAll = true;\r\n                    for (const component of moreComponents) {\r\n                        if (component.storage && !hasComponent(component.storage, eid & INDEX_MASK)) {\r\n                            hasAll = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (hasAll) {\r\n                        result.push(eid);\r\n                    }\r\n                }\r\n\r\n                result.sort((a, b) => a - b);\r\n                return new QueryIterator<T>(result, this.getEntity, this.isDestroyed);\r\n            }\r\n\r\n            return this.byType<T>(typeOrComponent);\r\n        }\r\n\r\n        // Query by component(s)\r\n        return this.byComponents<T>(typeOrComponent, ...moreComponents);\r\n    }\r\n\r\n    /**\r\n     * O(1) lookup by clientId.\r\n     */\r\n    getByClientId(clientId: number): number | undefined {\r\n        return this.clientIdIndex.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Get all entity IDs (sorted for determinism).\r\n     */\r\n    getAllEids(): number[] {\r\n        const allEids = new Set<number>();\r\n\r\n        for (const typeSet of this.typeIndex.values()) {\r\n            for (const eid of typeSet) {\r\n                allEids.add(eid);\r\n            }\r\n        }\r\n\r\n        return Array.from(allEids).sort((a, b) => a - b);\r\n    }\r\n\r\n    /**\r\n     * Clear all indices (for reset).\r\n     */\r\n    clear(): void {\r\n        this.typeIndex.clear();\r\n        this.componentIndex.clear();\r\n        this.clientIdIndex.clear();\r\n    }\r\n\r\n    /**\r\n     * Get sorted eids from a set (for deterministic iteration).\r\n     */\r\n    private sortedEids(set: Set<number>): number[] {\r\n        return Array.from(set).sort((a, b) => a - b);\r\n    }\r\n}\r\n", "/**\r\n * System Scheduler\r\n *\r\n * Manages system registration and execution in ordered phases.\r\n * Systems are functions that operate on entities with specific components.\r\n */\r\n\r\nimport { SystemPhase, SYSTEM_PHASES } from './constants';\r\n\r\nexport interface SystemOptions {\r\n    /** Execution phase (default: 'update') */\r\n    phase?: SystemPhase;\r\n\r\n    /** Only run on client (e.g., rendering) */\r\n    client?: boolean;\r\n\r\n    /** Only run on server */\r\n    server?: boolean;\r\n\r\n    /** Execution order within phase (lower = earlier) */\r\n    order?: number;\r\n}\r\n\r\nexport type SystemFn = () => void;\r\n\r\ninterface SystemEntry {\r\n    fn: SystemFn;\r\n    options: SystemOptions;\r\n    order: number;\r\n}\r\n\r\n/**\r\n * System scheduler - manages system registration and execution.\r\n */\r\nexport class SystemScheduler {\r\n    /** Systems organized by phase */\r\n    private systems: Map<SystemPhase, SystemEntry[]> = new Map();\r\n\r\n    /** Whether we're running on client or server */\r\n    private isClient: boolean = true;\r\n\r\n    /** System ID counter for ordering */\r\n    private nextSystemId: number = 0;\r\n\r\n    constructor() {\r\n        // Initialize all phases\r\n        for (const phase of SYSTEM_PHASES) {\r\n            this.systems.set(phase, []);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set whether this scheduler is running on client or server.\r\n     */\r\n    setIsClient(isClient: boolean): void {\r\n        this.isClient = isClient;\r\n    }\r\n\r\n    /**\r\n     * Add a system to the scheduler.\r\n     *\r\n     * @param fn System function to execute\r\n     * @param options System options (phase, client/server, order)\r\n     * @returns Function to remove the system\r\n     */\r\n    add(fn: SystemFn, options: SystemOptions = {}): () => void {\r\n        const phase = options.phase || 'update';\r\n        const systems = this.systems.get(phase);\r\n\r\n        if (!systems) {\r\n            throw new Error(`Unknown system phase: ${phase}`);\r\n        }\r\n\r\n        const entry: SystemEntry = {\r\n            fn,\r\n            options,\r\n            order: options.order ?? this.nextSystemId++\r\n        };\r\n\r\n        systems.push(entry);\r\n\r\n        // Sort by order\r\n        systems.sort((a, b) => a.order - b.order);\r\n\r\n        // Return removal function\r\n        return () => this.remove(fn);\r\n    }\r\n\r\n    /**\r\n     * Remove a system from the scheduler.\r\n     */\r\n    remove(fn: SystemFn): boolean {\r\n        for (const systems of this.systems.values()) {\r\n            const index = systems.findIndex(s => s.fn === fn);\r\n            if (index !== -1) {\r\n                systems.splice(index, 1);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Run all systems in a specific phase.\r\n     */\r\n    runPhase(phase: SystemPhase): void {\r\n        const systems = this.systems.get(phase);\r\n        if (!systems) return;\r\n\r\n        for (const system of systems) {\r\n            // Skip client-only systems on server\r\n            if (system.options.client && !this.isClient) continue;\r\n\r\n            // Skip server-only systems on client\r\n            if (system.options.server && this.isClient) continue;\r\n\r\n            // Execute system\r\n            try {\r\n                const result = system.fn() as unknown;\r\n\r\n                // Check for accidental async systems\r\n                if (result && typeof result === 'object' && 'then' in result) {\r\n                    throw new Error(\r\n                        `System returned a Promise. Async systems are not allowed ` +\r\n                        `as they break determinism. Remove 'await' from your system.`\r\n                    );\r\n                }\r\n            } catch (error) {\r\n                console.error(`Error in system during '${phase}' phase:`, error);\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run all phases in order (except render if not client).\r\n     */\r\n    runAll(): void {\r\n        for (const phase of SYSTEM_PHASES) {\r\n            // Skip render phase on server\r\n            if (phase === 'render' && !this.isClient) continue;\r\n\r\n            this.runPhase(phase);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get count of systems in each phase (for debugging).\r\n     */\r\n    getSystemCounts(): Record<SystemPhase, number> {\r\n        const counts: Partial<Record<SystemPhase, number>> = {};\r\n        for (const [phase, systems] of this.systems) {\r\n            counts[phase] = systems.length;\r\n        }\r\n        return counts as Record<SystemPhase, number>;\r\n    }\r\n\r\n    /**\r\n     * Clear all systems (for testing).\r\n     */\r\n    clear(): void {\r\n        for (const systems of this.systems.values()) {\r\n            systems.length = 0;\r\n        }\r\n        this.nextSystemId = 0;\r\n    }\r\n}\r\n", "/**\r\n * Sparse Snapshot System\r\n *\r\n * Efficient snapshot encoding using entity bitmaps.\r\n * Only active entities are stored, not MAX_ENTITIES slots.\r\n */\r\n\r\nimport { MAX_ENTITIES, INDEX_MASK } from './constants';\r\nimport { ComponentType, getAllComponents } from './component';\r\nimport { EntityIdAllocatorState } from './entity-id';\r\n\r\n/**\r\n * Sparse snapshot format.\r\n * Much smaller than full snapshot when entity count << MAX_ENTITIES.\r\n */\r\nexport interface SparseSnapshot {\r\n    /** Frame number */\r\n    frame: number;\r\n\r\n    /** Sequence number (for network ordering) */\r\n    seq: number;\r\n\r\n    /** Bitmap: which entity indices are active */\r\n    entityMask: Uint32Array;\r\n\r\n    /** Entity metadata (type, clientId) indexed by position in packed arrays */\r\n    entityMeta: EntityMeta[];\r\n\r\n    /** Packed component data for each component type */\r\n    componentData: Map<string, ArrayBuffer>;\r\n\r\n    /** Entity count (for quick reference) */\r\n    entityCount: number;\r\n\r\n    /** Allocator state for deterministic ID recycling */\r\n    allocator: EntityIdAllocatorState;\r\n\r\n    /** String registry for late joiners */\r\n    strings: {\r\n        tables: Record<string, Record<string, number>>;\r\n        nextIds: Record<string, number>;\r\n    };\r\n\r\n    /** RNG state */\r\n    rng?: { s0: number; s1: number };\r\n}\r\n\r\n/**\r\n * Entity metadata stored per-entity in snapshot.\r\n */\r\nexport interface EntityMeta {\r\n    eid: number;\r\n    type: string;\r\n    clientId?: number;\r\n}\r\n\r\n/**\r\n * Sparse snapshot encoder/decoder.\r\n */\r\nexport class SparseSnapshotCodec {\r\n    /**\r\n     * Encode world state to sparse snapshot.\r\n     */\r\n    encode(\r\n        activeEids: number[],\r\n        getEntityType: (eid: number) => string,\r\n        getEntityClientId: (eid: number) => number | undefined,\r\n        getComponentsForEntity: (eid: number) => ComponentType[],\r\n        allocatorState: EntityIdAllocatorState,\r\n        stringsState: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> },\r\n        frame: number = 0,\r\n        seq: number = 0,\r\n        rng?: { s0: number; s1: number }\r\n    ): SparseSnapshot {\r\n        // Build entity bitmap\r\n        const entityMask = new Uint32Array(Math.ceil(MAX_ENTITIES / 32));\r\n        const entityMeta: EntityMeta[] = [];\r\n\r\n        // Sort eids for deterministic order\r\n        const sortedEids = [...activeEids].sort((a, b) => a - b);\r\n\r\n        for (const eid of sortedEids) {\r\n            const index = eid & INDEX_MASK;\r\n            entityMask[index >>> 5] |= (1 << (index & 31));\r\n\r\n            entityMeta.push({\r\n                eid,\r\n                type: getEntityType(eid),\r\n                clientId: getEntityClientId(eid)\r\n            });\r\n        }\r\n\r\n        // Pack component data\r\n        const componentData = new Map<string, ArrayBuffer>();\r\n        const allComponents = getAllComponents();\r\n\r\n        for (const [name, component] of allComponents) {\r\n            // Skip components that are not synced (client-only state)\r\n            if (!component.sync) continue;\r\n\r\n            const fieldCount = component.fieldNames.length;\r\n            if (fieldCount === 0) continue;\r\n\r\n            // Calculate buffer size\r\n            let totalSize = 0;\r\n            for (const fieldName of component.fieldNames) {\r\n                const arr = component.storage.fields[fieldName];\r\n                totalSize += sortedEids.length * arr.BYTES_PER_ELEMENT;\r\n            }\r\n\r\n            const buffer = new ArrayBuffer(totalSize);\r\n            let offset = 0;\r\n\r\n            // Pack each field's data for active entities only\r\n            for (const fieldName of component.fieldNames) {\r\n                const sourceArr = component.storage.fields[fieldName];\r\n                const bytesPerElement = sourceArr.BYTES_PER_ELEMENT;\r\n\r\n                // Create view into packed buffer\r\n                const packedArr = new (sourceArr.constructor as any)(\r\n                    buffer,\r\n                    offset,\r\n                    sortedEids.length\r\n                );\r\n\r\n                // Copy only active entity data\r\n                for (let i = 0; i < sortedEids.length; i++) {\r\n                    const index = sortedEids[i] & INDEX_MASK;\r\n                    packedArr[i] = sourceArr[index];\r\n                }\r\n\r\n                offset += sortedEids.length * bytesPerElement;\r\n            }\r\n\r\n            componentData.set(name, buffer);\r\n        }\r\n\r\n        return {\r\n            frame,\r\n            seq,\r\n            entityMask,\r\n            entityMeta,\r\n            componentData,\r\n            entityCount: sortedEids.length,\r\n            allocator: allocatorState,\r\n            strings: stringsState,\r\n            rng\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decode sparse snapshot back to world state.\r\n     */\r\n    decode(\r\n        snapshot: SparseSnapshot,\r\n        clearWorld: () => void,\r\n        setAllocatorState: (state: EntityIdAllocatorState) => void,\r\n        setStringsState: (state: { tables: Record<string, Record<string, number>>; nextIds: Record<string, number> }) => void,\r\n        createEntity: (eid: number, type: string, clientId?: number) => void,\r\n        setRng?: (rng: { s0: number; s1: number }) => void\r\n    ): void {\r\n        // Clear existing state\r\n        clearWorld();\r\n\r\n        // Restore allocator state\r\n        setAllocatorState(snapshot.allocator);\r\n\r\n        // Restore strings\r\n        setStringsState(snapshot.strings);\r\n\r\n        // Restore RNG if provided\r\n        if (snapshot.rng && setRng) {\r\n            setRng(snapshot.rng);\r\n        }\r\n\r\n        // Get component types\r\n        const allComponents = getAllComponents();\r\n\r\n        // Unpack entities from metadata\r\n        for (let i = 0; i < snapshot.entityMeta.length; i++) {\r\n            const meta = snapshot.entityMeta[i];\r\n            createEntity(meta.eid, meta.type, meta.clientId);\r\n        }\r\n\r\n        // Unpack component data\r\n        for (const [name, buffer] of snapshot.componentData) {\r\n            const component = allComponents.get(name);\r\n            if (!component) continue;\r\n\r\n            let offset = 0;\r\n\r\n            for (const fieldName of component.fieldNames) {\r\n                const targetArr = component.storage.fields[fieldName];\r\n                const bytesPerElement = targetArr.BYTES_PER_ELEMENT;\r\n\r\n                // Create view into packed buffer\r\n                const packedArr = new (targetArr.constructor as any)(\r\n                    buffer,\r\n                    offset,\r\n                    snapshot.entityCount\r\n                );\r\n\r\n                // Unpack to entity indices\r\n                for (let i = 0; i < snapshot.entityMeta.length; i++) {\r\n                    const index = snapshot.entityMeta[i].eid & INDEX_MASK;\r\n                    targetArr[index] = packedArr[i];\r\n                }\r\n\r\n                offset += snapshot.entityCount * bytesPerElement;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate snapshot size in bytes.\r\n     */\r\n    getSize(snapshot: SparseSnapshot): number {\r\n        let size = 0;\r\n\r\n        // Entity mask\r\n        size += snapshot.entityMask.byteLength;\r\n\r\n        // Entity metadata (rough estimate)\r\n        size += snapshot.entityMeta.length * 32; // ~32 bytes per entity meta\r\n\r\n        // Component data\r\n        for (const buffer of snapshot.componentData.values()) {\r\n            size += buffer.byteLength;\r\n        }\r\n\r\n        // Allocator state\r\n        size += snapshot.allocator.freeList.length * 4;\r\n        size += snapshot.allocator.generations.length * 2;\r\n\r\n        return size;\r\n    }\r\n\r\n    /**\r\n     * Serialize snapshot to binary for network transfer.\r\n     */\r\n    toBinary(snapshot: SparseSnapshot): ArrayBuffer {\r\n        // Calculate total size\r\n        const metaJson = JSON.stringify({\r\n            frame: snapshot.frame,\r\n            seq: snapshot.seq,\r\n            entityMeta: snapshot.entityMeta,\r\n            allocator: snapshot.allocator,\r\n            strings: snapshot.strings,\r\n            rng: snapshot.rng,\r\n            componentNames: Array.from(snapshot.componentData.keys())\r\n        });\r\n\r\n        const metaBytes = new TextEncoder().encode(metaJson);\r\n        const metaLength = metaBytes.length;\r\n\r\n        // Calculate component data size\r\n        let componentDataSize = 0;\r\n        const componentSizes: number[] = [];\r\n        for (const buffer of snapshot.componentData.values()) {\r\n            componentSizes.push(buffer.byteLength);\r\n            componentDataSize += buffer.byteLength;\r\n        }\r\n\r\n        // Total: 4 (meta length) + meta + 4 (mask length) + mask + component data\r\n        const totalSize = 4 + metaLength + 4 + snapshot.entityMask.byteLength + componentDataSize;\r\n\r\n        const buffer = new ArrayBuffer(totalSize);\r\n        const view = new DataView(buffer);\r\n        let offset = 0;\r\n\r\n        // Write meta length and data\r\n        view.setUint32(offset, metaLength, true);\r\n        offset += 4;\r\n        new Uint8Array(buffer, offset, metaLength).set(metaBytes);\r\n        offset += metaLength;\r\n\r\n        // Write entity mask\r\n        view.setUint32(offset, snapshot.entityMask.byteLength, true);\r\n        offset += 4;\r\n        new Uint8Array(buffer, offset, snapshot.entityMask.byteLength).set(\r\n            new Uint8Array(snapshot.entityMask.buffer)\r\n        );\r\n        offset += snapshot.entityMask.byteLength;\r\n\r\n        // Write component data\r\n        for (const compBuffer of snapshot.componentData.values()) {\r\n            new Uint8Array(buffer, offset, compBuffer.byteLength).set(\r\n                new Uint8Array(compBuffer)\r\n            );\r\n            offset += compBuffer.byteLength;\r\n        }\r\n\r\n        return buffer;\r\n    }\r\n\r\n    /**\r\n     * Deserialize snapshot from binary.\r\n     */\r\n    fromBinary(buffer: ArrayBuffer): SparseSnapshot {\r\n        const view = new DataView(buffer);\r\n        let offset = 0;\r\n\r\n        // Read meta\r\n        const metaLength = view.getUint32(offset, true);\r\n        offset += 4;\r\n        const metaBytes = new Uint8Array(buffer, offset, metaLength);\r\n        const metaJson = new TextDecoder().decode(metaBytes);\r\n        const meta = JSON.parse(metaJson);\r\n        offset += metaLength;\r\n\r\n        // Read entity mask\r\n        const maskLength = view.getUint32(offset, true);\r\n        offset += 4;\r\n        const entityMask = new Uint32Array(\r\n            buffer.slice(offset, offset + maskLength)\r\n        );\r\n        offset += maskLength;\r\n\r\n        // Read component data\r\n        const componentData = new Map<string, ArrayBuffer>();\r\n        const allComponents = getAllComponents();\r\n\r\n        for (const name of meta.componentNames) {\r\n            const component = allComponents.get(name);\r\n            if (!component) continue;\r\n\r\n            // Calculate size for this component\r\n            let compSize = 0;\r\n            for (const fieldName of component.fieldNames) {\r\n                const arr = component.storage.fields[fieldName];\r\n                compSize += meta.entityMeta.length * arr.BYTES_PER_ELEMENT;\r\n            }\r\n\r\n            const compBuffer = buffer.slice(offset, offset + compSize);\r\n            componentData.set(name, compBuffer);\r\n            offset += compSize;\r\n        }\r\n\r\n        return {\r\n            frame: meta.frame,\r\n            seq: meta.seq,\r\n            entityMask,\r\n            entityMeta: meta.entityMeta,\r\n            componentData,\r\n            entityCount: meta.entityMeta.length,\r\n            allocator: meta.allocator,\r\n            strings: meta.strings,\r\n            rng: meta.rng\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Rollback buffer - stores snapshots for rewinding state.\r\n */\r\nexport class RollbackBuffer {\r\n    private snapshots: Map<number, SparseSnapshot> = new Map();\r\n    private codec: SparseSnapshotCodec = new SparseSnapshotCodec();\r\n\r\n    constructor(private maxFrames: number = 60) {}\r\n\r\n    /**\r\n     * Save a snapshot for a frame.\r\n     */\r\n    save(frame: number, snapshot: SparseSnapshot): void {\r\n        this.snapshots.set(frame, snapshot);\r\n\r\n        // Prune old snapshots (keep exactly maxFrames snapshots)\r\n        const minFrame = frame - this.maxFrames + 1;\r\n        for (const f of this.snapshots.keys()) {\r\n            if (f < minFrame) {\r\n                this.snapshots.delete(f);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get snapshot for a frame.\r\n     */\r\n    get(frame: number): SparseSnapshot | undefined {\r\n        return this.snapshots.get(frame);\r\n    }\r\n\r\n    /**\r\n     * Check if snapshot exists for frame.\r\n     */\r\n    has(frame: number): boolean {\r\n        return this.snapshots.has(frame);\r\n    }\r\n\r\n    /**\r\n     * Get oldest available frame.\r\n     */\r\n    getOldestFrame(): number | undefined {\r\n        let oldest: number | undefined;\r\n        for (const frame of this.snapshots.keys()) {\r\n            if (oldest === undefined || frame < oldest) {\r\n                oldest = frame;\r\n            }\r\n        }\r\n        return oldest;\r\n    }\r\n\r\n    /**\r\n     * Get newest available frame.\r\n     */\r\n    getNewestFrame(): number | undefined {\r\n        let newest: number | undefined;\r\n        for (const frame of this.snapshots.keys()) {\r\n            if (newest === undefined || frame > newest) {\r\n                newest = frame;\r\n            }\r\n        }\r\n        return newest;\r\n    }\r\n\r\n    /**\r\n     * Clear all snapshots.\r\n     */\r\n    clear(): void {\r\n        this.snapshots.clear();\r\n    }\r\n\r\n    /**\r\n     * Get number of stored snapshots.\r\n     */\r\n    get size(): number {\r\n        return this.snapshots.size;\r\n    }\r\n}\r\n", "/**\r\n * String Registry - Deterministic string interning\r\n *\r\n * Converts strings to integer IDs for efficient storage and comparison.\r\n * Used for entity types, colors, sprite IDs, etc.\r\n *\r\n * DETERMINISM: ID allocation order must be identical across all clients.\r\n * Strings are assigned IDs in order of first intern() call.\r\n */\r\n\r\nexport interface StringRegistryState {\r\n    tables: Record<string, Record<string, number>>;\r\n    nextIds: Record<string, number>;\r\n}\r\n\r\n/**\r\n * String registry for interning strings.\r\n *\r\n * Provides bidirectional mapping between strings and integer IDs,\r\n * organized by namespace (e.g., 'color', 'sprite', 'entityType').\r\n */\r\nexport class StringRegistry {\r\n    private stringToId: Map<string, Map<string, number>> = new Map();\r\n    private idToString: Map<string, Map<number, string>> = new Map();\r\n    private nextId: Map<string, number> = new Map();\r\n\r\n    /**\r\n     * Intern a string, get back an integer ID.\r\n     * If the string was already interned, returns the existing ID.\r\n     *\r\n     * @param namespace - Category for the string (e.g., 'color', 'sprite')\r\n     * @param str - The string to intern\r\n     * @returns Integer ID for the string\r\n     */\r\n    intern(namespace: string, str: string): number {\r\n        let nsMap = this.stringToId.get(namespace);\r\n        if (!nsMap) {\r\n            nsMap = new Map();\r\n            this.stringToId.set(namespace, nsMap);\r\n        }\r\n\r\n        const existing = nsMap.get(str);\r\n        if (existing !== undefined) return existing;\r\n\r\n        const id = this.nextId.get(namespace) ?? 1;\r\n        this.nextId.set(namespace, id + 1);\r\n\r\n        nsMap.set(str, id);\r\n\r\n        let idMap = this.idToString.get(namespace);\r\n        if (!idMap) {\r\n            idMap = new Map();\r\n            this.idToString.set(namespace, idMap);\r\n        }\r\n        idMap.set(id, str);\r\n\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Look up string by ID.\r\n     *\r\n     * @param namespace - Category for the string\r\n     * @param id - Integer ID to look up\r\n     * @returns The original string, or null if not found\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.idToString.get(namespace)?.get(id) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Get state for snapshotting.\r\n     * Returns a serializable representation of all interned strings.\r\n     */\r\n    getState(): StringRegistryState {\r\n        const tables: Record<string, Record<string, number>> = {};\r\n        const nextIds: Record<string, number> = {};\r\n\r\n        for (const [ns, nsMap] of this.stringToId) {\r\n            tables[ns] = Object.fromEntries(nsMap);\r\n            nextIds[ns] = this.nextId.get(ns) ?? 1;\r\n        }\r\n\r\n        return { tables, nextIds };\r\n    }\r\n\r\n    /**\r\n     * Restore state from snapshot.\r\n     * Replaces all current data with the snapshot state.\r\n     */\r\n    setState(state: StringRegistryState): void {\r\n        this.stringToId.clear();\r\n        this.idToString.clear();\r\n        this.nextId.clear();\r\n\r\n        for (const [ns, table] of Object.entries(state.tables)) {\r\n            const nsMap = new Map(Object.entries(table));\r\n            this.stringToId.set(ns, nsMap);\r\n\r\n            const idMap = new Map<number, string>();\r\n            for (const [str, id] of nsMap) {\r\n                idMap.set(id, str);\r\n            }\r\n            this.idToString.set(ns, idMap);\r\n\r\n            this.nextId.set(ns, state.nextIds[ns] ?? 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all data.\r\n     */\r\n    clear(): void {\r\n        this.stringToId.clear();\r\n        this.idToString.clear();\r\n        this.nextId.clear();\r\n    }\r\n}\r\n", "/**\r\n * InputHistory - Stores confirmed server inputs for rollback resimulation\r\n *\r\n * This class is CRITICAL for determinism in rollback netcode. It stores all\r\n * inputs (both predictions and server-confirmed) so that resimulation can\r\n * replay the exact same sequence of inputs after a rollback.\r\n *\r\n * Key guarantees:\r\n * 1. Inputs are stored per-frame with deterministic iteration order (sorted by clientId)\r\n * 2. Server-confirmed inputs replace any local predictions\r\n * 3. Serialization produces bit-exact snapshots for late joiners\r\n * 4. Memory is bounded by maxFrames through pruning\r\n */\r\n\r\n/**\r\n * Input data for a single frame, containing all client inputs.\r\n */\r\nexport interface FrameInput {\r\n    /** The frame number */\r\n    frame: number;\r\n\r\n    /** Client inputs for this frame (clientId -> input data) */\r\n    inputs: Map<number, Record<string, any>>;\r\n\r\n    /** Whether this frame has been confirmed by the server */\r\n    confirmed: boolean;\r\n\r\n    /**\r\n     * Get inputs in deterministic (sorted) order for resimulation.\r\n     * CRITICAL: Iteration order must be identical across all clients.\r\n     */\r\n    getSortedInputs(): Array<[number, Record<string, any>]>;\r\n}\r\n\r\n/**\r\n * Internal FrameInput implementation.\r\n */\r\nclass FrameInputImpl implements FrameInput {\r\n    frame: number;\r\n    inputs: Map<number, Record<string, any>>;\r\n    confirmed: boolean;\r\n\r\n    constructor(frame: number) {\r\n        this.frame = frame;\r\n        this.inputs = new Map();\r\n        this.confirmed = false;\r\n    }\r\n\r\n    /**\r\n     * Get inputs sorted by clientId for deterministic iteration.\r\n     */\r\n    getSortedInputs(): Array<[number, Record<string, any>]> {\r\n        const entries = Array.from(this.inputs.entries());\r\n        // Sort by clientId (numeric) for determinism\r\n        entries.sort((a, b) => a[0] - b[0]);\r\n        return entries;\r\n    }\r\n}\r\n\r\n/**\r\n * Serialized state for snapshots.\r\n */\r\nexport interface InputHistoryState {\r\n    frames: Array<{\r\n        frame: number;\r\n        inputs: Array<{ clientId: number; data: Record<string, any> }>;\r\n        confirmed: boolean;\r\n    }>;\r\n}\r\n\r\n/**\r\n * InputHistory stores inputs for resimulation during rollback.\r\n */\r\nexport class InputHistory {\r\n    /** Stored frames: frame number -> FrameInput */\r\n    private history: Map<number, FrameInputImpl> = new Map();\r\n\r\n    /** Maximum frames to keep (for memory management) */\r\n    private maxFrames: number;\r\n\r\n    /**\r\n     * Create InputHistory with optional max frame limit.\r\n     * @param maxFrames Maximum frames to keep (default 120)\r\n     */\r\n    constructor(maxFrames: number = 120) {\r\n        this.maxFrames = maxFrames;\r\n    }\r\n\r\n    /**\r\n     * Store input for a frame from a client.\r\n     * Used for local predictions before server confirmation.\r\n     *\r\n     * @param frame Frame number\r\n     * @param clientId Client ID (numeric)\r\n     * @param input Input data\r\n     */\r\n    setInput(frame: number, clientId: number, input: Record<string, any>): void {\r\n        let frameInput = this.history.get(frame);\r\n\r\n        if (!frameInput) {\r\n            frameInput = new FrameInputImpl(frame);\r\n            this.history.set(frame, frameInput);\r\n        }\r\n\r\n        frameInput.inputs.set(clientId, input);\r\n    }\r\n\r\n    /**\r\n     * Mark a frame as server-confirmed with authoritative inputs.\r\n     * This replaces any local predictions with server-provided data.\r\n     *\r\n     * @param frame Frame number\r\n     * @param inputs Map of clientId -> input data from server\r\n     */\r\n    confirmFrame(frame: number, inputs: Map<number, Record<string, any>>): void {\r\n        // Create new frame or replace existing\r\n        const frameInput = new FrameInputImpl(frame);\r\n        frameInput.confirmed = true;\r\n\r\n        // Copy all server inputs\r\n        for (const [clientId, data] of inputs) {\r\n            frameInput.inputs.set(clientId, data);\r\n        }\r\n\r\n        this.history.set(frame, frameInput);\r\n    }\r\n\r\n    /**\r\n     * Get input data for a specific frame.\r\n     *\r\n     * @param frame Frame number\r\n     * @returns FrameInput or undefined if not found\r\n     */\r\n    getFrame(frame: number): FrameInput | undefined {\r\n        return this.history.get(frame);\r\n    }\r\n\r\n    /**\r\n     * Get ordered frames for resimulation.\r\n     * Returns frames in ascending order, skipping any missing frames.\r\n     *\r\n     * CRITICAL: Order must be deterministic for rollback to work.\r\n     *\r\n     * @param fromFrame Start frame (inclusive)\r\n     * @param toFrame End frame (inclusive)\r\n     * @returns Array of FrameInput in ascending frame order\r\n     */\r\n    getRange(fromFrame: number, toFrame: number): FrameInput[] {\r\n        if (fromFrame > toFrame) {\r\n            return [];\r\n        }\r\n\r\n        const result: FrameInputImpl[] = [];\r\n\r\n        // Collect all frames in range\r\n        for (const [frame, frameInput] of this.history) {\r\n            if (frame >= fromFrame && frame <= toFrame) {\r\n                result.push(frameInput);\r\n            }\r\n        }\r\n\r\n        // Sort by frame number for deterministic order\r\n        result.sort((a, b) => a.frame - b.frame);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Remove frames before the specified frame number.\r\n     * Called to limit memory usage.\r\n     *\r\n     * @param beforeFrame Remove all frames with frame < beforeFrame\r\n     */\r\n    prune(beforeFrame: number): void {\r\n        // Collect frames to remove (avoid modifying during iteration)\r\n        const toRemove: number[] = [];\r\n\r\n        for (const frame of this.history.keys()) {\r\n            if (frame < beforeFrame) {\r\n                toRemove.push(frame);\r\n            }\r\n        }\r\n\r\n        // Remove collected frames\r\n        for (const frame of toRemove) {\r\n            this.history.delete(frame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize for snapshots (late joiner sync).\r\n     * CRITICAL: Must produce identical output across all clients.\r\n     *\r\n     * @returns Serializable state object\r\n     */\r\n    getState(): InputHistoryState {\r\n        const frames: InputHistoryState['frames'] = [];\r\n\r\n        // Sort frames by frame number for deterministic serialization\r\n        const sortedFrames = Array.from(this.history.entries())\r\n            .sort((a, b) => a[0] - b[0]);\r\n\r\n        for (const [, frameInput] of sortedFrames) {\r\n            // Sort inputs by clientId for deterministic serialization\r\n            const sortedInputs = frameInput.getSortedInputs().map(([clientId, data]) => ({\r\n                clientId,\r\n                data\r\n            }));\r\n\r\n            frames.push({\r\n                frame: frameInput.frame,\r\n                inputs: sortedInputs,\r\n                confirmed: frameInput.confirmed\r\n            });\r\n        }\r\n\r\n        return { frames };\r\n    }\r\n\r\n    /**\r\n     * Restore from serialized state (for late joiner sync).\r\n     * Clears existing data before restoring.\r\n     *\r\n     * @param state Previously serialized state\r\n     */\r\n    setState(state: InputHistoryState): void {\r\n        // Clear existing data\r\n        this.history.clear();\r\n\r\n        // Restore frames\r\n        for (const frameData of state.frames) {\r\n            const frameInput = new FrameInputImpl(frameData.frame);\r\n            frameInput.confirmed = frameData.confirmed;\r\n\r\n            for (const { clientId, data } of frameData.inputs) {\r\n                frameInput.inputs.set(clientId, data);\r\n            }\r\n\r\n            this.history.set(frameData.frame, frameInput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the number of frames currently stored.\r\n     * Useful for debugging and monitoring memory usage.\r\n     */\r\n    get size(): number {\r\n        return this.history.size;\r\n    }\r\n\r\n    /**\r\n     * Clear all stored history.\r\n     */\r\n    clear(): void {\r\n        this.history.clear();\r\n    }\r\n}\r\n", "/**\r\n * ECS World\r\n *\r\n * Main entry point for the ECS system. Manages:\r\n * - Entity definitions and spawning\r\n * - Component management\r\n * - Query engine\r\n * - System scheduler\r\n * - String interning\r\n */\r\n\r\nimport { EntityIdAllocator, EntityIdAllocatorState } from './entity-id';\r\nimport { SparseSnapshot, SparseSnapshotCodec } from './snapshot';\r\nimport {\r\n    ComponentType,\r\n    defineComponent as defineComponentInternal,\r\n    hasComponent,\r\n    addComponentToEntity,\r\n    initializeComponentDefaults,\r\n    removeComponentFromEntity,\r\n    clearComponentRegistry,\r\n    getAllComponents\r\n} from './component';\r\nimport { QueryEngine, QueryIterator } from './query';\r\nimport { SystemScheduler, SystemFn, SystemOptions } from './system';\r\nimport { Entity, EntityPool, EntityDefinition, RenderState } from './entity';\r\nimport { INDEX_MASK } from './constants';\r\nimport { toFixed, saveRandomState, loadRandomState } from '../math';\r\nimport { StringRegistry } from './string-registry';\r\nimport { InputHistory } from './input-history';\r\n\r\n/**\r\n * Entity definition builder.\r\n */\r\nexport class EntityBuilder {\r\n    private components: Array<{\r\n        type: ComponentType;\r\n        defaults?: Record<string, any>;\r\n    }> = [];\r\n\r\n    private registered: boolean = false;\r\n    private _syncFields?: string[];\r\n    private _onRestore?: (entity: Entity, game: any) => void;\r\n\r\n    constructor(\r\n        private world: World,\r\n        private name: string\r\n    ) {}\r\n\r\n    /**\r\n     * Add a component to this entity definition.\r\n     */\r\n    with<T extends Record<string, any>>(\r\n        component: ComponentType<T>,\r\n        defaults?: Partial<T>\r\n    ): EntityBuilder {\r\n        this.components.push({\r\n            type: component,\r\n            defaults: defaults as Record<string, any>\r\n        });\r\n\r\n        // Register immediately (idempotent - just overwrites with latest)\r\n        this.register();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set sync fields for this entity (internal - use GameEntityBuilder.syncOnly()).\r\n     */\r\n    _setSyncFields(fields: string[]): void {\r\n        this._syncFields = fields;\r\n    }\r\n\r\n    /**\r\n     * Set restore callback for this entity (internal - use GameEntityBuilder.onRestore()).\r\n     */\r\n    _setOnRestore(callback: (entity: Entity, game: any) => void): void {\r\n        this._onRestore = callback;\r\n    }\r\n\r\n    /**\r\n     * Finalize entity definition.\r\n     */\r\n    private register(): void {\r\n        this.world._registerEntityDef({\r\n            name: this.name,\r\n            components: this.components,\r\n            syncFields: this._syncFields,\r\n            onRestore: this._onRestore\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Force immediate registration (for sync usage).\r\n     */\r\n    _ensureRegistered(): void {\r\n        if (!this.registered) {\r\n            this.registered = true;\r\n        }\r\n        this.register();\r\n    }\r\n\r\n    /**\r\n     * Get the entity definition (for internal use).\r\n     */\r\n    _getDefinition(): EntityDefinition {\r\n        return {\r\n            name: this.name,\r\n            components: this.components,\r\n            syncFields: this._syncFields,\r\n            onRestore: this._onRestore\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * ECS World - main container for all ECS state.\r\n */\r\nexport class World {\r\n    /** Entity ID allocator */\r\n    readonly idAllocator: EntityIdAllocator;\r\n\r\n    /** Query engine */\r\n    readonly queryEngine: QueryEngine;\r\n\r\n    /** System scheduler */\r\n    readonly scheduler: SystemScheduler;\r\n\r\n    /** Entity pool */\r\n    readonly entityPool: EntityPool;\r\n\r\n    /** String registry */\r\n    readonly strings: StringRegistry;\r\n\r\n    /** Entity definitions */\r\n    private entityDefs: Map<string, EntityDefinition> = new Map();\r\n\r\n    /** Active entity eids */\r\n    private activeEntities: Set<number> = new Set();\r\n\r\n    /** Entity type by eid */\r\n    private entityTypes: Map<number, string> = new Map();\r\n\r\n    /** Entity components by eid */\r\n    private entityComponents: Map<number, ComponentType[]> = new Map();\r\n\r\n    /** Client ID by eid */\r\n    private entityClientIds: Map<number, number> = new Map();\r\n\r\n    /** Input registry: clientId \u2192 input data */\r\n    private inputRegistry: Map<number, any> = new Map();\r\n\r\n    /** Whether running on client */\r\n    private _isClient: boolean = true;\r\n\r\n    constructor() {\r\n        this.idAllocator = new EntityIdAllocator();\r\n        this.entityPool = new EntityPool();\r\n        this.strings = new StringRegistry();\r\n\r\n        // Create query engine with callbacks\r\n        this.queryEngine = new QueryEngine(\r\n            (eid) => this.getEntity(eid),\r\n            (eid) => this.isDestroyed(eid)\r\n        );\r\n\r\n        this.scheduler = new SystemScheduler();\r\n\r\n        // Register interpolation state saving in prePhysics phase\r\n        this.addSystem(() => this.saveInterpolationState(), { phase: 'prePhysics', order: -1000 });\r\n    }\r\n\r\n    /**\r\n     * Set whether running on client.\r\n     */\r\n    setIsClient(isClient: boolean): void {\r\n        this._isClient = isClient;\r\n        this.scheduler.setIsClient(isClient);\r\n    }\r\n\r\n    /**\r\n     * Check if running on client.\r\n     */\r\n    get isClient(): boolean {\r\n        return this._isClient;\r\n    }\r\n\r\n    // ==========================================\r\n    // Component API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Define a new component type.\r\n     */\r\n    defineComponent<T extends Record<string, any>>(\r\n        name: string,\r\n        defaults: T\r\n    ): ComponentType<{ [K in keyof T]: T[K] extends boolean ? boolean : number }> {\r\n        return defineComponentInternal(name, defaults);\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Definition API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Define a new entity type.\r\n     */\r\n    defineEntity(name: string): EntityBuilder {\r\n        const builder = new EntityBuilder(this, name);\r\n        // Auto-register when builder methods are done\r\n        // We need to defer this, so we'll register on first spawn or explicitly\r\n        return builder;\r\n    }\r\n\r\n    /**\r\n     * Register an entity definition (internal).\r\n     */\r\n    _registerEntityDef(def: EntityDefinition): void {\r\n        this.entityDefs.set(def.name, def);\r\n    }\r\n\r\n    /**\r\n     * Get entity definition by type name.\r\n     */\r\n    getEntityDef(typeName: string): EntityDefinition | undefined {\r\n        return this.entityDefs.get(typeName);\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Spawning/Destruction\r\n    // ==========================================\r\n\r\n    /**\r\n     * Spawn a new entity.\r\n     */\r\n    spawn(\r\n        typeOrBuilder: string | EntityBuilder,\r\n        props: Record<string, any> = {}\r\n    ): Entity {\r\n        // Handle EntityBuilder\r\n        let typeName: string;\r\n        if (typeof typeOrBuilder === 'string') {\r\n            typeName = typeOrBuilder;\r\n        } else {\r\n            const def = typeOrBuilder._getDefinition();\r\n            this._registerEntityDef(def);\r\n            typeName = def.name;\r\n        }\r\n\r\n        // Get entity definition\r\n        const def = this.entityDefs.get(typeName);\r\n        if (!def) {\r\n            throw new Error(`Unknown entity type: '${typeName}'`);\r\n        }\r\n\r\n        // Allocate entity ID\r\n        const eid = this.idAllocator.allocate();\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Get entity wrapper\r\n        const entity = this.entityPool.acquire(eid);\r\n\r\n        // Track entity\r\n        this.activeEntities.add(eid);\r\n        this.entityTypes.set(eid, typeName);\r\n\r\n        // Initialize components\r\n        const componentTypes: ComponentType[] = [];\r\n        for (const compDef of def.components) {\r\n            const component = compDef.type;\r\n            componentTypes.push(component);\r\n\r\n            // Add to storage\r\n            addComponentToEntity(component.storage, index);\r\n            initializeComponentDefaults(component.storage, index);\r\n\r\n            // Apply definition defaults\r\n            if (compDef.defaults) {\r\n                for (const [key, value] of Object.entries(compDef.defaults)) {\r\n                    const arr = component.storage.fields[key];\r\n                    if (arr) {\r\n                        const fieldDef = component.storage.schema[key];\r\n                        if (fieldDef.type === 'i32') {\r\n                            arr[index] = toFixed(value as number);\r\n                        } else if (fieldDef.type === 'bool') {\r\n                            arr[index] = value ? 1 : 0;\r\n                        } else {\r\n                            arr[index] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply spawn props (route to components)\r\n        let clientId: number | undefined;\r\n        for (const [key, value] of Object.entries(props)) {\r\n            if (key === 'clientId') {\r\n                clientId = value as number;\r\n                this.entityClientIds.set(eid, clientId);\r\n            }\r\n\r\n            // Route to first component that has this field\r\n            for (const component of componentTypes) {\r\n                if (key in component.storage.schema) {\r\n                    const arr = component.storage.fields[key];\r\n                    const fieldDef = component.storage.schema[key];\r\n                    if (fieldDef.type === 'i32') {\r\n                        arr[index] = toFixed(value as number);\r\n                    } else if (fieldDef.type === 'bool') {\r\n                        arr[index] = value ? 1 : 0;\r\n                    } else {\r\n                        arr[index] = value;\r\n                    }\r\n                    break; // Route to first matching component\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store components\r\n        this.entityComponents.set(eid, componentTypes);\r\n\r\n        // Initialize entity wrapper\r\n        entity._init(eid, typeName, componentTypes, this);\r\n\r\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\r\n        // Use raw props values (before fixed-point conversion) for render coordinates\r\n        if (props.x !== undefined || props.y !== undefined) {\r\n            const spawnX = props.x ?? 0;\r\n            const spawnY = props.y ?? 0;\r\n            entity.render.prevX = spawnX;\r\n            entity.render.prevY = spawnY;\r\n            entity.render.interpX = spawnX;\r\n            entity.render.interpY = spawnY;\r\n        }\r\n\r\n        // Register in query engine\r\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Spawn an entity with a specific eid (for snapshot restore).\r\n     * This is used when restoring entities to preserve their original IDs.\r\n     */\r\n    spawnWithId(typeOrBuilder: string | EntityBuilder, targetEid: number, props: Record<string, any> = {}): Entity {\r\n        let typeName: string;\r\n        if (typeof typeOrBuilder === 'string') {\r\n            typeName = typeOrBuilder;\r\n        } else {\r\n            const def = typeOrBuilder._getDefinition();\r\n            this._registerEntityDef(def);\r\n            typeName = def.name;\r\n        }\r\n\r\n        // Get entity definition\r\n        const def = this.entityDefs.get(typeName);\r\n        if (!def) {\r\n            throw new Error(`Unknown entity type: '${typeName}'`);\r\n        }\r\n\r\n        // Allocate specific entity ID\r\n        const eid = this.idAllocator.allocateSpecific(targetEid);\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Get entity wrapper\r\n        const entity = this.entityPool.acquire(eid);\r\n\r\n        // Track entity\r\n        this.activeEntities.add(eid);\r\n        this.entityTypes.set(eid, typeName);\r\n\r\n        // Initialize components\r\n        const componentTypes: ComponentType[] = [];\r\n        for (const compDef of def.components) {\r\n            const component = compDef.type;\r\n            componentTypes.push(component);\r\n\r\n            // Add to storage\r\n            addComponentToEntity(component.storage, index);\r\n            initializeComponentDefaults(component.storage, index);\r\n\r\n            // Apply definition defaults\r\n            if (compDef.defaults) {\r\n                for (const [key, value] of Object.entries(compDef.defaults)) {\r\n                    const arr = component.storage.fields[key];\r\n                    if (arr) {\r\n                        const fieldDef = component.storage.schema[key];\r\n                        if (fieldDef.type === 'i32') {\r\n                            arr[index] = toFixed(value as number);\r\n                        } else if (fieldDef.type === 'bool') {\r\n                            arr[index] = value ? 1 : 0;\r\n                        } else {\r\n                            arr[index] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply spawn props (route to components)\r\n        let clientId: number | undefined;\r\n        for (const [key, value] of Object.entries(props)) {\r\n            if (key === 'clientId') {\r\n                clientId = value as number;\r\n                this.entityClientIds.set(eid, clientId);\r\n            }\r\n\r\n            // Route to first component that has this field\r\n            for (const compDef of def.components) {\r\n                const arr = compDef.type.storage.fields[key];\r\n                if (arr) {\r\n                    const fieldDef = compDef.type.storage.schema[key];\r\n                    if (fieldDef.type === 'i32') {\r\n                        arr[index] = toFixed(value as number);\r\n                    } else if (fieldDef.type === 'bool') {\r\n                        arr[index] = value ? 1 : 0;\r\n                    } else {\r\n                        arr[index] = value;\r\n                    }\r\n                    break; // Route to first matching component\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store components\r\n        this.entityComponents.set(eid, componentTypes);\r\n\r\n        // Initialize entity wrapper\r\n        entity._init(eid, typeName, componentTypes, this);\r\n\r\n        // Initialize render state to spawn position (prevent interpolation from 0,0)\r\n        // Use raw props values (before fixed-point conversion) for render coordinates\r\n        if (props.x !== undefined || props.y !== undefined) {\r\n            const spawnX = props.x ?? 0;\r\n            const spawnY = props.y ?? 0;\r\n            entity.render.prevX = spawnX;\r\n            entity.render.prevY = spawnY;\r\n            entity.render.interpX = spawnX;\r\n            entity.render.interpY = spawnY;\r\n        }\r\n\r\n        // Register in query engine\r\n        this.queryEngine.addEntity(eid, typeName, componentTypes, clientId);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * Destroy an entity.\r\n     */\r\n    destroyEntity(entity: Entity): void {\r\n        const eid = entity.eid;\r\n\r\n        if (!this.activeEntities.has(eid)) {\r\n            return; // Already destroyed\r\n        }\r\n\r\n        const typeName = this.entityTypes.get(eid) || '';\r\n        const components = this.entityComponents.get(eid) || [];\r\n        const clientId = this.entityClientIds.get(eid);\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Remove from component storage\r\n        for (const component of components) {\r\n            removeComponentFromEntity(component.storage, index);\r\n        }\r\n\r\n        // Remove from query engine\r\n        this.queryEngine.removeEntity(eid, typeName, components, clientId);\r\n\r\n        // Clean up tracking\r\n        this.activeEntities.delete(eid);\r\n        this.entityTypes.delete(eid);\r\n        this.entityComponents.delete(eid);\r\n        this.entityClientIds.delete(eid);\r\n\r\n        // Return entity wrapper to pool\r\n        this.entityPool.release(eid);\r\n\r\n        // Free entity ID\r\n        this.idAllocator.free(eid);\r\n    }\r\n\r\n    /**\r\n     * Get entity by eid.\r\n     */\r\n    getEntity(eid: number): Entity | null {\r\n        if (!this.activeEntities.has(eid)) {\r\n            return null;\r\n        }\r\n\r\n        const entity = this.entityPool.get(eid);\r\n        if (entity && !entity.destroyed) {\r\n            return entity;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if entity is destroyed.\r\n     */\r\n    isDestroyed(eid: number): boolean {\r\n        return !this.activeEntities.has(eid);\r\n    }\r\n\r\n    /**\r\n     * Get entity by clientId (O(1) lookup).\r\n     */\r\n    getEntityByClientId(clientId: number): Entity | null {\r\n        const eid = this.queryEngine.getByClientId(clientId);\r\n        if (eid === undefined) return null;\r\n        return this.getEntity(eid);\r\n    }\r\n\r\n    /**\r\n     * Set clientId for an entity (for snapshot restore).\r\n     * Updates both entityClientIds map and queryEngine index.\r\n     */\r\n    setEntityClientId(eid: number, clientId: number): void {\r\n        this.entityClientIds.set(eid, clientId);\r\n        this.queryEngine.setClientId(eid, clientId);\r\n    }\r\n\r\n    // ==========================================\r\n    // Query API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Query entities by type or component.\r\n     */\r\n    query(\r\n        typeOrComponent: string | ComponentType,\r\n        ...moreComponents: ComponentType[]\r\n    ): QueryIterator<Entity> {\r\n        return this.queryEngine.query(typeOrComponent, ...moreComponents);\r\n    }\r\n\r\n    /**\r\n     * Get all active entities.\r\n     */\r\n    getAllEntities(): Entity[] {\r\n        const result: Entity[] = [];\r\n        // Sort eids for determinism\r\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\r\n        for (const eid of sortedEids) {\r\n            const entity = this.entityPool.get(eid);\r\n            if (entity) {\r\n                result.push(entity);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get all active entity IDs.\r\n     */\r\n    getAllEntityIds(): number[] {\r\n        return Array.from(this.activeEntities).sort((a, b) => a - b);\r\n    }\r\n\r\n    // ==========================================\r\n    // System API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Add a system.\r\n     */\r\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\r\n        return this.scheduler.add(fn, options);\r\n    }\r\n\r\n    /**\r\n     * Run all systems.\r\n     */\r\n    runSystems(): void {\r\n        this.scheduler.runAll();\r\n    }\r\n\r\n    // ==========================================\r\n    // String Interning API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Intern a string, get back an integer ID.\r\n     */\r\n    internString(namespace: string, str: string): number {\r\n        return this.strings.intern(namespace, str);\r\n    }\r\n\r\n    /**\r\n     * Look up string by ID.\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.strings.getString(namespace, id);\r\n    }\r\n\r\n    // ==========================================\r\n    // Input Registry\r\n    // ==========================================\r\n\r\n    /**\r\n     * Set input data for a client.\r\n     */\r\n    setInput(clientId: number, data: any): void {\r\n        this.inputRegistry.set(clientId, data);\r\n        // Also set on entity if it exists\r\n        const entity = this.getEntityByClientId(clientId);\r\n        if (entity) {\r\n            entity._setInputData(data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get input data for a client.\r\n     */\r\n    getInput(clientId: number): any {\r\n        return this.inputRegistry.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Clear all input data (call at end of tick).\r\n     */\r\n    clearInputs(): void {\r\n        this.inputRegistry.clear();\r\n    }\r\n\r\n    /**\r\n     * Get input state for snapshot.\r\n     * Returns a map of clientId -> input data.\r\n     */\r\n    getInputState(): Record<number, any> {\r\n        const state: Record<number, any> = {};\r\n        for (const [clientId, data] of this.inputRegistry) {\r\n            state[clientId] = data;\r\n        }\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Set input state from snapshot.\r\n     * Restores the input registry and entity input caches.\r\n     */\r\n    setInputState(state: Record<number, any>): void {\r\n        this.inputRegistry.clear();\r\n        for (const [clientIdStr, data] of Object.entries(state)) {\r\n            const clientId = parseInt(clientIdStr, 10);\r\n            this.inputRegistry.set(clientId, data);\r\n            // Also set on entity if it exists\r\n            const entity = this.getEntityByClientId(clientId);\r\n            if (entity) {\r\n                entity._setInputData(data);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // ==========================================\r\n    // State Management\r\n    // ==========================================\r\n\r\n    /**\r\n     * Get full world state for snapshotting.\r\n     */\r\n    getState(): WorldState {\r\n        const entities: EntityState[] = [];\r\n\r\n        for (const eid of this.activeEntities) {\r\n            const typeName = this.entityTypes.get(eid)!;\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            const componentData: Record<string, Record<string, number>> = {};\r\n\r\n            for (const component of components) {\r\n                const data: Record<string, number> = {};\r\n                for (const [fieldName, arr] of Object.entries(component.storage.fields)) {\r\n                    data[fieldName] = arr[index];\r\n                }\r\n                componentData[component.name] = data;\r\n            }\r\n\r\n            entities.push({\r\n                eid,\r\n                type: typeName,\r\n                components: componentData,\r\n                clientId: this.entityClientIds.get(eid)\r\n            });\r\n        }\r\n\r\n        return {\r\n            entities,\r\n            allocator: this.idAllocator.getState(),\r\n            strings: this.strings.getState()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Restore world state from snapshot.\r\n     */\r\n    setState(state: WorldState): void {\r\n        // Clear current state\r\n        this.clear();\r\n\r\n        // Restore allocator\r\n        this.idAllocator.setState(state.allocator);\r\n\r\n        // Restore strings\r\n        this.strings.setState(state.strings);\r\n\r\n        // Restore entities\r\n        for (const entityState of state.entities) {\r\n            const def = this.entityDefs.get(entityState.type);\r\n            if (!def) {\r\n                console.warn(`Unknown entity type in snapshot: ${entityState.type}`);\r\n                continue;\r\n            }\r\n\r\n            const eid = entityState.eid;\r\n            const index = eid & INDEX_MASK;\r\n\r\n            // Get entity wrapper\r\n            const entity = this.entityPool.acquire(eid);\r\n\r\n            // Track entity\r\n            this.activeEntities.add(eid);\r\n            this.entityTypes.set(eid, entityState.type);\r\n\r\n            if (entityState.clientId !== undefined) {\r\n                this.entityClientIds.set(eid, entityState.clientId);\r\n            }\r\n\r\n            // Restore components\r\n            const componentTypes: ComponentType[] = [];\r\n            for (const compDef of def.components) {\r\n                const component = compDef.type;\r\n                componentTypes.push(component);\r\n\r\n                addComponentToEntity(component.storage, index);\r\n\r\n                // Restore component data\r\n                const savedData = entityState.components[component.name];\r\n                if (savedData) {\r\n                    for (const [fieldName, value] of Object.entries(savedData)) {\r\n                        const arr = component.storage.fields[fieldName];\r\n                        if (arr) {\r\n                            arr[index] = value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.entityComponents.set(eid, componentTypes);\r\n\r\n            // Initialize entity wrapper\r\n            entity._init(eid, entityState.type, componentTypes, this);\r\n\r\n            // Register in query engine\r\n            this.queryEngine.addEntity(eid, entityState.type, componentTypes, entityState.clientId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all world state.\r\n     */\r\n    clear(): void {\r\n        // Release all entities\r\n        for (const eid of this.activeEntities) {\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            for (const component of components) {\r\n                removeComponentFromEntity(component.storage, index);\r\n            }\r\n\r\n            this.entityPool.release(eid);\r\n        }\r\n\r\n        // Clear tracking\r\n        this.activeEntities.clear();\r\n        this.entityTypes.clear();\r\n        this.entityComponents.clear();\r\n        this.entityClientIds.clear();\r\n\r\n        // Clear indices\r\n        this.queryEngine.clear();\r\n\r\n        // Reset allocator\r\n        this.idAllocator.reset();\r\n\r\n        // Clear strings\r\n        this.strings.clear();\r\n    }\r\n\r\n    /**\r\n     * Reset world (keeps definitions, clears entities).\r\n     */\r\n    reset(): void {\r\n        this.clear();\r\n    }\r\n\r\n    /**\r\n     * Get entity count.\r\n     */\r\n    get entityCount(): number {\r\n        return this.activeEntities.size;\r\n    }\r\n\r\n    // ==========================================\r\n    // Sparse Snapshot API (Efficient)\r\n    // ==========================================\r\n\r\n    /** Snapshot codec */\r\n    private snapshotCodec: SparseSnapshotCodec = new SparseSnapshotCodec();\r\n\r\n    /** Current frame number */\r\n    frame: number = 0;\r\n\r\n    /** Current sequence number */\r\n    seq: number = 0;\r\n\r\n    /** RNG state (for determinism) - deprecated, now uses global random state */\r\n    rngState?: { s0: number; s1: number };\r\n\r\n    /**\r\n     * Get sparse snapshot (efficient format).\r\n     */\r\n    getSparseSnapshot(): SparseSnapshot {\r\n        return this.snapshotCodec.encode(\r\n            Array.from(this.activeEntities),\r\n            (eid) => this.entityTypes.get(eid) || '',\r\n            (eid) => this.entityClientIds.get(eid),\r\n            (eid) => this.entityComponents.get(eid) || [],\r\n            this.idAllocator.getState(),\r\n            this.strings.getState(),\r\n            this.frame,\r\n            this.seq,\r\n            saveRandomState() // CRITICAL: Save actual RNG state for deterministic rollback\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load sparse snapshot (efficient format).\r\n     */\r\n    loadSparseSnapshot(snapshot: SparseSnapshot): void {\r\n        this.snapshotCodec.decode(\r\n            snapshot,\r\n            () => this.clearForSnapshot(),\r\n            (state) => this.idAllocator.setState(state),\r\n            (state) => this.strings.setState(state),\r\n            (eid, type, clientId) => this.createEntityFromSnapshot(eid, type, clientId),\r\n            (rng) => {\r\n                // CRITICAL: Actually restore the global RNG state for deterministic rollback\r\n                if (rng) {\r\n                    loadRandomState(rng);\r\n                }\r\n            }\r\n        );\r\n\r\n        this.frame = snapshot.frame;\r\n        this.seq = snapshot.seq;\r\n\r\n        // Sync render state with restored transform positions\r\n        this.syncRenderStateFromTransforms();\r\n    }\r\n\r\n    /**\r\n     * Sync render state with current transform positions.\r\n     * Called after snapshot restore to prevent interpolation artifacts.\r\n     */\r\n    private syncRenderStateFromTransforms(): void {\r\n        for (const eid of this.activeEntities) {\r\n            const entity = this.getEntity(eid);\r\n            if (!entity) continue;\r\n\r\n            // Find Transform2D component and read x,y values\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            for (const component of components) {\r\n                if (component.name === 'Transform2D') {\r\n                    const xArr = component.storage.fields['x'];\r\n                    const yArr = component.storage.fields['y'];\r\n                    if (xArr && yArr) {\r\n                        // Convert from fixed-point to float for render\r\n                        const x = xArr[index] / 65536;\r\n                        const y = yArr[index] / 65536;\r\n                        entity.render.prevX = x;\r\n                        entity.render.prevY = y;\r\n                        entity.render.interpX = x;\r\n                        entity.render.interpY = y;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear world for snapshot restore (doesn't reset allocator).\r\n     */\r\n    private clearForSnapshot(): void {\r\n        // Release all entities\r\n        for (const eid of this.activeEntities) {\r\n            const components = this.entityComponents.get(eid) || [];\r\n            const index = eid & INDEX_MASK;\r\n\r\n            for (const component of components) {\r\n                removeComponentFromEntity(component.storage, index);\r\n            }\r\n\r\n            this.entityPool.release(eid);\r\n        }\r\n\r\n        // Clear tracking\r\n        this.activeEntities.clear();\r\n        this.entityTypes.clear();\r\n        this.entityComponents.clear();\r\n        this.entityClientIds.clear();\r\n\r\n        // Clear query indices\r\n        this.queryEngine.clear();\r\n    }\r\n\r\n    /**\r\n     * Create entity from snapshot data (without allocating new ID).\r\n     */\r\n    private createEntityFromSnapshot(eid: number, type: string, clientId?: number): void {\r\n        const def = this.entityDefs.get(type);\r\n        if (!def) {\r\n            console.warn(`Unknown entity type in snapshot: ${type}`);\r\n            return;\r\n        }\r\n\r\n        const index = eid & INDEX_MASK;\r\n\r\n        // Get entity wrapper\r\n        const entity = this.entityPool.acquire(eid);\r\n\r\n        // Track entity\r\n        this.activeEntities.add(eid);\r\n        this.entityTypes.set(eid, type);\r\n\r\n        if (clientId !== undefined) {\r\n            this.entityClientIds.set(eid, clientId);\r\n        }\r\n\r\n        // Setup components (data will be restored by codec)\r\n        const componentTypes: ComponentType[] = [];\r\n        for (const compDef of def.components) {\r\n            const component = compDef.type;\r\n            componentTypes.push(component);\r\n            addComponentToEntity(component.storage, index);\r\n        }\r\n\r\n        this.entityComponents.set(eid, componentTypes);\r\n\r\n        // Initialize entity wrapper\r\n        entity._init(eid, type, componentTypes, this);\r\n\r\n        // Register in query engine\r\n        this.queryEngine.addEntity(eid, type, componentTypes, clientId);\r\n    }\r\n\r\n    /**\r\n     * Serialize snapshot to binary for network transfer.\r\n     */\r\n    snapshotToBinary(snapshot: SparseSnapshot): ArrayBuffer {\r\n        return this.snapshotCodec.toBinary(snapshot);\r\n    }\r\n\r\n    /**\r\n     * Deserialize snapshot from binary.\r\n     */\r\n    snapshotFromBinary(buffer: ArrayBuffer): SparseSnapshot {\r\n        return this.snapshotCodec.fromBinary(buffer);\r\n    }\r\n\r\n    /**\r\n     * Get snapshot size estimate.\r\n     */\r\n    getSnapshotSize(snapshot: SparseSnapshot): number {\r\n        return this.snapshotCodec.getSize(snapshot);\r\n    }\r\n\r\n    // ==========================================\r\n    // Network Integration (Phase 3)\r\n    // ==========================================\r\n\r\n    /**\r\n     * Network input format.\r\n     */\r\n    private inputBuffer: Map<number, Record<string, any>> = new Map();\r\n\r\n    /**\r\n     * Run a single game tick with network inputs.\r\n     *\r\n     * Executes all system phases in order:\r\n     * 1. INPUT - Apply network inputs to entities\r\n     * 2. UPDATE - Game logic systems\r\n     * 3. PREPHYSICS - Save state for interpolation\r\n     * 4. PHYSICS - Physics simulation (external hook)\r\n     * 5. POSTPHYSICS - Post-physics cleanup\r\n     * 6. RENDER - Rendering (client only)\r\n     */\r\n    /** True while running deterministic simulation phases */\r\n    _isSimulating: boolean = false;\r\n\r\n    tick(frame: number, inputs: NetworkInput[] = []): void {\r\n        this.frame = frame;\r\n\r\n        // Apply network inputs (O(1) per input via clientIdIndex)\r\n        this.applyNetworkInputs(inputs);\r\n\r\n        // Run deterministic simulation phases\r\n        this._isSimulating = true;\r\n        try {\r\n            this.scheduler.runPhase('input');\r\n            this.scheduler.runPhase('update');\r\n            this.scheduler.runPhase('prePhysics');\r\n            this.scheduler.runPhase('physics');\r\n            this.scheduler.runPhase('postPhysics');\r\n        } finally {\r\n            this._isSimulating = false;\r\n        }\r\n\r\n        // Render phase only runs on client (not deterministic)\r\n        if (this._isClient) {\r\n            this.scheduler.runPhase('render');\r\n        }\r\n\r\n        // Clear input buffer after tick\r\n        this.inputBuffer.clear();\r\n    }\r\n\r\n    /**\r\n     * Apply network inputs to entities via O(1) clientId lookup.\r\n     */\r\n    private applyNetworkInputs(inputs: NetworkInput[]): void {\r\n        for (const input of inputs) {\r\n            // O(1) lookup via clientIdIndex\r\n            const entity = this.getEntityByClientId(input.clientId);\r\n\r\n            if (entity) {\r\n                // Store input data for systems to read\r\n                this.inputBuffer.set(input.clientId, input.data);\r\n\r\n                // Apply input to entity's render state for interpolation reference\r\n                const data = input.data;\r\n                if (data) {\r\n                    // Store in entity's input cache for system access\r\n                    entity._setInputData(data);\r\n                }\r\n            }\r\n            // If no entity for this clientId, silently ignore (disconnected player)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get input data for a clientId.\r\n     */\r\n    getInputForClient(clientId: number): Record<string, any> | undefined {\r\n        return this.inputBuffer.get(clientId);\r\n    }\r\n\r\n    /**\r\n     * Check if we have input for a clientId this tick.\r\n     */\r\n    hasInputForClient(clientId: number): boolean {\r\n        return this.inputBuffer.has(clientId);\r\n    }\r\n\r\n    /**\r\n     * Run only physics phase (for external physics integration).\r\n     */\r\n    runPhysics(): void {\r\n        this.scheduler.runPhase('physics');\r\n    }\r\n\r\n    /**\r\n     * Set physics step callback (called during PHYSICS phase).\r\n     */\r\n    setPhysicsStep(fn: () => void): () => void {\r\n        return this.addSystem(fn, { phase: 'physics', order: 0 });\r\n    }\r\n\r\n    /**\r\n     * Save previous positions for interpolation (called in prePhysics).\r\n     */\r\n    saveInterpolationState(): void {\r\n        for (const eid of this.activeEntities) {\r\n            const entity = this.getEntity(eid);\r\n            if (entity) {\r\n                entity._savePreviousState();\r\n            }\r\n        }\r\n    }\r\n\r\n    // ==========================================\r\n    // Client-Side Prediction (Phase 4)\r\n    // ==========================================\r\n\r\n    /** Local client ID for prediction */\r\n    localClientId: number | null = null;\r\n\r\n    /** Pending predictions awaiting server confirmation */\r\n    private predictions: PredictionEntry[] = [];\r\n\r\n    /** Rollback buffer for state restoration */\r\n    private rollbackBuffer: Map<number, SparseSnapshot> = new Map();\r\n\r\n    /** Maximum frames to keep in rollback buffer */\r\n    rollbackBufferSize: number = 60;\r\n\r\n    /** Callback for when rollback occurs */\r\n    onRollback?: (toFrame: number) => void;\r\n\r\n    /** Input history for rollback resimulation */\r\n    private inputHistory: InputHistory = new InputHistory(120);\r\n\r\n    /**\r\n     * Handle local player input (client-side prediction).\r\n     * Applies input immediately for responsiveness.\r\n     */\r\n    handleLocalInput(input: Record<string, any>): void {\r\n        if (this.localClientId === null) {\r\n            console.warn('Cannot handle local input: localClientId not set');\r\n            return;\r\n        }\r\n\r\n        // Apply input immediately (prediction)\r\n        const entity = this.getEntityByClientId(this.localClientId);\r\n        if (entity) {\r\n            entity._setInputData(input);\r\n        }\r\n\r\n        // Store input in history for potential resimulation\r\n        this.inputHistory.setInput(this.frame, this.localClientId, input);\r\n\r\n        // Store prediction for verification\r\n        this.predictions.push({\r\n            frame: this.frame,\r\n            input,\r\n            hash: this.getStateHash()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Process server-confirmed inputs.\r\n     * Detects mispredictions and triggers rollback if needed.\r\n     */\r\n    onServerTick(serverFrame: number, inputs: NetworkInput[]): boolean {\r\n        // Save current state before processing\r\n        this.saveSnapshot(this.frame);\r\n\r\n        // Convert NetworkInput[] to Map for input history\r\n        const inputMap = new Map<number, Record<string, any>>();\r\n        for (const input of inputs) {\r\n            inputMap.set(input.clientId, input.data);\r\n        }\r\n\r\n        // Store confirmed inputs in history for potential resimulation\r\n        this.inputHistory.confirmFrame(serverFrame, inputMap);\r\n\r\n        // Prune old input history to manage memory\r\n        const minFrame = serverFrame - 120;\r\n        if (minFrame > 0) {\r\n            this.inputHistory.prune(minFrame);\r\n        }\r\n\r\n        // Check if we predicted this frame\r\n        const predictionIdx = this.predictions.findIndex(p => p.frame === serverFrame);\r\n\r\n        if (predictionIdx !== -1) {\r\n            // We predicted this frame - verify our prediction was correct\r\n            const prediction = this.predictions[predictionIdx];\r\n\r\n            // Rollback to frame before this tick\r\n            const snapshot = this.rollbackBuffer.get(serverFrame);\r\n            if (snapshot) {\r\n                this.loadSparseSnapshot(snapshot);\r\n            }\r\n\r\n            // Apply server inputs\r\n            this.tick(serverFrame, inputs);\r\n\r\n            // Check if state matches our prediction\r\n            const serverHash = this.getStateHash();\r\n            const mispredicted = serverHash !== prediction.hash;\r\n\r\n            if (mispredicted) {\r\n                // Notify about rollback\r\n                this.onRollback?.(serverFrame);\r\n\r\n                // Resimulate from this frame forward\r\n                this.resimulateFrom(serverFrame);\r\n            }\r\n\r\n            // Remove verified predictions up to this frame\r\n            this.predictions = this.predictions.filter(p => p.frame > serverFrame);\r\n\r\n            return mispredicted;\r\n        } else {\r\n            // We didn't predict this frame, just apply normally\r\n            this.tick(serverFrame, inputs);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save snapshot for potential rollback.\r\n     */\r\n    saveSnapshot(frame: number): void {\r\n        const snapshot = this.getSparseSnapshot();\r\n        this.rollbackBuffer.set(frame, snapshot);\r\n\r\n        // Prune old snapshots\r\n        const minFrame = frame - this.rollbackBufferSize + 1;\r\n        for (const f of this.rollbackBuffer.keys()) {\r\n            if (f < minFrame) {\r\n                this.rollbackBuffer.delete(f);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore state from snapshot at frame.\r\n     */\r\n    restoreSnapshot(frame: number): boolean {\r\n        const snapshot = this.rollbackBuffer.get(frame);\r\n        if (!snapshot) {\r\n            return false;\r\n        }\r\n\r\n        this.loadSparseSnapshot(snapshot);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check if snapshot exists for frame.\r\n     */\r\n    hasSnapshot(frame: number): boolean {\r\n        return this.rollbackBuffer.has(frame);\r\n    }\r\n\r\n    /**\r\n     * Get oldest frame in rollback buffer.\r\n     */\r\n    getOldestSnapshotFrame(): number | undefined {\r\n        let oldest: number | undefined;\r\n        for (const frame of this.rollbackBuffer.keys()) {\r\n            if (oldest === undefined || frame < oldest) {\r\n                oldest = frame;\r\n            }\r\n        }\r\n        return oldest;\r\n    }\r\n\r\n    /**\r\n     * Resimulate from a frame forward to current frame.\r\n     * Uses stored inputs from input history.\r\n     *\r\n     * NOTE: This retrieves data from InputHistory but full tick logic\r\n     * will be implemented in Phase 2 of the rollback implementation plan.\r\n     */\r\n    private resimulateFrom(fromFrame: number): void {\r\n        const currentFrame = this.frame;\r\n\r\n        // Get all frames we need to resimulate (fromFrame+1 to current)\r\n        // We already applied fromFrame, so start at next frame\r\n        const framesToResim = this.inputHistory.getRange(fromFrame + 1, currentFrame);\r\n\r\n        // TODO Phase 2: Actually resimulate each frame\r\n        // For now, just log that we have the data available\r\n        if (framesToResim.length > 0) {\r\n            // Frames are available for resimulation\r\n            // Full implementation will call this.tick() for each frame\r\n            for (const frameInput of framesToResim) {\r\n                // Convert FrameInput to NetworkInput[] format\r\n                const inputs: NetworkInput[] = [];\r\n                for (const [clientId, data] of frameInput.getSortedInputs()) {\r\n                    inputs.push({ clientId, data });\r\n                }\r\n\r\n                // Tick the world with these inputs\r\n                this.tick(frameInput.frame, inputs);\r\n            }\r\n        }\r\n\r\n        // Restore frame counter (tick may have incremented it)\r\n        this.frame = currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Get deterministic hash of world state.\r\n     * Used for comparing state between clients.\r\n     * Excludes components with sync: false (client-only state).\r\n     */\r\n    getStateHash(): string {\r\n        // Get all entity data in deterministic order\r\n        const sortedEids = Array.from(this.activeEntities).sort((a, b) => a - b);\r\n\r\n        let hash = 0;\r\n\r\n        for (const eid of sortedEids) {\r\n            const index = eid & INDEX_MASK;\r\n            const components = this.entityComponents.get(eid) || [];\r\n\r\n            // Hash eid\r\n            hash = (hash * 31 + eid) | 0;\r\n\r\n            // Hash each component's fields in deterministic order\r\n            for (const component of components) {\r\n                // Skip components that are not synced (client-only state)\r\n                if (!component.sync) continue;\r\n\r\n                const fieldNames = [...component.fieldNames].sort();\r\n                for (const fieldName of fieldNames) {\r\n                    const arr = component.storage.fields[fieldName];\r\n                    const value = arr[index];\r\n                    hash = (hash * 31 + value) | 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Convert to hex string\r\n        return (hash >>> 0).toString(16).padStart(8, '0');\r\n    }\r\n\r\n    /**\r\n     * Clear rollback buffer.\r\n     */\r\n    clearRollbackBuffer(): void {\r\n        this.rollbackBuffer.clear();\r\n        this.predictions = [];\r\n    }\r\n\r\n    /**\r\n     * Get pending prediction count.\r\n     */\r\n    getPendingPredictionCount(): number {\r\n        return this.predictions.length;\r\n    }\r\n\r\n    /**\r\n     * Check if we have pending predictions.\r\n     */\r\n    hasPendingPredictions(): boolean {\r\n        return this.predictions.length > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Network input format.\r\n */\r\nexport interface NetworkInput {\r\n    clientId: number;\r\n    data: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Prediction entry for tracking local predictions.\r\n */\r\nexport interface PredictionEntry {\r\n    frame: number;\r\n    input: Record<string, any>;\r\n    hash: string;\r\n}\r\n\r\n/**\r\n * World state for snapshotting.\r\n */\r\nexport interface WorldState {\r\n    entities: EntityState[];\r\n    allocator: EntityIdAllocatorState;\r\n    strings: {\r\n        tables: Record<string, Record<string, number>>;\r\n        nextIds: Record<string, number>;\r\n    };\r\n}\r\n\r\n/**\r\n * Entity state for snapshotting.\r\n */\r\nexport interface EntityState {\r\n    eid: number;\r\n    type: string;\r\n    components: Record<string, Record<string, number>>;\r\n    clientId?: number;\r\n}\r\n", "/**\r\n * Codec Module\r\n *\r\n * Binary encoding/decoding for network communication.\r\n */\r\n\r\nexport { encode, decode } from './binary';\r\n", "/**\r\n * Binary Codec\r\n *\r\n * Compact binary encoding for arbitrary JSON-like data.\r\n * Used for inputs, snapshots, and all engine-network communication.\r\n */\r\n\r\n// Type markers\r\nconst TYPE_NULL = 0x00;\r\nconst TYPE_FALSE = 0x01;\r\nconst TYPE_TRUE = 0x02;\r\nconst TYPE_INT8 = 0x03;\r\nconst TYPE_INT16 = 0x04;\r\nconst TYPE_INT32 = 0x05;\r\nconst TYPE_FLOAT64 = 0x06;\r\nconst TYPE_STRING = 0x07;\r\nconst TYPE_ARRAY = 0x08;\r\nconst TYPE_OBJECT = 0x09;\r\nconst TYPE_UINT8 = 0x0A;\r\nconst TYPE_UINT16 = 0x0B;\r\nconst TYPE_UINT32 = 0x0C;\r\n\r\n/**\r\n * Binary encoder - accumulates bytes\r\n */\r\nclass BinaryEncoder {\r\n    private buffer: number[] = [];\r\n\r\n    writeByte(b: number): void {\r\n        this.buffer.push(b & 0xFF);\r\n    }\r\n\r\n    writeUint16(n: number): void {\r\n        this.buffer.push((n >> 8) & 0xFF);\r\n        this.buffer.push(n & 0xFF);\r\n    }\r\n\r\n    writeUint32(n: number): void {\r\n        this.buffer.push((n >> 24) & 0xFF);\r\n        this.buffer.push((n >> 16) & 0xFF);\r\n        this.buffer.push((n >> 8) & 0xFF);\r\n        this.buffer.push(n & 0xFF);\r\n    }\r\n\r\n    writeInt32(n: number): void {\r\n        this.writeUint32(n >>> 0);\r\n    }\r\n\r\n    writeFloat64(n: number): void {\r\n        const view = new DataView(new ArrayBuffer(8));\r\n        view.setFloat64(0, n, false); // big-endian\r\n        for (let i = 0; i < 8; i++) {\r\n            this.buffer.push(view.getUint8(i));\r\n        }\r\n    }\r\n\r\n    writeString(s: string): void {\r\n        const encoded = new TextEncoder().encode(s);\r\n        this.writeUint16(encoded.length);\r\n        for (let i = 0; i < encoded.length; i++) {\r\n            this.buffer.push(encoded[i]);\r\n        }\r\n    }\r\n\r\n    writeValue(value: any): void {\r\n        if (value === null || value === undefined) {\r\n            this.writeByte(TYPE_NULL);\r\n        } else if (value === false) {\r\n            this.writeByte(TYPE_FALSE);\r\n        } else if (value === true) {\r\n            this.writeByte(TYPE_TRUE);\r\n        } else if (typeof value === 'number') {\r\n            if (Number.isInteger(value)) {\r\n                if (value >= 0 && value <= 255) {\r\n                    this.writeByte(TYPE_UINT8);\r\n                    this.writeByte(value);\r\n                } else if (value >= 0 && value <= 65535) {\r\n                    this.writeByte(TYPE_UINT16);\r\n                    this.writeUint16(value);\r\n                } else if (value >= -2147483648 && value <= 2147483647) {\r\n                    this.writeByte(TYPE_INT32);\r\n                    this.writeInt32(value);\r\n                } else {\r\n                    this.writeByte(TYPE_FLOAT64);\r\n                    this.writeFloat64(value);\r\n                }\r\n            } else {\r\n                this.writeByte(TYPE_FLOAT64);\r\n                this.writeFloat64(value);\r\n            }\r\n        } else if (typeof value === 'string') {\r\n            this.writeByte(TYPE_STRING);\r\n            this.writeString(value);\r\n        } else if (Array.isArray(value)) {\r\n            this.writeByte(TYPE_ARRAY);\r\n            this.writeUint16(value.length);\r\n            for (const item of value) {\r\n                this.writeValue(item);\r\n            }\r\n        } else if (typeof value === 'object') {\r\n            this.writeByte(TYPE_OBJECT);\r\n            const keys = Object.keys(value);\r\n            this.writeUint16(keys.length);\r\n            for (const key of keys) {\r\n                this.writeString(key);\r\n                this.writeValue(value[key]);\r\n            }\r\n        } else {\r\n            // Unknown type - encode as null\r\n            this.writeByte(TYPE_NULL);\r\n        }\r\n    }\r\n\r\n    toUint8Array(): Uint8Array {\r\n        return new Uint8Array(this.buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * Binary decoder - reads bytes\r\n */\r\nclass BinaryDecoder {\r\n    private data: Uint8Array;\r\n    private pos: number = 0;\r\n\r\n    constructor(data: Uint8Array) {\r\n        this.data = data;\r\n    }\r\n\r\n    readByte(): number {\r\n        return this.data[this.pos++];\r\n    }\r\n\r\n    readUint16(): number {\r\n        const b1 = this.data[this.pos++];\r\n        const b2 = this.data[this.pos++];\r\n        return (b1 << 8) | b2;\r\n    }\r\n\r\n    readUint32(): number {\r\n        const b1 = this.data[this.pos++];\r\n        const b2 = this.data[this.pos++];\r\n        const b3 = this.data[this.pos++];\r\n        const b4 = this.data[this.pos++];\r\n        return ((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) >>> 0;\r\n    }\r\n\r\n    readInt32(): number {\r\n        const u = this.readUint32();\r\n        return u > 0x7FFFFFFF ? u - 0x100000000 : u;\r\n    }\r\n\r\n    readFloat64(): number {\r\n        const view = new DataView(new ArrayBuffer(8));\r\n        for (let i = 0; i < 8; i++) {\r\n            view.setUint8(i, this.data[this.pos++]);\r\n        }\r\n        return view.getFloat64(0, false);\r\n    }\r\n\r\n    readString(): string {\r\n        const len = this.readUint16();\r\n        const bytes = this.data.slice(this.pos, this.pos + len);\r\n        this.pos += len;\r\n        return new TextDecoder().decode(bytes);\r\n    }\r\n\r\n    readValue(): any {\r\n        const type = this.readByte();\r\n\r\n        switch (type) {\r\n            case TYPE_NULL:\r\n                return null;\r\n            case TYPE_FALSE:\r\n                return false;\r\n            case TYPE_TRUE:\r\n                return true;\r\n            case TYPE_UINT8:\r\n                return this.readByte();\r\n            case TYPE_UINT16:\r\n                return this.readUint16();\r\n            case TYPE_INT32:\r\n                return this.readInt32();\r\n            case TYPE_UINT32:\r\n                return this.readUint32();\r\n            case TYPE_FLOAT64:\r\n                return this.readFloat64();\r\n            case TYPE_STRING:\r\n                return this.readString();\r\n            case TYPE_ARRAY: {\r\n                const len = this.readUint16();\r\n                const arr = [];\r\n                for (let i = 0; i < len; i++) {\r\n                    arr.push(this.readValue());\r\n                }\r\n                return arr;\r\n            }\r\n            case TYPE_OBJECT: {\r\n                const len = this.readUint16();\r\n                const obj: Record<string, any> = {};\r\n                for (let i = 0; i < len; i++) {\r\n                    const key = this.readString();\r\n                    obj[key] = this.readValue();\r\n                }\r\n                return obj;\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Encode any JSON-compatible value to binary.\r\n */\r\nexport function encode(value: any): Uint8Array {\r\n    const encoder = new BinaryEncoder();\r\n    encoder.writeValue(value);\r\n    return encoder.toUint8Array();\r\n}\r\n\r\n/**\r\n * Decode binary data to a value.\r\n */\r\nexport function decode(data: Uint8Array): any {\r\n    const decoder = new BinaryDecoder(data);\r\n    return decoder.readValue();\r\n}\r\n", "/**\r\n * Game - High-level wrapper for ECS World with Network Integration\r\n *\r\n * Provides the game API that examples use:\r\n * - game.defineEntity(name) \u2192 EntityBuilder\r\n * - game.spawn(type, props) \u2192 Entity\r\n * - game.query(type) \u2192 Iterator\r\n * - game.addSystem(fn, options)\r\n * - game.physics \u2192 Physics2D integration\r\n * - game.connect() \u2192 Network connection with rollback sync\r\n */\r\n\r\nimport { World, EntityBuilder, NetworkInput } from './core/world';\r\nimport { Entity } from './core/entity';\r\nimport { ComponentType } from './core/component';\r\nimport { SystemFn, SystemOptions } from './core/system';\r\nimport { Transform2D, Body2D, Player } from './components';\r\nimport { SparseSnapshot } from './core/snapshot';\r\nimport { QueryIterator } from './core/query';\r\nimport { encode, decode } from './codec';\r\nimport { loadRandomState, saveRandomState } from './math/random';\r\nimport { INDEX_MASK } from './core/constants';\r\n\r\n// ==========================================\r\n// Types\r\n// ==========================================\r\n\r\n/** Physics system interface */\r\ninterface Physics2DLike {\r\n    physicsWorld: any;\r\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this;\r\n    setGravity(x: number, y: number): this;\r\n    getBody(entity: Entity): any;\r\n    clear(): void;\r\n    wakeAllBodies(): void;\r\n}\r\n\r\n/** Network connection interface (from modu-network SDK) */\r\ninterface Connection {\r\n    send(data: any): void;\r\n    sendSnapshot(snapshot: any, hash: string, seq?: number, frame?: number): void;\r\n    leaveRoom(): void;\r\n    clientId: string | null;\r\n    totalBytesIn: number;\r\n    totalBytesOut: number;\r\n    bandwidthIn: number;\r\n    bandwidthOut: number;\r\n}\r\n\r\n/** Network SDK interface */\r\ninterface NetworkSDK {\r\n    connect(roomId: string, options: any): Promise<Connection>;\r\n}\r\n\r\n/** Network input from server */\r\ninterface ServerInput {\r\n    seq: number;\r\n    clientId: string;\r\n    data: any;\r\n    frame?: number;\r\n}\r\n\r\n/** Game callbacks for lifecycle events */\r\nexport interface GameCallbacks {\r\n    /** Called when room is first created (first client joins) */\r\n    onRoomCreate?(): void;\r\n    /** Called when a client connects */\r\n    onConnect?(clientId: string): void;\r\n    /** Called when a client disconnects */\r\n    onDisconnect?(clientId: string): void;\r\n    /** Called after snapshot restore with all restored entities */\r\n    onSnapshot?(entities: Entity[]): void;\r\n    /** Called each game tick */\r\n    onTick?(frame: number): void;\r\n    /** Called each render frame */\r\n    render?(): void;\r\n}\r\n\r\n/** Connection options */\r\nexport interface ConnectOptions {\r\n    /** Direct node URL (bypasses central service) */\r\n    nodeUrl?: string;\r\n    /** Central service URL */\r\n    centralServiceUrl?: string;\r\n    /** JWT token for authentication */\r\n    joinToken?: string;\r\n}\r\n\r\n// Debug flag - set to false for production\r\nconst DEBUG_NETWORK = false;\r\n\r\n// ==========================================\r\n// Prefab Class\r\n// ==========================================\r\n\r\n/**\r\n * Prefab - spawnable entity definition\r\n */\r\nexport class Prefab {\r\n    constructor(\r\n        private game: Game,\r\n        private typeName: string,\r\n        private builder: EntityBuilder\r\n    ) {}\r\n\r\n    /**\r\n     * Spawn a new entity from this prefab.\r\n     */\r\n    spawn(props: Record<string, any> = {}): Entity {\r\n        return this.game.spawn(this.typeName, props);\r\n    }\r\n}\r\n\r\n// ==========================================\r\n// Game Class\r\n// ==========================================\r\n\r\n/**\r\n * Game class - main entry point for games using the ECS.\r\n */\r\nexport class Game {\r\n    /** ECS World instance */\r\n    readonly world: World;\r\n\r\n    /** Physics system (optional) */\r\n    physics: Physics2DLike | null = null;\r\n\r\n    // ==========================================\r\n    // Network State\r\n    // ==========================================\r\n\r\n    /** WebSocket connection */\r\n    private connection: Connection | null = null;\r\n\r\n    /** Game callbacks */\r\n    private callbacks: GameCallbacks = {};\r\n\r\n    /** Connected room ID */\r\n    private connectedRoomId: string | null = null;\r\n\r\n    /** Local client ID (string form) */\r\n    private localClientIdStr: string | null = null;\r\n\r\n    /** All connected client IDs (in join order for determinism) */\r\n    private connectedClients: string[] = [];\r\n\r\n    /** Authority client (first joiner, sends snapshots) */\r\n    private authorityClientId: string | null = null;\r\n\r\n    /** Current server frame */\r\n    private currentFrame: number = 0;\r\n\r\n    /** Last processed frame (for skipping old frames after catchup) */\r\n    private lastProcessedFrame: number = 0;\r\n\r\n    /** Last processed input sequence */\r\n    private lastInputSeq: number = 0;\r\n\r\n    /** Server tick rate */\r\n    private serverFps: number = 20;\r\n\r\n    /** RequestAnimationFrame handle */\r\n    private gameLoop: number | null = null;\r\n\r\n    /** Deferred snapshot flag (send after tick completes) */\r\n    private pendingSnapshotUpload: boolean = false;\r\n\r\n    /** Last snapshot info for debug UI */\r\n    private lastSnapshotHash: string | null = null;\r\n    private lastSnapshotFrame: number = 0;\r\n    private lastSnapshotSize: number = 0;\r\n    private lastSnapshotEntityCount: number = 0;\r\n\r\n    /** Drift tracking stats for debug UI */\r\n    private driftStats = {\r\n        determinismPercent: 100,\r\n        totalChecks: 0,\r\n        matchingFieldCount: 0,\r\n        totalFieldCount: 0\r\n    };\r\n\r\n    /** Divergence tracking */\r\n    private lastSyncPercent: number = 100;\r\n    private firstDivergenceFrame: number | null = null;\r\n    private divergenceHistory: Array<{ frame: number; field: string; local: any; server: any; delta?: number }> = [];\r\n    private recentInputs: Array<{ frame: number; seq: number; clientId: string; data: any }> = [];\r\n    private lastServerSnapshot: { raw: Uint8Array | null; decoded: any; frame: number } = { raw: null, decoded: null, frame: 0 };\r\n    private lastGoodSnapshot: { snapshot: any; frame: number; hash: string } | null = null;\r\n    private divergenceCaptured: boolean = false;\r\n    private divergenceCapture: {\r\n        lastGoodSnapshot: any;\r\n        lastGoodFrame: number;\r\n        inputs: Array<{ frame: number; seq: number; clientId: string; data: any }>;\r\n        localSnapshot: any;\r\n        serverSnapshot: any;\r\n        diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }>;\r\n        divergenceFrame: number;\r\n        clientId: string | null;\r\n        isAuthority: boolean;\r\n    } | null = null;\r\n\r\n    /** Tick timing for render interpolation */\r\n    private lastTickTime: number = 0;\r\n    private tickIntervalMs: number = 50; // 20fps default\r\n\r\n    // ==========================================\r\n    // String Interning\r\n    // ==========================================\r\n\r\n    /** String to ID mapping for clientIds */\r\n    private clientIdToNum: Map<string, number> = new Map();\r\n    private numToClientId: Map<number, string> = new Map();\r\n    private nextClientNum: number = 1;\r\n\r\n    /** Prefab registry */\r\n    private prefabs: Map<string, Prefab> = new Map();\r\n\r\n    /** Collision handlers (type:type -> handler) */\r\n    private collisionHandlers: Map<string, (a: Entity, b: Entity) => void> = new Map();\r\n\r\n    /** Clients that already have entities from snapshot (skip onConnect for them during catchup) */\r\n    private clientsWithEntitiesFromSnapshot: Set<string> = new Set();\r\n\r\n    /** Attached renderer */\r\n    private renderer: any = null;\r\n\r\n    /** Installed plugins */\r\n    private plugins: Map<string, any> = new Map();\r\n\r\n    constructor() {\r\n        this.world = new World();\r\n    }\r\n\r\n    // ==========================================\r\n    // Plugin API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Add a plugin to the game.\r\n     *\r\n     * Plugins can be classes or factory functions that integrate with the game.\r\n     * Common plugins include Physics2DSystem and AutoRenderer.\r\n     *\r\n     * @example\r\n     * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\r\n     * game.addPlugin(AutoRenderer, canvas);\r\n     *\r\n     * @param Plugin - Plugin class or factory\r\n     * @param args - Arguments to pass to the plugin constructor\r\n     * @returns The created plugin instance\r\n     */\r\n    addPlugin<T>(\r\n        Plugin: new (game: Game, ...args: any[]) => T,\r\n        ...args: any[]\r\n    ): T {\r\n        const plugin = new Plugin(this, ...args);\r\n        const name = Plugin.name || 'anonymous';\r\n        this.plugins.set(name, plugin);\r\n        return plugin;\r\n    }\r\n\r\n    /**\r\n     * Get a previously added plugin by class.\r\n     */\r\n    getPlugin<T>(Plugin: new (...args: any[]) => T): T | undefined {\r\n        return this.plugins.get(Plugin.name) as T | undefined;\r\n    }\r\n\r\n    /**\r\n     * Current frame number.\r\n     */\r\n    get frame(): number {\r\n        return this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Deterministic time in milliseconds.\r\n     * Use this instead of Date.now() for game logic.\r\n     *\r\n     * @example\r\n     * const RESPAWN_TIME = 3000; // 3 seconds\r\n     * deadPlayers.set(clientId, game.time + RESPAWN_TIME);\r\n     * if (game.time >= respawnTime) spawnPlayer(clientId);\r\n     */\r\n    get time(): number {\r\n        return this.currentFrame * this.tickIntervalMs;\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Definition API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Define a new entity type.\r\n     *\r\n     * @example\r\n     * const Cell = game.defineEntity('cell')\r\n     *     .with(Transform2D)\r\n     *     .with(Body2D, { shapeType: 1, radius: 20 })\r\n     *     .with(Player);\r\n     */\r\n    defineEntity(name: string): GameEntityBuilder {\r\n        return new GameEntityBuilder(this, name);\r\n    }\r\n\r\n    /**\r\n     * Register a prefab (internal).\r\n     */\r\n    _registerPrefab(name: string, builder: EntityBuilder): Prefab {\r\n        const prefab = new Prefab(this, name, builder);\r\n        this.prefabs.set(name, prefab);\r\n        return prefab;\r\n    }\r\n\r\n    // ==========================================\r\n    // Entity Spawning\r\n    // ==========================================\r\n\r\n    /**\r\n     * Spawn an entity.\r\n     *\r\n     * @param type Entity type name\r\n     * @param props Property overrides\r\n     */\r\n    spawn(type: string, props: Record<string, any> = {}): Entity {\r\n        // Convert string clientId to number\r\n        let numericProps = { ...props };\r\n        if (props.clientId && typeof props.clientId === 'string') {\r\n            numericProps.clientId = this.internClientId(props.clientId);\r\n        }\r\n\r\n        return this.world.spawn(type, numericProps);\r\n    }\r\n\r\n    /**\r\n     * Get a prefab by name.\r\n     */\r\n    getPrefab(name: string): Prefab | undefined {\r\n        return this.prefabs.get(name);\r\n    }\r\n\r\n    // ==========================================\r\n    // Query API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Query entities by type.\r\n     */\r\n    query(type: string): QueryIterator<Entity> {\r\n        return this.world.query(type);\r\n    }\r\n\r\n    /**\r\n     * Get entities by type as array.\r\n     */\r\n    getEntitiesByType(type: string): Entity[] {\r\n        return this.world.query(type).toArray();\r\n    }\r\n\r\n    /**\r\n     * Get all entities.\r\n     */\r\n    getAllEntities(): Entity[] {\r\n        return this.world.getAllEntities();\r\n    }\r\n\r\n    /**\r\n     * Get entity by client ID.\r\n     */\r\n    getEntityByClientId(clientId: string): Entity | null {\r\n        const numId = this.clientIdToNum.get(clientId);\r\n        if (numId === undefined) return null;\r\n        return this.world.getEntityByClientId(numId);\r\n    }\r\n\r\n    /**\r\n     * Get player by client ID (alias for getEntityByClientId).\r\n     */\r\n    getPlayer(clientId: string): Entity | null {\r\n        return this.getEntityByClientId(clientId);\r\n    }\r\n\r\n    /**\r\n     * Get all players (entities with Player component).\r\n     */\r\n    getPlayers(): Entity[] {\r\n        return this.world.query(Player).toArray();\r\n    }\r\n\r\n    // ==========================================\r\n    // System API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Add a system.\r\n     */\r\n    addSystem(fn: SystemFn, options?: SystemOptions): () => void {\r\n        return this.world.addSystem(fn, options);\r\n    }\r\n\r\n    // ==========================================\r\n    // Collision API\r\n    // ==========================================\r\n\r\n    /**\r\n     * Register a collision handler.\r\n     */\r\n    onCollision(typeA: string, typeB: string, handler: (a: Entity, b: Entity) => void): this {\r\n        if (this.physics) {\r\n            this.physics.onCollision(typeA, typeB, handler);\r\n        } else {\r\n            const key = `${typeA}:${typeB}`;\r\n            this.collisionHandlers.set(key, handler);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // ==========================================\r\n    // String Interning\r\n    // ==========================================\r\n\r\n    /**\r\n     * Intern a client ID string, get back a number.\r\n     */\r\n    internClientId(clientId: string): number {\r\n        let num = this.clientIdToNum.get(clientId);\r\n        if (num === undefined) {\r\n            num = this.nextClientNum++;\r\n            this.clientIdToNum.set(clientId, num);\r\n            this.numToClientId.set(num, clientId);\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * Get client ID string from number.\r\n     */\r\n    getClientIdString(num: number): string | undefined {\r\n        return this.numToClientId.get(num);\r\n    }\r\n\r\n    /**\r\n     * Intern any string in a namespace.\r\n     */\r\n    internString(namespace: string, str: string): number {\r\n        return this.world.internString(namespace, str);\r\n    }\r\n\r\n    /**\r\n     * Get string by ID from namespace.\r\n     */\r\n    getString(namespace: string, id: number): string | null {\r\n        return this.world.getString(namespace, id);\r\n    }\r\n\r\n    // ==========================================\r\n    // State Management\r\n    // ==========================================\r\n\r\n    /**\r\n     * Get deterministic state hash.\r\n     */\r\n    getStateHash(): string {\r\n        return this.world.getStateHash();\r\n    }\r\n\r\n    /**\r\n     * Reset game state.\r\n     */\r\n    reset(): void {\r\n        this.world.reset();\r\n        this.currentFrame = 0;\r\n    }\r\n\r\n    // ==========================================\r\n    // Network Connection\r\n    // ==========================================\r\n\r\n    /**\r\n     * Connect to a multiplayer room.\r\n     */\r\n    async connect(\r\n        roomId: string,\r\n        callbacks: GameCallbacks,\r\n        options: ConnectOptions = {}\r\n    ): Promise<void> {\r\n        this.callbacks = callbacks;\r\n\r\n        // Allow URL params to override (for testing)\r\n        if (typeof window !== 'undefined') {\r\n            const params = new URLSearchParams(window.location.search);\r\n            if (params.get('room')) roomId = params.get('room')!;\r\n            if (params.get('nodeUrl')) options.nodeUrl = params.get('nodeUrl')!;\r\n        }\r\n\r\n        this.connectedRoomId = roomId;\r\n\r\n        // Get network SDK\r\n        const network: NetworkSDK = (window as any).moduNetwork;\r\n        if (!network) {\r\n            throw new Error('moduNetwork not found. Include modu-network SDK before calling connect().');\r\n        }\r\n\r\n        console.log(`[ecs] Connecting to room \"${roomId}\"...`);\r\n\r\n        try {\r\n            this.connection = await network.connect(roomId, {\r\n                nodeUrl: options.nodeUrl,\r\n                centralServiceUrl: options.centralServiceUrl,\r\n                appId: 'dev',\r\n                joinToken: options.joinToken,\r\n\r\n                onConnect: (\r\n                    snapshot: any,\r\n                    inputs: ServerInput[],\r\n                    frame: number,\r\n                    nodeUrl: string | null,\r\n                    fps: number,\r\n                    clientId: string\r\n                ) => {\r\n                    this.handleConnect(snapshot, inputs, frame, fps, clientId);\r\n                },\r\n\r\n                onTick: (frame: number, inputs: ServerInput[]) => {\r\n                    this.handleTick(frame, inputs);\r\n                },\r\n\r\n                onDisconnect: () => {\r\n                    this.handleDisconnect();\r\n                },\r\n\r\n                onBinarySnapshot: (data: Uint8Array) => {\r\n                    this.handleServerSnapshot(data);\r\n                },\r\n\r\n                onError: (error: string) => {\r\n                    console.error('[ecs] Network error:', error);\r\n                }\r\n            });\r\n\r\n            this.localClientIdStr = this.connection.clientId;\r\n        } catch (err: any) {\r\n            console.warn('[ecs] Connection failed:', err?.message || err);\r\n            this.connection = null;\r\n            this.connectedRoomId = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle initial connection (first join or late join).\r\n     */\r\n    private handleConnect(\r\n        snapshot: any,\r\n        inputs: ServerInput[],\r\n        frame: number,\r\n        fps: number,\r\n        clientId: string\r\n    ): void {\r\n        // Decode binary snapshot if needed\r\n        let snapshotSize = 0;\r\n        if (snapshot instanceof Uint8Array) {\r\n            snapshotSize = snapshot.length;\r\n            if (snapshot.length < 2) {\r\n                snapshot = null;\r\n            } else {\r\n                try {\r\n                    snapshot = decode(snapshot)?.snapshot || null;\r\n                } catch (e) {\r\n                    console.error('[ecs] Failed to decode snapshot:', e);\r\n                    snapshot = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store connection state\r\n        this.localClientIdStr = clientId;\r\n        this.serverFps = fps;\r\n        this.tickIntervalMs = 1000 / fps;\r\n        this.currentFrame = frame;\r\n\r\n        // Store snapshot hash for debug UI\r\n        if (snapshot?.hash !== undefined) {\r\n            this.lastSnapshotHash = typeof snapshot.hash === 'number'\r\n                ? snapshot.hash.toString(16).padStart(8, '0')\r\n                : String(snapshot.hash);\r\n            this.lastSnapshotFrame = snapshot.frame || frame;\r\n            this.lastSnapshotSize = snapshotSize;\r\n            this.lastSnapshotEntityCount = snapshot.entities?.length || 0;\r\n        }\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Connected as ${clientId}, frame ${frame}, fps ${fps}`);\r\n            console.log(`[ecs] Snapshot:`, snapshot ? { frame: snapshot.frame, entityCount: snapshot.entities?.length } : 'none');\r\n            console.log(`[ecs] Inputs: ${inputs.length}`);\r\n        }\r\n\r\n        const hasValidSnapshot = snapshot?.entities && snapshot.entities.length > 0;\r\n\r\n        if (hasValidSnapshot) {\r\n            // === LATE JOINER PATH ===\r\n            if (DEBUG_NETWORK) console.log(`[ecs] Late join: restoring snapshot frame=${snapshot.frame}`);\r\n\r\n            // 1. Restore snapshot\r\n            this.currentFrame = snapshot.frame || frame;\r\n            this.loadNetworkSnapshot(snapshot);\r\n\r\n            // 2. Build authority chain from ALL inputs\r\n            for (const input of inputs) {\r\n                this.processAuthorityChainInput(input);\r\n            }\r\n\r\n            // 3. Call onSnapshot callback\r\n            if (this.callbacks.onSnapshot) {\r\n                this.callbacks.onSnapshot(this.world.getAllEntities());\r\n            }\r\n\r\n            // 4. Filter inputs already in snapshot\r\n            const snapshotSeq = snapshot.seq || 0;\r\n            const pendingInputs = inputs\r\n                .filter(i => i.seq > snapshotSeq)\r\n                .sort((a, b) => a.seq - b.seq);\r\n\r\n            // 5. Run catchup simulation\r\n            const snapshotFrame = this.currentFrame;\r\n            const isPostTick = snapshot.postTick === true;\r\n            const startFrame = isPostTick ? snapshotFrame + 1 : snapshotFrame;\r\n            const ticksToRun = frame - startFrame + 1;\r\n\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Catchup: from ${startFrame} to ${frame} (${ticksToRun} ticks), ${pendingInputs.length} pending inputs`);\r\n            }\r\n\r\n            if (ticksToRun > 0) {\r\n                this.runCatchup(startFrame, frame, pendingInputs);\r\n            }\r\n\r\n            // Store as last good snapshot - we just loaded authority's state\r\n            this.lastGoodSnapshot = {\r\n                snapshot: JSON.parse(JSON.stringify(snapshot)),\r\n                frame: this.currentFrame,\r\n                hash: this.getStateHash()\r\n            };\r\n        } else {\r\n            // === FIRST JOINER PATH ===\r\n            if (DEBUG_NETWORK) console.log('[ecs] First join: creating room');\r\n\r\n            this.currentFrame = frame;\r\n            this.callbacks.onRoomCreate?.();\r\n\r\n            // Process all inputs\r\n            for (const input of inputs) {\r\n                this.processInput(input);\r\n            }\r\n        }\r\n\r\n        // Send initial snapshot if we're authority\r\n        if (this.checkIsAuthority()) {\r\n            this.sendSnapshot('init');\r\n        }\r\n\r\n        // Start game loop\r\n        this.startGameLoop();\r\n        if (DEBUG_NETWORK) console.log('[ecs] Game loop started');\r\n    }\r\n\r\n    /**\r\n     * Handle server tick.\r\n     */\r\n    private handleTick(frame: number, inputs: ServerInput[]): void {\r\n        // Skip frames we've already processed (e.g., during catchup)\r\n        if (frame <= this.lastProcessedFrame) {\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Skipping old frame ${frame} (already at ${this.lastProcessedFrame})`);\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.currentFrame = frame;\r\n        this.lastProcessedFrame = frame;\r\n\r\n        if (DEBUG_NETWORK && inputs.length > 0) {\r\n            const types = inputs.map(i => i.data?.type || 'game').join(',');\r\n            console.log(`[ecs] onTick frame=${frame}: ${inputs.length} inputs (${types})`);\r\n        }\r\n\r\n        // 1. Process all inputs for this frame (sorted by seq for determinism)\r\n        // Multiple inputs can arrive in a single tick - seq determines order\r\n        const sortedInputs = inputs.length > 1\r\n            ? [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0))\r\n            : inputs;\r\n        for (const input of sortedInputs) {\r\n            this.processInput(input);\r\n        }\r\n\r\n        // 2. Run ECS world tick (systems)\r\n        this.world.tick(frame, []);\r\n\r\n        // 3. Call game's onTick callback\r\n        this.callbacks.onTick?.(frame);\r\n\r\n        // 4. Send deferred snapshot if pending\r\n        if (this.pendingSnapshotUpload && this.checkIsAuthority()) {\r\n            this.sendSnapshot('join');\r\n            this.pendingSnapshotUpload = false;\r\n        }\r\n\r\n        // 5. Record tick time for interpolation\r\n        this.lastTickTime = typeof performance !== 'undefined' ? performance.now() : Date.now();\r\n    }\r\n\r\n    /**\r\n     * Process a network input (join/leave/game).\r\n     */\r\n    private processInput(input: ServerInput): void {\r\n        // Decode binary data if needed\r\n        let data = input.data;\r\n        if (data instanceof Uint8Array) {\r\n            try {\r\n                data = decode(data);\r\n            } catch (e) {\r\n                console.warn('[ecs] Failed to decode input:', e);\r\n                return;\r\n            }\r\n        }\r\n\r\n        const clientId = data?.clientId || input.clientId;\r\n        const type = data?.type;\r\n\r\n        // Track input for divergence debugging (keep last 500)\r\n        this.recentInputs.push({\r\n            frame: this.currentFrame,\r\n            seq: input.seq,\r\n            clientId,\r\n            data: JSON.parse(JSON.stringify(data))\r\n        });\r\n        if (this.recentInputs.length > 500) {\r\n            this.recentInputs.shift();\r\n        }\r\n\r\n        // Track input sequence\r\n        if (input.seq > this.lastInputSeq) {\r\n            this.lastInputSeq = input.seq;\r\n        }\r\n\r\n        if (type === 'join') {\r\n            // Track connected clients\r\n            if (!this.connectedClients.includes(clientId)) {\r\n                this.connectedClients.push(clientId);\r\n            }\r\n\r\n            // First joiner becomes authority\r\n            if (this.authorityClientId === null) {\r\n                this.authorityClientId = clientId;\r\n            }\r\n\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Join: ${clientId.slice(0, 8)}, authority=${this.authorityClientId?.slice(0, 8)}`);\r\n            }\r\n\r\n            // Call callback ONLY if this client doesn't already have an entity from snapshot\r\n            // This prevents duplicate entity creation during catchup\r\n            if (this.clientsWithEntitiesFromSnapshot.has(clientId)) {\r\n                if (DEBUG_NETWORK) {\r\n                    console.log(`[ecs] Skipping onConnect for ${clientId.slice(0, 8)} - already has entity from snapshot`);\r\n                }\r\n            } else {\r\n                this.callbacks.onConnect?.(clientId);\r\n            }\r\n\r\n            // Mark snapshot needed\r\n            if (this.checkIsAuthority()) {\r\n                this.pendingSnapshotUpload = true;\r\n            }\r\n        } else if (type === 'leave' || type === 'disconnect') {\r\n            // Remove from connected clients\r\n            const idx = this.connectedClients.indexOf(clientId);\r\n            if (idx !== -1) {\r\n                this.connectedClients.splice(idx, 1);\r\n            }\r\n\r\n            // Transfer authority if needed\r\n            if (clientId === this.authorityClientId) {\r\n                this.authorityClientId = this.connectedClients[0] || null;\r\n            }\r\n\r\n            if (DEBUG_NETWORK) {\r\n                console.log(`[ecs] Leave: ${clientId.slice(0, 8)}, new authority=${this.authorityClientId?.slice(0, 8)}`);\r\n            }\r\n\r\n            // Call callback\r\n            this.callbacks.onDisconnect?.(clientId);\r\n        } else if (data) {\r\n            // Game input - store in world's input registry\r\n            this.routeInputToEntity(clientId, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Route game input to the world's input registry for systems to read.\r\n     */\r\n    private routeInputToEntity(clientId: string, data: any): void {\r\n        const numId = this.internClientId(clientId);\r\n\r\n        // Use O(1) clientId index lookup instead of iterating\r\n        const entity = this.world.getEntityByClientId(numId);\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] routeInput: clientId=${clientId.slice(0, 8)}, numId=${numId}, entity=${entity?.eid || 'null'}, data=${JSON.stringify(data)}`);\r\n        }\r\n        if (entity) {\r\n            // Store input in world's input registry for systems to read\r\n            this.world.setInput(numId, data);\r\n        } else if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] WARNING: No entity for clientId ${clientId.slice(0, 8)} (numId=${numId})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process input for authority chain only (no game logic).\r\n     */\r\n    private processAuthorityChainInput(input: ServerInput): void {\r\n        let data = input.data;\r\n        if (data instanceof Uint8Array) {\r\n            try { data = decode(data); } catch { return; }\r\n        }\r\n\r\n        const clientId = data?.clientId || input.clientId;\r\n        const type = data?.type;\r\n\r\n        if (type === 'join') {\r\n            if (!this.connectedClients.includes(clientId)) {\r\n                this.connectedClients.push(clientId);\r\n            }\r\n            if (this.authorityClientId === null) {\r\n                this.authorityClientId = clientId;\r\n            }\r\n        } else if (type === 'leave' || type === 'disconnect') {\r\n            const idx = this.connectedClients.indexOf(clientId);\r\n            if (idx !== -1) {\r\n                this.connectedClients.splice(idx, 1);\r\n            }\r\n            if (clientId === this.authorityClientId) {\r\n                this.authorityClientId = this.connectedClients[0] || null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run catchup simulation.\r\n     */\r\n    private runCatchup(startFrame: number, endFrame: number, inputs: ServerInput[]): void {\r\n        const ticksToRun = endFrame - startFrame + 1;\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Catchup: ${ticksToRun} ticks from ${startFrame} to ${endFrame}, ${inputs.length} inputs`);\r\n        }\r\n\r\n        // CRITICAL: Sort all inputs by seq to ensure correct order within frames\r\n        // Multiple inputs can occur in a single frame - seq determines order\r\n        const sortedInputs = [...inputs].sort((a, b) => (a.seq || 0) - (b.seq || 0));\r\n\r\n        // Build map of frame -> inputs for that frame (sorted by seq)\r\n        const inputsByFrame = new Map<number, ServerInput[]>();\r\n        for (const input of sortedInputs) {\r\n            // Inputs without frame are assigned to startFrame (first catchup frame)\r\n            const frame = input.frame ?? startFrame;\r\n            if (!inputsByFrame.has(frame)) {\r\n                inputsByFrame.set(frame, []);\r\n            }\r\n            inputsByFrame.get(frame)!.push(input);\r\n        }\r\n\r\n        // Run each tick\r\n        for (let f = 0; f < ticksToRun; f++) {\r\n            const tickFrame = startFrame + f;\r\n\r\n            // Process inputs for this frame (already sorted by seq)\r\n            const frameInputs = inputsByFrame.get(tickFrame) || [];\r\n            for (const input of frameInputs) {\r\n                this.processInput(input);\r\n            }\r\n\r\n            // Run world tick\r\n            this.world.tick(tickFrame, []);\r\n\r\n            // Call game's onTick\r\n            this.callbacks.onTick?.(tickFrame);\r\n        }\r\n\r\n        this.currentFrame = endFrame;\r\n        this.lastProcessedFrame = endFrame;  // Prevent re-processing old frames\r\n\r\n        // Clear the snapshot entity tracking - catchup is done\r\n        // Future join events should trigger onConnect normally\r\n        this.clientsWithEntitiesFromSnapshot.clear();\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Catchup complete at frame ${this.currentFrame}, hash=${this.getStateHash()}`);\r\n        }\r\n    }\r\n\r\n    // ==========================================\r\n    // Snapshot Methods\r\n    // ==========================================\r\n\r\n    /**\r\n     * Convert ECS snapshot to network wire format.\r\n     */\r\n    private getNetworkSnapshot(): any {\r\n        // Format 5: Type-indexed encoding with optional syncFields\r\n        // - types: [\"snake-head\", \"snake-segment\", ...] - type names array\r\n        // - schema: [[compSchema], [compSchema], ...] - indexed by type index\r\n        // - entities: [[eid, typeIndex, values], ...] - typeIndex instead of string\r\n        // If entity type has syncFields, only those fields are included in schema/values\r\n\r\n        // Build type index and schema\r\n        const types: string[] = [];\r\n        const typeToIndex = new Map<string, number>();\r\n        const schema: [string, string[]][][] = [];\r\n        const typeSyncFields = new Map<string, Set<string>>();  // Cache syncFields per type\r\n        const entities: any[] = [];\r\n\r\n        for (const entity of this.world.getAllEntities()) {\r\n            const index = entity.eid & INDEX_MASK;\r\n            const type = entity.type;\r\n\r\n            // Assign type index if new type\r\n            if (!typeToIndex.has(type)) {\r\n                const typeIdx = types.length;\r\n                types.push(type);\r\n                typeToIndex.set(type, typeIdx);\r\n\r\n                // Get syncFields for this type (if defined)\r\n                const entityDef = this.world.getEntityDef(type);\r\n                const syncFieldsSet = entityDef?.syncFields\r\n                    ? new Set(entityDef.syncFields)\r\n                    : null;\r\n                typeSyncFields.set(type, syncFieldsSet!);\r\n\r\n                // Build schema for this type (only synced fields)\r\n                const typeSchema: [string, string[]][] = [];\r\n                for (const comp of entity.getComponents()) {\r\n                    const fieldsToSync = syncFieldsSet\r\n                        ? comp.fieldNames.filter(f => syncFieldsSet.has(f))\r\n                        : comp.fieldNames;\r\n                    if (fieldsToSync.length > 0) {\r\n                        typeSchema.push([comp.name, fieldsToSync]);\r\n                    }\r\n                }\r\n                schema.push(typeSchema);\r\n            }\r\n\r\n            // Encode values as flat array matching schema order (only synced fields)\r\n            const syncFieldsSet = typeSyncFields.get(type);\r\n            const values: any[] = [];\r\n            for (const comp of entity.getComponents()) {\r\n                for (const fieldName of comp.fieldNames) {\r\n                    // Only include if no syncFields defined OR field is in syncFields\r\n                    if (!syncFieldsSet || syncFieldsSet.has(fieldName)) {\r\n                        values.push(comp.storage.fields[fieldName][index]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            entities.push([\r\n                entity.eid,  // eid as number (no need for hex conversion)\r\n                typeToIndex.get(type)!,  // type INDEX (1 byte) instead of string\r\n                values\r\n            ]);\r\n        }\r\n\r\n        // Compute minimal ID allocator state from entities\r\n        let maxIndex = 0;\r\n        const activeGenerations: Record<number, number> = {};\r\n        for (const e of entities) {\r\n            const eid = e[0];\r\n            const index = eid & INDEX_MASK;\r\n            const gen = eid >>> 20;\r\n            if (index >= maxIndex) maxIndex = index + 1;\r\n            activeGenerations[index] = gen;\r\n        }\r\n\r\n        return {\r\n            frame: this.currentFrame,\r\n            seq: this.lastInputSeq,\r\n            format: 5, // Format 5: type-indexed compact encoding\r\n            types,     // Type names array (sent once)\r\n            schema,    // Component schemas indexed by type index\r\n            entities,  // Array of [eid, typeIndex, values[]]\r\n            idAllocatorState: {\r\n                nextIndex: maxIndex,\r\n                freeList: [],\r\n                generations: activeGenerations\r\n            },\r\n            rng: saveRandomState(),\r\n            strings: this.world.strings.getState(),\r\n            clientIdMap: {\r\n                toNum: Object.fromEntries(this.clientIdToNum),\r\n                nextNum: this.nextClientNum\r\n            },\r\n            inputState: this.world.getInputState()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Load network snapshot into ECS world.\r\n     */\r\n    private loadNetworkSnapshot(snapshot: any): void {\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Loading snapshot: ${snapshot.entities?.length} entities`);\r\n        }\r\n\r\n        // Reset world FIRST (clears everything including ID allocator and strings)\r\n        this.world.reset();\r\n\r\n        // CRITICAL: Clear physics state before recreating entities\r\n        // Without this, old physics bodies with stale state (positions, sleeping, etc.)\r\n        // would be reused when entities are recreated with the same eids\r\n        if (this.physics) {\r\n            this.physics.clear();\r\n        }\r\n\r\n        // Restore RNG state\r\n        if (snapshot.rng) {\r\n            loadRandomState(snapshot.rng);\r\n        }\r\n\r\n        // Restore strings AFTER reset\r\n        if (snapshot.strings) {\r\n            this.world.strings.setState(snapshot.strings);\r\n        }\r\n\r\n        // Restore clientId interning\r\n        if (snapshot.clientIdMap) {\r\n            this.clientIdToNum = new Map(Object.entries(snapshot.clientIdMap.toNum).map(([k, v]) => [k, v as number]));\r\n            this.numToClientId = new Map(Array.from(this.clientIdToNum.entries()).map(([k, v]) => [v, k]));\r\n            this.nextClientNum = snapshot.clientIdMap.nextNum || 1;\r\n        }\r\n\r\n        // Format 5: type-indexed encoding\r\n        const types = snapshot.types;\r\n        const schema = snapshot.schema;\r\n        const entitiesData = snapshot.entities;\r\n\r\n        // Track loaded entities by type for onRestore callbacks\r\n        const loadedEntitiesByType = new Map<string, Entity[]>();\r\n\r\n        for (const entityData of entitiesData) {\r\n            const [eid, typeIndex, values] = entityData;\r\n            const type = types[typeIndex];\r\n            const typeSchema = schema[typeIndex];\r\n\r\n            // Spawn entity with specific eid\r\n            let entity;\r\n            try {\r\n                entity = this.world.spawnWithId(type, eid, {});\r\n            } catch (e) {\r\n                console.warn(`[ecs] Failed to spawn ${type} with eid ${eid}:`, e);\r\n                continue;\r\n            }\r\n\r\n            // Track for onRestore callback\r\n            if (!loadedEntitiesByType.has(type)) {\r\n                loadedEntitiesByType.set(type, []);\r\n            }\r\n            loadedEntitiesByType.get(type)!.push(entity);\r\n\r\n            // Restore values using schema\r\n            const index = eid & INDEX_MASK;\r\n            let valueIdx = 0;\r\n\r\n            for (const [compName, fieldNames] of typeSchema) {\r\n                // Find component on entity\r\n                for (const comp of entity.getComponents()) {\r\n                    if (comp.name === compName) {\r\n                        for (const fieldName of fieldNames) {\r\n                            comp.storage.fields[fieldName][index] = values[valueIdx++];\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // CRITICAL: Update clientIdIndex for Player entities after component restore\r\n            // The spawnWithId call above didn't have clientId in props, so the index wasn't set\r\n            if (entity.has(Player)) {\r\n                const player = entity.get(Player);\r\n                if (player.clientId !== 0) {\r\n                    this.world.setEntityClientId(entity.eid, player.clientId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Call onRestore callbacks for entity types that have them\r\n        // This allows reconstructing non-synced fields from synced data\r\n        for (const [type, entities] of loadedEntitiesByType) {\r\n            const entityDef = this.world.getEntityDef(type);\r\n            if (entityDef?.onRestore) {\r\n                for (const entity of entities) {\r\n                    entityDef.onRestore(entity, this);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Restore input sequence\r\n        this.lastInputSeq = snapshot.seq || 0;\r\n\r\n        // Restore ID allocator state for proper future allocations\r\n        // Format 3+: minimal format with generations as object { index: gen }\r\n        // Format 2-: full format with generations as array\r\n        if (snapshot.idAllocatorState) {\r\n            const state = snapshot.idAllocatorState;\r\n            if (snapshot.format >= 3 && typeof state.generations === 'object' && !Array.isArray(state.generations)) {\r\n                // Minimal format - reconstruct full state\r\n                this.world.idAllocator.reset();\r\n                this.world.idAllocator.setNextId(state.nextIndex);\r\n                // Set generations for active entities\r\n                for (const [indexStr, gen] of Object.entries(state.generations)) {\r\n                    const index = parseInt(indexStr, 10);\r\n                    (this.world.idAllocator as any).generations[index] = gen;\r\n                }\r\n                // Compute free list: indices from 0 to nextIndex that aren't in active generations\r\n                const freeList: number[] = [];\r\n                for (let i = 0; i < state.nextIndex; i++) {\r\n                    if (!(i.toString() in state.generations)) {\r\n                        freeList.push(i);\r\n                    }\r\n                }\r\n                (this.world.idAllocator as any).freeList = freeList;\r\n            } else {\r\n                // Legacy full format\r\n                this.world.idAllocator.setState(state);\r\n            }\r\n        }\r\n\r\n        // Track which clients already have entities from the snapshot\r\n        // This prevents duplicate entity creation during catchup\r\n        this.clientsWithEntitiesFromSnapshot.clear();\r\n        for (const entity of this.world.query(Player)) {\r\n            const player = entity.get(Player);\r\n            if (player.clientId !== 0) {\r\n                const clientIdStr = this.getClientIdString(player.clientId);\r\n                if (clientIdStr) {\r\n                    this.clientsWithEntitiesFromSnapshot.add(clientIdStr);\r\n                    if (DEBUG_NETWORK) {\r\n                        console.log(`[ecs] Snapshot has entity for client ${clientIdStr.slice(0, 8)}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // CRITICAL: Wake all physics bodies after snapshot restore\r\n        // Without this, late joiners have awake bodies while existing clients may have\r\n        // sleeping bodies, causing physics simulation divergence after catchup\r\n        if (this.physics) {\r\n            this.physics.wakeAllBodies();\r\n        }\r\n\r\n        // CRITICAL: Restore input state so movement systems behave identically\r\n        // Without this, systems that check `game.world.getInput(clientId)` won't find\r\n        // the last input, causing movement to stop on late joiners while authority continues\r\n        if (snapshot.inputState) {\r\n            this.world.setInputState(snapshot.inputState);\r\n        }\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Snapshot loaded: ${this.world.getAllEntities().length} entities, hash=${this.getStateHash()}`);\r\n            // Debug: log first restored entity\r\n            const firstEntity = this.world.getAllEntities()[0];\r\n            if (firstEntity) {\r\n                const components: Record<string, Record<string, any>> = {};\r\n                for (const comp of firstEntity.getComponents()) {\r\n                    const data: Record<string, any> = {};\r\n                    for (const fieldName of comp.fieldNames) {\r\n                        data[fieldName] = (firstEntity.get(comp) as any)[fieldName];\r\n                    }\r\n                    components[comp.name] = data;\r\n                }\r\n                console.log(`[ecs] Restored first entity: type=${firstEntity.type}, components=`, JSON.stringify(components));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send snapshot to network.\r\n     */\r\n    private sendSnapshot(source: string): void {\r\n        if (!this.connection) return;\r\n\r\n        // CRITICAL: Wake all physics bodies when sending snapshot\r\n        // This ensures the authority's bodies are in the same state as the late joiner's\r\n        // bodies will be after they restore and wake. Without this, authority has sleeping\r\n        // bodies while late joiner has awake bodies, causing physics divergence.\r\n        if (this.physics) {\r\n            this.physics.wakeAllBodies();\r\n        }\r\n\r\n        const snapshot = this.getNetworkSnapshot();\r\n        const hash = this.world.getStateHash();\r\n        const binary = encode({ snapshot, hash });\r\n\r\n        // DEBUG: Log snapshot size breakdown\r\n        const entitiesSize = encode(snapshot.entities).length;\r\n        const schemaSize = encode(snapshot.schema).length;\r\n        const entityCount = snapshot.entities.length;\r\n        console.log(`[SNAPSHOT-SIZE] Total: ${binary.length}B | entities: ${entitiesSize}B (${entityCount}) | schema: ${schemaSize}B`);\r\n\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Sending snapshot (${source}): ${binary.length} bytes, ${entityCount} entities, hash=${hash}`);\r\n        }\r\n\r\n        this.connection.sendSnapshot(binary, hash, snapshot.seq, snapshot.frame);\r\n\r\n        // Update debug UI tracking - show last SENT snapshot for authority\r\n        this.lastSnapshotHash = hash;\r\n        this.lastSnapshotFrame = snapshot.frame;\r\n        this.lastSnapshotSize = binary.length;\r\n        this.lastSnapshotEntityCount = entityCount;\r\n    }\r\n\r\n    /**\r\n     * Handle server snapshot (for drift detection).\r\n     */\r\n    private handleServerSnapshot(data: Uint8Array): void {\r\n        if (DEBUG_NETWORK) {\r\n            console.log(`[ecs] Received server snapshot: ${data.length} bytes`);\r\n        }\r\n\r\n        // Decode and compare for drift detection\r\n        try {\r\n            const decoded = decode(data);\r\n            const serverSnapshot = decoded?.snapshot;\r\n            const serverHash = decoded?.hash;\r\n\r\n            if (serverSnapshot) {\r\n                this.lastSnapshotHash = serverHash;\r\n                this.lastSnapshotFrame = serverSnapshot.frame;\r\n                this.lastSnapshotSize = data.length;\r\n                this.lastSnapshotEntityCount = serverSnapshot.entities?.length || 0;\r\n\r\n                // Only compare if frames match - otherwise comparison is meaningless\r\n                if (this.currentFrame === serverSnapshot.frame) {\r\n                    // Field-by-field comparison for drift stats\r\n                    this.compareSnapshotFields(serverSnapshot);\r\n\r\n                    // Compare hashes\r\n                    const localHash = this.getStateHash();\r\n                    if (localHash !== serverHash) {\r\n                        console.warn(`[ecs] DRIFT detected at frame ${serverSnapshot.frame}: local=${localHash}, server=${serverHash}`);\r\n                    }\r\n                } else {\r\n                    // Frames don't match - skip comparison (would give false positives)\r\n                    // Reset drift stats since we can't validate\r\n                    this.driftStats = {\r\n                        determinismPercent: 100,\r\n                        totalChecks: 0,\r\n                        matchingFieldCount: 0,\r\n                        totalFieldCount: 0\r\n                    };\r\n                }\r\n            }\r\n        } catch (e) {\r\n            console.warn('[ecs] Failed to decode server snapshot:', e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compare server snapshot fields with local state for drift tracking.\r\n     */\r\n    private compareSnapshotFields(serverSnapshot: any): void {\r\n        const frame = serverSnapshot.frame;\r\n        let matchingFields = 0;\r\n        let totalFields = 0;\r\n        const diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }> = [];\r\n\r\n        // Store server snapshot for debugging\r\n        this.lastServerSnapshot = { raw: null, decoded: serverSnapshot, frame };\r\n\r\n        const types = serverSnapshot.types || [];\r\n        const serverEntities = serverSnapshot.entities || [];\r\n        const schema = serverSnapshot.schema || [];\r\n\r\n        // Build map of server entities by eid (numeric)\r\n        const serverEntityMap = new Map<number, any>();\r\n        for (const e of serverEntities) {\r\n            serverEntityMap.set(e[0], e);\r\n        }\r\n\r\n        // Compare each local entity with server entity\r\n        for (const entity of this.world.getAllEntities()) {\r\n            const eid = entity.eid;\r\n            const serverEntity = serverEntityMap.get(eid);\r\n            const index = eid & INDEX_MASK;\r\n\r\n            if (!serverEntity) {\r\n                for (const comp of entity.getComponents()) {\r\n                    totalFields += comp.fieldNames.length;\r\n                    for (const fieldName of comp.fieldNames) {\r\n                        diffs.push({ entity: entity.type, eid, comp: comp.name, field: fieldName, local: 'EXISTS', server: 'MISSING' });\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n\r\n            const [, typeIndex, serverValues] = serverEntity;\r\n            const typeSchema = schema[typeIndex];\r\n\r\n            if (!typeSchema) continue;\r\n\r\n            let valueIdx = 0;\r\n            for (const [compName, fieldNames] of typeSchema) {\r\n                const localComp = entity.getComponents().find(c => c.name === compName);\r\n\r\n                for (const fieldName of fieldNames) {\r\n                    totalFields++;\r\n                    const serverValue = serverValues[valueIdx++];\r\n\r\n                    if (localComp) {\r\n                        const localValue = localComp.storage.fields[fieldName][index];\r\n                        const fieldDef = localComp.schema[fieldName];\r\n\r\n                        let valuesMatch = false;\r\n                        if (fieldDef?.type === 'bool') {\r\n                            const localBool = localValue !== 0;\r\n                            const serverBool = serverValue !== 0 && serverValue !== false;\r\n                            valuesMatch = localBool === serverBool;\r\n                        } else {\r\n                            valuesMatch = localValue === serverValue;\r\n                        }\r\n\r\n                        if (valuesMatch) {\r\n                            matchingFields++;\r\n                        } else {\r\n                            diffs.push({ entity: entity.type, eid, comp: compName, field: fieldName, local: localValue, server: serverValue });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Count server entities not in local state\r\n        for (const [eid, serverEntity] of serverEntityMap) {\r\n            if (this.world.getEntity(eid) === null) {\r\n                const [, typeIndex, serverValues] = serverEntity;\r\n                const serverType = types[typeIndex] || `type${typeIndex}`;\r\n                totalFields += serverValues.length;\r\n                diffs.push({ entity: serverType, eid, comp: '*', field: '*', local: 'MISSING', server: 'EXISTS' });\r\n            }\r\n        }\r\n\r\n        const newPercent = totalFields > 0 ? (matchingFields / totalFields) * 100 : 100;\r\n        const wasSync = this.lastSyncPercent === 100;\r\n        const isSync = newPercent === 100;\r\n\r\n        // Store good snapshot when 100% sync\r\n        if (isSync) {\r\n            this.lastGoodSnapshot = {\r\n                snapshot: JSON.parse(JSON.stringify(serverSnapshot)),\r\n                frame: frame,\r\n                hash: this.getStateHash()\r\n            };\r\n        }\r\n\r\n        // First divergence - capture debug data and auto-show\r\n        if (wasSync && !isSync && !this.divergenceCaptured) {\r\n            this.firstDivergenceFrame = frame;\r\n            this.divergenceHistory = [];\r\n            this.divergenceCaptured = true;\r\n\r\n            const lastGoodFrame = this.lastGoodSnapshot?.frame ?? 0;\r\n            const inputsInRange = this.recentInputs.filter(i => i.frame > lastGoodFrame && i.frame <= frame);\r\n            const localSnapshot = this.world.getState();\r\n\r\n            this.divergenceCapture = {\r\n                lastGoodSnapshot: this.lastGoodSnapshot?.snapshot ?? null,\r\n                lastGoodFrame: lastGoodFrame,\r\n                inputs: inputsInRange,\r\n                localSnapshot: localSnapshot,\r\n                serverSnapshot: serverSnapshot,\r\n                diffs: diffs,\r\n                divergenceFrame: frame,\r\n                clientId: this.localClientIdStr,\r\n                isAuthority: this.checkIsAuthority()\r\n            };\r\n\r\n            this.showDivergenceDiff(diffs, inputsInRange, frame);\r\n        }\r\n\r\n        this.lastSyncPercent = newPercent;\r\n\r\n        // Update drift stats\r\n        this.driftStats.totalChecks++;\r\n        this.driftStats.matchingFieldCount = matchingFields;\r\n        this.driftStats.totalFieldCount = totalFields;\r\n        this.driftStats.determinismPercent = newPercent;\r\n\r\n        // Sparse ongoing divergence log (every 60 frames)\r\n        if (diffs.length > 0 && newPercent < 100 && this.divergenceCaptured && frame % 60 === 0) {\r\n            console.warn(`[DIVERGENCE] Frame ${frame}: still diverged (${newPercent.toFixed(1)}% sync, first at ${this.firstDivergenceFrame})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Show divergence debug data (auto-called on first divergence).\r\n     */\r\n    private showDivergenceDiff(\r\n        diffs: Array<{ entity: string; eid: number; comp: string; field: string; local: any; server: any }>,\r\n        inputs: Array<{ frame: number; seq: number; clientId: string; data: any }>,\r\n        frame: number\r\n    ): void {\r\n        const lines: string[] = [];\r\n        const lastGoodFrame = this.lastGoodSnapshot?.frame ?? 0;\r\n        const myClientId = this.localClientIdStr || '';\r\n\r\n        // Build client legend (assign P1, P2, etc.)\r\n        const clientIds = new Set<string>();\r\n        for (const input of inputs) {\r\n            clientIds.add(input.clientId);\r\n        }\r\n        const clientList = Array.from(clientIds);\r\n        const clientLabels = new Map<string, string>();\r\n        clientList.forEach((cid, i) => {\r\n            const label = cid === myClientId ? 'ME' : `P${i + 1}`;\r\n            clientLabels.set(cid, label);\r\n        });\r\n\r\n        // Try to find entity owners (entities with Player component)\r\n        const entityOwners = new Map<number, string>();\r\n        for (const entity of this.world.getAllEntities()) {\r\n            if (entity.has(Player)) {\r\n                const playerData = entity.get(Player);\r\n                const ownerClientId = this.numToClientId.get(playerData.clientId);\r\n                if (ownerClientId) {\r\n                    entityOwners.set(entity.eid, clientLabels.get(ownerClientId) || ownerClientId.slice(0, 8));\r\n                }\r\n            }\r\n        }\r\n\r\n        lines.push(`=== DIVERGENCE DEBUG DATA ===`);\r\n        lines.push(`Frame: ${frame} | Last good: ${lastGoodFrame} | Authority: ${this.checkIsAuthority()}`);\r\n        lines.push(`Clients: ${clientList.map(cid => `${clientLabels.get(cid)}=${cid.slice(0, 8)}`).join(', ')}`);\r\n        lines.push(``);\r\n\r\n        lines.push(`DIVERGENT FIELDS (${diffs.length}):`);\r\n        for (const d of diffs) {\r\n            const delta = typeof d.local === 'number' && typeof d.server === 'number'\r\n                ? ` \u0394${d.local - d.server}`\r\n                : '';\r\n            const owner = entityOwners.get(d.eid);\r\n            const ownerStr = owner ? ` [${owner}]` : '';\r\n            lines.push(`  ${d.entity}#${d.eid.toString(16)}${ownerStr}.${d.comp}.${d.field}: local=${d.local} server=${d.server}${delta}`);\r\n        }\r\n        lines.push(``);\r\n\r\n        lines.push(`INPUTS (${inputs.length}):`);\r\n        for (const input of inputs) {\r\n            const label = clientLabels.get(input.clientId) || input.clientId.slice(0, 8);\r\n            lines.push(`  f${input.frame} [${label}]: ${JSON.stringify(input.data)}`);\r\n        }\r\n        lines.push(``);\r\n\r\n        if (this.lastGoodSnapshot) {\r\n            const goodEnts = Object.keys(this.lastGoodSnapshot.snapshot.entities || {}).length;\r\n            lines.push(`LAST GOOD SNAPSHOT (f${lastGoodFrame}): ${goodEnts} entities`);\r\n        } else {\r\n            lines.push(`LAST GOOD SNAPSHOT: none (never had 100% sync)`);\r\n        }\r\n\r\n        if (this.lastServerSnapshot.decoded) {\r\n            const serverEnts = Object.keys(this.lastServerSnapshot.decoded.entities || {}).length;\r\n            lines.push(`SERVER SNAPSHOT (f${this.lastServerSnapshot.frame}): ${serverEnts} entities`);\r\n        }\r\n\r\n        lines.push(`=== END DEBUG DATA ===`);\r\n        lines.push(`To get detailed replay data: game.getDivergenceReplay()`);\r\n\r\n        console.error(lines.join('\\n'));\r\n    }\r\n\r\n    /**\r\n     * Download divergence replay data as JSON.\r\n     */\r\n    getDivergenceReplay(): void {\r\n        if (!this.divergenceCapture) {\r\n            console.warn('[REPLAY] No divergence captured yet.');\r\n            return;\r\n        }\r\n\r\n        const json = JSON.stringify(this.divergenceCapture, null, 2);\r\n        const blob = new Blob([json], { type: 'application/json' });\r\n        const url = URL.createObjectURL(blob);\r\n\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = `divergence-${this.divergenceCapture.divergenceFrame}.json`;\r\n        document.body.appendChild(a);\r\n        a.click();\r\n        document.body.removeChild(a);\r\n        URL.revokeObjectURL(url);\r\n\r\n        console.log(`[REPLAY] Downloaded (${(json.length / 1024).toFixed(1)} KB)`);\r\n    }\r\n\r\n    // ==========================================\r\n    // Game Loop\r\n    // ==========================================\r\n\r\n    /**\r\n     * Start the render loop.\r\n     */\r\n    private startGameLoop(): void {\r\n        if (this.gameLoop) return;\r\n\r\n        let lastSnapshotFrame = 0;\r\n        const SNAPSHOT_INTERVAL = 100; // Every 5 seconds at 20fps\r\n\r\n        const loop = () => {\r\n            // Render\r\n            if (this.renderer?.render) {\r\n                this.renderer.render();\r\n            } else if (this.callbacks.render) {\r\n                this.callbacks.render();\r\n            }\r\n\r\n            // Periodic snapshot upload (authority only)\r\n            if (this.checkIsAuthority() && this.currentFrame - lastSnapshotFrame >= SNAPSHOT_INTERVAL) {\r\n                this.sendSnapshot('loop');\r\n                lastSnapshotFrame = this.currentFrame;\r\n            }\r\n\r\n            this.gameLoop = requestAnimationFrame(loop);\r\n        };\r\n\r\n        this.gameLoop = requestAnimationFrame(loop);\r\n    }\r\n\r\n    /**\r\n     * Stop the render loop.\r\n     */\r\n    private stopGameLoop(): void {\r\n        if (this.gameLoop) {\r\n            cancelAnimationFrame(this.gameLoop);\r\n            this.gameLoop = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle disconnect.\r\n     */\r\n    private handleDisconnect(): void {\r\n        if (DEBUG_NETWORK) console.log('[ecs] Disconnected');\r\n        this.stopGameLoop();\r\n    }\r\n\r\n    // ==========================================\r\n    // Utility Methods\r\n    // ==========================================\r\n\r\n    /**\r\n     * Check if this client is the authority.\r\n     * Handles potential length mismatch between SDK and server client IDs.\r\n     */\r\n    checkIsAuthority(): boolean {\r\n        if (this.localClientIdStr === null || this.authorityClientId === null) {\r\n            return false;\r\n        }\r\n        // Server may send shorter client IDs, compare by prefix\r\n        const minLen = Math.min(this.localClientIdStr.length, this.authorityClientId.length);\r\n        return this.localClientIdStr.substring(0, minLen) === this.authorityClientId.substring(0, minLen);\r\n    }\r\n\r\n    /**\r\n     * Check if this client is the authority (public).\r\n     */\r\n    isAuthority(): boolean {\r\n        return this.checkIsAuthority();\r\n    }\r\n\r\n    /**\r\n     * Check if connected.\r\n     */\r\n    isConnected(): boolean {\r\n        return this.connection !== null;\r\n    }\r\n\r\n    /**\r\n     * Get current frame.\r\n     */\r\n    getFrame(): number {\r\n        return this.currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Get server tick rate.\r\n     */\r\n    getServerFps(): number {\r\n        return this.serverFps;\r\n    }\r\n\r\n    /**\r\n     * Get render interpolation alpha (0-1).\r\n     */\r\n    getRenderAlpha(): number {\r\n        if (this.lastTickTime === 0) return 1;\r\n        const now = typeof performance !== 'undefined' ? performance.now() : Date.now();\r\n        const elapsed = now - this.lastTickTime;\r\n        return Math.min(elapsed / this.tickIntervalMs, 1.0);\r\n    }\r\n\r\n    /**\r\n     * Send input to network.\r\n     */\r\n    sendInput(input: any): void {\r\n        if (!this.connection) return;\r\n        const binary = encode(input);\r\n        this.connection.send(binary);\r\n    }\r\n\r\n    /**\r\n     * Leave current room.\r\n     */\r\n    leaveRoom(): void {\r\n        if (this.connection) {\r\n            this.connection.leaveRoom();\r\n            this.connection = null;\r\n            this.stopGameLoop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get local client ID.\r\n     */\r\n    get localClientId(): string | null {\r\n        return this.localClientIdStr;\r\n    }\r\n\r\n    /**\r\n     * Set local client ID.\r\n     */\r\n    setLocalClientId(clientId: string): void {\r\n        this.localClientIdStr = clientId;\r\n        const numId = this.internClientId(clientId);\r\n        this.world.localClientId = numId;\r\n    }\r\n\r\n    /**\r\n     * Get room ID.\r\n     */\r\n    getRoomId(): string | null {\r\n        return this.connectedRoomId;\r\n    }\r\n\r\n    /**\r\n     * Get last snapshot info.\r\n     */\r\n    getLastSnapshot(): { hash: string | null; frame: number; size: number; entityCount: number } {\r\n        return {\r\n            hash: this.lastSnapshotHash,\r\n            frame: this.lastSnapshotFrame,\r\n            size: this.lastSnapshotSize,\r\n            entityCount: this.lastSnapshotEntityCount\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get connected clients.\r\n     */\r\n    getClients(): string[] {\r\n        return this.connectedClients;\r\n    }\r\n\r\n    /**\r\n     * Get client ID (for debug UI).\r\n     */\r\n    getClientId(): string | null {\r\n        return this.localClientIdStr;\r\n    }\r\n\r\n    /**\r\n     * Get node URL (for debug UI).\r\n     */\r\n    getNodeUrl(): string | null {\r\n        // Could be tracked from connection, for now return null\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get upload rate in bytes/second (for debug UI).\r\n     */\r\n    getUploadRate(): number {\r\n        return this.connection?.bandwidthOut || 0;\r\n    }\r\n\r\n    /**\r\n     * Get download rate in bytes/second (for debug UI).\r\n     */\r\n    getDownloadRate(): number {\r\n        return this.connection?.bandwidthIn || 0;\r\n    }\r\n\r\n    /**\r\n     * Get drift stats (for debug UI).\r\n     * Authority clients show 100% until they receive a comparison snapshot.\r\n     */\r\n    getDriftStats(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number } {\r\n        // If no snapshots have been compared yet, assume 100% sync\r\n        // Authority clients are the source of truth, so they're always \"in sync\"\r\n        if (this.driftStats.totalChecks === 0) {\r\n            const entityCount = this.world.getAllEntities().length;\r\n            // Estimate total fields from local entities if no comparison done yet\r\n            let estimatedFields = 0;\r\n            for (const entity of this.world.getAllEntities()) {\r\n                for (const comp of entity.getComponents()) {\r\n                    estimatedFields += comp.fieldNames.length;\r\n                }\r\n            }\r\n            return {\r\n                determinismPercent: 100,\r\n                totalChecks: 0,\r\n                matchingFieldCount: estimatedFields,\r\n                totalFieldCount: estimatedFields\r\n            };\r\n        }\r\n        return { ...this.driftStats };\r\n    }\r\n\r\n    /**\r\n     * Attach a renderer.\r\n     */\r\n    setRenderer(renderer: any): void {\r\n        this.renderer = renderer;\r\n    }\r\n\r\n    /**\r\n     * Get canvas from attached renderer.\r\n     */\r\n    getCanvas(): HTMLCanvasElement | null {\r\n        return this.renderer?.element ?? null;\r\n    }\r\n}\r\n\r\n// ==========================================\r\n// GameEntityBuilder\r\n// ==========================================\r\n\r\n/**\r\n * Game-specific entity builder with fluent API.\r\n */\r\nexport class GameEntityBuilder {\r\n    private worldBuilder: EntityBuilder;\r\n    private inputCommandsDef: any = null;\r\n\r\n    constructor(\r\n        private game: Game,\r\n        private name: string\r\n    ) {\r\n        this.worldBuilder = game.world.defineEntity(name);\r\n    }\r\n\r\n    /**\r\n     * Add a component to the entity definition.\r\n     */\r\n    with<T extends Record<string, any>>(\r\n        component: ComponentType<T>,\r\n        defaults?: Partial<T>\r\n    ): this {\r\n        this.worldBuilder.with(component, defaults);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Define input commands for this entity type.\r\n     */\r\n    commands(def: any): this {\r\n        this.inputCommandsDef = def;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specify which fields to sync in snapshots (field-level sync).\r\n     * Only the specified fields are included in network snapshots.\r\n     *\r\n     * Use this to reduce bandwidth by only syncing essential fields.\r\n     * Non-synced fields can be reconstructed via onRestore().\r\n     *\r\n     * @example\r\n     * game.defineEntity('snake-segment')\r\n     *     .with(Transform2D)\r\n     *     .with(Sprite)\r\n     *     .with(SnakeSegment)\r\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\r\n     *     .register();\r\n     */\r\n    syncOnly(fields: string[]): this {\r\n        this.worldBuilder._setSyncFields(fields);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Exclude all fields from syncing for this entity type.\r\n     * The entity will not be included in network snapshots at all.\r\n     *\r\n     * Use this for purely client-local entities like cameras, UI, or effects.\r\n     *\r\n     * @example\r\n     * game.defineEntity('local-camera')\r\n     *     .with(Camera2D)\r\n     *     .syncNone()\r\n     *     .register();\r\n     */\r\n    syncNone(): this {\r\n        this.worldBuilder._setSyncFields([]);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use syncOnly() instead for clarity\r\n     */\r\n    sync(fields: string[]): this {\r\n        return this.syncOnly(fields);\r\n    }\r\n\r\n    /**\r\n     * Set a callback to reconstruct non-synced fields after snapshot load.\r\n     * Called for each entity of this type after loading a snapshot.\r\n     *\r\n     * @example\r\n     * game.defineEntity('snake-segment')\r\n     *     .with(Transform2D)\r\n     *     .with(Sprite)\r\n     *     .with(SnakeSegment)\r\n     *     .syncOnly(['x', 'y', 'ownerId', 'spawnFrame'])\r\n     *     .onRestore((entity, game) => {\r\n     *         const owner = game.world.getEntityByClientId(entity.get(SnakeSegment).ownerId);\r\n     *         if (owner) {\r\n     *             entity.get(Sprite).color = owner.get(Sprite).color;\r\n     *             entity.get(Sprite).radius = SEGMENT_RADIUS;\r\n     *         }\r\n     *     })\r\n     *     .register();\r\n     */\r\n    onRestore(callback: (entity: Entity, game: Game) => void): this {\r\n        this.worldBuilder._setOnRestore(callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Finalize and register the entity definition.\r\n     */\r\n    register(): Prefab {\r\n        this.worldBuilder._ensureRegistered();\r\n        return this.game._registerPrefab(this.name, this.worldBuilder);\r\n    }\r\n}\r\n\r\n// ==========================================\r\n// Factory Function\r\n// ==========================================\r\n\r\n/**\r\n * Initialize a new game instance.\r\n */\r\nexport function createGame(): Game {\r\n    return new Game();\r\n}\r\n", "/**\n * Simple2DRenderer - Basic 2D canvas renderer for entities with Sprite component\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Sprite, Camera2D, SHAPE_RECT, SHAPE_CIRCLE, SPRITE_IMAGE } from '../components';\n\nexport interface Simple2DRendererOptions {\n    /** Background color (default: '#111') */\n    background?: string;\n    /** Whether to clear canvas each frame (default: true) */\n    autoClear?: boolean;\n}\n\n/**\n * Simple 2D renderer that draws all entities with Sprite component.\n *\n * Can be used as a plugin via game.addPlugin() or standalone.\n *\n * @example\n * // Plugin pattern (recommended)\n * game.addPlugin(Simple2DRenderer, canvas);\n *\n * // Standalone pattern\n * new Simple2DRenderer(game, canvas);\n */\nexport class Simple2DRenderer {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    private game: Game;\n    private options: Required<Simple2DRendererOptions>;\n    private imageCache: Map<string, HTMLImageElement> = new Map();\n    private _cameraEntity: Entity | null = null;\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string, options: Simple2DRendererOptions = {}) {\n        this.game = game;\n\n        // Accept either element or selector\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        const ctx = this.canvas.getContext('2d');\n        if (!ctx) throw new Error('Could not get 2d context');\n        this.ctx = ctx;\n\n        this.options = {\n            background: options.background ?? '#111',\n            autoClear: options.autoClear ?? true\n        };\n\n        // Attach to game\n        game.setRenderer(this);\n    }\n\n    /** Canvas width */\n    get width(): number { return this.canvas.width; }\n\n    /** Canvas height */\n    get height(): number { return this.canvas.height; }\n\n    /** The canvas element */\n    get element(): HTMLCanvasElement { return this.canvas; }\n\n    /** The 2D context (for custom drawing) */\n    get context(): CanvasRenderingContext2D { return this.ctx; }\n\n    /**\n     * Set the camera entity to use for rendering.\n     * When set, the renderer will apply camera transform (position, zoom).\n     */\n    set camera(entity: Entity | null) {\n        this._cameraEntity = entity;\n        if (entity) {\n            // Update viewport size in camera component\n            try {\n                const cam = entity.get(Camera2D);\n                cam.viewportWidth = this.canvas.width;\n                cam.viewportHeight = this.canvas.height;\n            } catch {\n                // Entity doesn't have Camera2D\n            }\n        }\n    }\n\n    get camera(): Entity | null {\n        return this._cameraEntity;\n    }\n\n    /**\n     * Render all entities with Sprite component.\n     */\n    render(): void {\n        const { ctx, canvas, options, game } = this;\n\n        // Clear\n        if (options.autoClear) {\n            ctx.fillStyle = options.background;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n\n        // Get interpolation alpha (0-1 between physics ticks)\n        const alpha = game.getRenderAlpha();\n\n        // Get camera data if available\n        let camX = 0, camY = 0, camZoom = 1;\n        if (this._cameraEntity && !this._cameraEntity.destroyed) {\n            try {\n                const cam = this._cameraEntity.get(Camera2D);\n                camX = cam.x;\n                camY = cam.y;\n                camZoom = cam.zoom;\n\n                // Update viewport size in case canvas was resized\n                cam.viewportWidth = canvas.width;\n                cam.viewportHeight = canvas.height;\n            } catch {\n                // Camera entity doesn't have Camera2D\n            }\n        }\n\n        // Collect entities with Sprite, sorted by layer\n        const entities: Array<{ entity: any; layer: number }> = [];\n\n        for (const entity of game.getAllEntities()) {\n            // Skip destroyed entities\n            if (entity.destroyed) continue;\n\n            try {\n                const sprite = entity.get(Sprite);\n                if (sprite && sprite.visible) {\n                    // Calculate interpolated position for smooth rendering\n                    entity.interpolate(alpha);\n                    entities.push({ entity, layer: sprite.layer });\n                }\n            } catch {\n                // Entity doesn't have Sprite\n            }\n        }\n\n        // Sort by layer (lower first)\n        entities.sort((a, b) => a.layer - b.layer);\n\n        // Apply camera transform\n        ctx.save();\n        ctx.translate(canvas.width / 2, canvas.height / 2);\n        ctx.scale(camZoom, camZoom);\n        ctx.translate(-camX, -camY);\n\n        // Draw each entity\n        for (const { entity } of entities) {\n            this.drawEntity(entity);\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Draw a single entity.\n     */\n    private drawEntity(entity: any): void {\n        const { ctx, game } = this;\n\n        const sprite = entity.get(Sprite);\n\n        // Use interpolated position for smooth rendering between physics ticks\n        const x = entity.render.interpX + sprite.offsetX;\n        const y = entity.render.interpY + sprite.offsetY;\n        const scaleX = sprite.scaleX;\n        const scaleY = sprite.scaleY;\n\n        // Get color string\n        const colorStr = game.getString('color', sprite.color) || '#fff';\n\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.scale(scaleX, scaleY);\n\n        const shape = sprite.shape;\n\n        if (shape === SHAPE_CIRCLE) {\n            const radius = sprite.radius;\n            ctx.fillStyle = colorStr;\n            ctx.beginPath();\n            ctx.arc(0, 0, radius, 0, Math.PI * 2);\n            ctx.fill();\n        } else if (shape === SHAPE_RECT) {\n            const w = sprite.width;\n            const h = sprite.height;\n            ctx.fillStyle = colorStr;\n            ctx.fillRect(-w / 2, -h / 2, w, h);\n        } else if (shape === SPRITE_IMAGE) {\n            const imageId = game.getString('sprite', sprite.spriteId);\n            if (imageId) {\n                const img = this.getImage(imageId);\n                if (img && img.complete) {\n                    const w = sprite.width || img.width;\n                    const h = sprite.height || img.height;\n                    ctx.drawImage(img, -w / 2, -h / 2, w, h);\n                }\n            }\n        }\n\n        ctx.restore();\n    }\n\n    /**\n     * Get or load an image.\n     */\n    private getImage(src: string): HTMLImageElement | null {\n        let img = this.imageCache.get(src);\n        if (!img) {\n            img = new Image();\n            img.src = src;\n            this.imageCache.set(src, img);\n        }\n        return img;\n    }\n\n    /**\n     * Preload images for faster rendering.\n     */\n    preload(images: string[]): Promise<void> {\n        return Promise.all(\n            images.map(src => new Promise<void>((resolve) => {\n                const img = this.getImage(src);\n                if (img?.complete) {\n                    resolve();\n                } else if (img) {\n                    img.onload = () => resolve();\n                    img.onerror = () => resolve();\n                }\n            }))\n        ).then(() => {});\n    }\n}\n", "/**\n * InputPlugin - Handles input collection and network sending\n *\n * Provides an action-based input system where:\n * - Game defines actions with default bindings\n * - Players can rebind actions to different keys\n * - Input is automatically sent to server at tick rate\n *\n * @example\n * const input = game.addPlugin(InputPlugin, canvas);\n *\n * input.action('move', { type: 'vector', bindings: ['keys:wasd+arrows'] });\n * input.action('boost', { type: 'button', bindings: ['key:shift'] });\n * input.action('target', { type: 'vector', bindings: ['mouse'] });\n *\n * // Player rebinds\n * input.rebind('boost', ['key:space']);\n *\n * // Save/load\n * localStorage.setItem('keybinds', JSON.stringify(input.getBindings()));\n * input.loadBindings(JSON.parse(localStorage.getItem('keybinds')));\n */\n\nimport { Game } from '../game';\n\n// Forward declaration to avoid circular import\ninterface GameLike {\n    isConnected(): boolean;\n    localClientId: string | null;\n    sendInput(input: any): void;\n    getServerFps(): number;\n}\n\n/** Action types */\nexport type ActionType = 'button' | 'vector';\n\n/** Binding source - string shorthand or custom callback */\nexport type BindingSource = string | (() => any);\n\n/** Action definition */\nexport interface ActionDef {\n    type: ActionType;\n    bindings: BindingSource[];\n}\n\n/** Vector value */\nexport interface Vec2 {\n    x: number;\n    y: number;\n}\n\n/**\n * InputPlugin - Action-based input system\n */\nexport class InputPlugin {\n    private game: GameLike;\n    private canvas: HTMLCanvasElement;\n\n    /** Action definitions */\n    private actions: Map<string, ActionDef> = new Map();\n\n    /** Current bindings (may differ from defaults after rebind) */\n    private bindings: Map<string, BindingSource[]> = new Map();\n\n    /** Raw input state */\n    private mousePos: Vec2 = { x: 0, y: 0 };\n    private keysDown: Set<string> = new Set();\n    private mouseButtons: Set<number> = new Set();\n\n    /** Send interval handle */\n    private sendInterval: number | null = null;\n\n    /** Last sent input (for deduplication) */\n    private lastSentInput: string = '';\n\n    constructor(game: Game, canvas: HTMLCanvasElement | string) {\n        this.game = game;\n\n        // Resolve canvas\n        if (typeof canvas === 'string') {\n            const el = document.querySelector(canvas) as HTMLCanvasElement;\n            if (!el) throw new Error(`Canvas not found: ${canvas}`);\n            this.canvas = el;\n        } else {\n            this.canvas = canvas;\n        }\n\n        this.setupListeners();\n        this.startSendLoop();\n    }\n\n    /**\n     * Define an action with default bindings.\n     */\n    action(name: string, def: ActionDef): this {\n        this.actions.set(name, def);\n        // Set default bindings if not already rebound\n        if (!this.bindings.has(name)) {\n            this.bindings.set(name, [...def.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Rebind an action to new bindings.\n     */\n    rebind(name: string, bindings: BindingSource[]): this {\n        if (!this.actions.has(name)) {\n            console.warn(`[InputPlugin] Unknown action: ${name}`);\n            return this;\n        }\n        this.bindings.set(name, bindings);\n        return this;\n    }\n\n    /**\n     * Reset action to default bindings.\n     */\n    resetBinding(name: string): this {\n        const action = this.actions.get(name);\n        if (action) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Reset all bindings to defaults.\n     */\n    resetAllBindings(): this {\n        for (const [name, action] of this.actions) {\n            this.bindings.set(name, [...action.bindings]);\n        }\n        return this;\n    }\n\n    /**\n     * Get current bindings for serialization.\n     * Only includes string bindings (callbacks can't be serialized).\n     */\n    getBindings(): Record<string, string[]> {\n        const result: Record<string, string[]> = {};\n        for (const [name, sources] of this.bindings) {\n            result[name] = sources.filter(s => typeof s === 'string') as string[];\n        }\n        return result;\n    }\n\n    /**\n     * Load bindings from serialized data.\n     */\n    loadBindings(data: Record<string, string[]>): this {\n        for (const [name, sources] of Object.entries(data)) {\n            if (this.actions.has(name)) {\n                this.bindings.set(name, sources);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Get current value of an action.\n     */\n    get(name: string): boolean | Vec2 | null {\n        const action = this.actions.get(name);\n        const sources = this.bindings.get(name);\n        if (!action || !sources) return null;\n\n        if (action.type === 'button') {\n            return this.resolveButton(sources);\n        } else {\n            return this.resolveVector(sources);\n        }\n    }\n\n    /**\n     * Get all action values as an object.\n     */\n    getAll(): Record<string, any> {\n        const result: Record<string, any> = {};\n        for (const name of this.actions.keys()) {\n            result[name] = this.get(name);\n        }\n        return result;\n    }\n\n    /**\n     * Resolve button value from sources (OR logic).\n     */\n    private resolveButton(sources: BindingSource[]): boolean {\n        for (const source of sources) {\n            if (typeof source === 'function') {\n                if (source()) return true;\n            } else if (this.resolveStringButton(source)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Resolve vector value from sources (additive, clamped).\n     */\n    private resolveVector(sources: BindingSource[]): Vec2 {\n        let x = 0, y = 0;\n\n        for (const source of sources) {\n            let vec: Vec2 | null = null;\n\n            if (typeof source === 'function') {\n                vec = source();\n            } else {\n                vec = this.resolveStringVector(source);\n            }\n\n            if (vec) {\n                x += vec.x;\n                y += vec.y;\n            }\n        }\n\n        // Clamp to -1..1 for direction vectors, but not for mouse position\n        // We detect mouse by checking if values are large\n        if (Math.abs(x) <= 1 && Math.abs(y) <= 1) {\n            const len = Math.sqrt(x * x + y * y);\n            if (len > 1) {\n                x /= len;\n                y /= len;\n            }\n        }\n\n        return { x, y };\n    }\n\n    /**\n     * Resolve a string binding to button value.\n     */\n    private resolveStringButton(source: string): boolean {\n        // key:X - single key\n        if (source.startsWith('key:')) {\n            const key = source.slice(4).toLowerCase();\n            return this.keysDown.has(key);\n        }\n\n        // mouse:left, mouse:right, mouse:middle\n        if (source.startsWith('mouse:')) {\n            const button = source.slice(6);\n            if (button === 'left') return this.mouseButtons.has(0);\n            if (button === 'right') return this.mouseButtons.has(2);\n            if (button === 'middle') return this.mouseButtons.has(1);\n        }\n\n        return false;\n    }\n\n    /**\n     * Resolve a string binding to vector value.\n     */\n    private resolveStringVector(source: string): Vec2 | null {\n        // mouse - current position\n        if (source === 'mouse') {\n            return { ...this.mousePos };\n        }\n\n        // keys:wasd\n        if (source === 'keys:wasd') {\n            return this.getWASD();\n        }\n\n        // keys:arrows\n        if (source === 'keys:arrows') {\n            return this.getArrows();\n        }\n\n        // keys:wasd+arrows\n        if (source === 'keys:wasd+arrows') {\n            const wasd = this.getWASD();\n            const arrows = this.getArrows();\n            return {\n                x: Math.max(-1, Math.min(1, wasd.x + arrows.x)),\n                y: Math.max(-1, Math.min(1, wasd.y + arrows.y))\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Get WASD direction.\n     */\n    private getWASD(): Vec2 {\n        let x = 0, y = 0;\n        if (this.keysDown.has('a')) x -= 1;\n        if (this.keysDown.has('d')) x += 1;\n        if (this.keysDown.has('w')) y -= 1;\n        if (this.keysDown.has('s')) y += 1;\n        return { x, y };\n    }\n\n    /**\n     * Get arrow keys direction.\n     */\n    private getArrows(): Vec2 {\n        let x = 0, y = 0;\n        if (this.keysDown.has('arrowleft')) x -= 1;\n        if (this.keysDown.has('arrowright')) x += 1;\n        if (this.keysDown.has('arrowup')) y -= 1;\n        if (this.keysDown.has('arrowdown')) y += 1;\n        return { x, y };\n    }\n\n    /**\n     * Set up event listeners.\n     */\n    private setupListeners(): void {\n        // Mouse move\n        this.canvas.addEventListener('mousemove', (e) => {\n            const rect = this.canvas.getBoundingClientRect();\n            this.mousePos.x = e.clientX - rect.left;\n            this.mousePos.y = e.clientY - rect.top;\n        });\n\n        // Mouse buttons\n        this.canvas.addEventListener('mousedown', (e) => {\n            this.mouseButtons.add(e.button);\n        });\n\n        this.canvas.addEventListener('mouseup', (e) => {\n            this.mouseButtons.delete(e.button);\n        });\n\n        // Keyboard - use window to catch all keys\n        window.addEventListener('keydown', (e) => {\n            this.keysDown.add(e.key.toLowerCase());\n        });\n\n        window.addEventListener('keyup', (e) => {\n            this.keysDown.delete(e.key.toLowerCase());\n        });\n\n        // Clear keys on blur (prevent stuck keys)\n        window.addEventListener('blur', () => {\n            this.keysDown.clear();\n            this.mouseButtons.clear();\n        });\n    }\n\n    /**\n     * Start the send loop.\n     */\n    private startSendLoop(): void {\n        // Send at server tick rate (default 50ms = 20fps)\n        const sendRate = 1000 / (this.game.getServerFps?.() || 20);\n\n        this.sendInterval = window.setInterval(() => {\n            if (this.game.isConnected() && this.game.localClientId && this.actions.size > 0) {\n                const input = this.getAll();\n                // Only send if input changed (deduplication to save bandwidth)\n                const inputStr = this.inputToString(input);\n                if (inputStr !== this.lastSentInput) {\n                    this.lastSentInput = inputStr;\n                    this.game.sendInput(input);\n                }\n            }\n        }, sendRate);\n    }\n\n    /**\n     * Convert input to string for comparison.\n     * Uses rounding for vectors to avoid sending tiny mouse movements.\n     */\n    private inputToString(input: Record<string, any>): string {\n        const normalized: Record<string, any> = {};\n        for (const [key, value] of Object.entries(input)) {\n            if (value && typeof value === 'object' && 'x' in value && 'y' in value) {\n                // Round vectors to avoid sending tiny movements\n                normalized[key] = { x: Math.round(value.x / 10) * 10, y: Math.round(value.y / 10) * 10 };\n            } else {\n                normalized[key] = value;\n            }\n        }\n        return JSON.stringify(normalized);\n    }\n\n    /**\n     * Stop the send loop.\n     */\n    destroy(): void {\n        if (this.sendInterval !== null) {\n            clearInterval(this.sendInterval);\n            this.sendInterval = null;\n        }\n    }\n}\n", "/**\n * CameraSystem - 2D camera management for ECS\n *\n * Updates Camera2D component based on follow target.\n * Handles zoom smoothing and position interpolation.\n *\n * This system is client-only - Camera2D component has sync: false.\n */\n\nimport { Game } from '../game';\nimport { Entity } from '../core/entity';\nimport { Camera2D, Transform2D } from '../components';\n\nexport interface CameraSystemOptions {\n    /** Default zoom level (default: 1) */\n    defaultZoom?: number;\n    /** Default smoothing (default: 0.1) */\n    defaultSmoothing?: number;\n    /** Minimum zoom level (default: 0.1) */\n    minZoom?: number;\n    /** Maximum zoom level (default: 10) */\n    maxZoom?: number;\n}\n\n/**\n * CameraSystem - manages Camera2D components.\n *\n * @example\n * // Add as plugin\n * const cameraSystem = game.addPlugin(CameraSystem);\n *\n * // Create a camera entity\n * game.defineEntity('camera').with(Camera2D).register();\n * const camera = game.spawn('camera');\n *\n * // Follow an entity\n * cameraSystem.follow(camera, playerEntity);\n *\n * // Or manually set position\n * const cam = camera.get(Camera2D);\n * cam.x = 100;\n * cam.y = 200;\n * cam.zoom = 1.5;\n */\nexport class CameraSystem {\n    private game: Game;\n    private options: Required<CameraSystemOptions>;\n\n    constructor(game: Game, options: CameraSystemOptions = {}) {\n        this.game = game;\n        this.options = {\n            defaultZoom: options.defaultZoom ?? 1,\n            defaultSmoothing: options.defaultSmoothing ?? 0.1,\n            minZoom: options.minZoom ?? 0.1,\n            maxZoom: options.maxZoom ?? 10\n        };\n\n        // Register update system\n        game.addSystem(this.update.bind(this), { phase: 'render' });\n    }\n\n    /**\n     * Update all cameras.\n     */\n    private update(): void {\n        for (const entity of this.game.query('Camera2D')) {\n            this.updateCamera(entity);\n        }\n    }\n\n    /**\n     * Update a single camera entity.\n     */\n    private updateCamera(cameraEntity: Entity): void {\n        const cam = cameraEntity.get(Camera2D);\n\n        // Follow target entity if set\n        if (cam.followEntity !== 0) {\n            const target = this.game.world.getEntity(cam.followEntity);\n            if (target && !target.destroyed) {\n                try {\n                    const transform = target.get(Transform2D);\n                    // Smooth follow\n                    cam.x += (transform.x - cam.x) * cam.smoothing;\n                    cam.y += (transform.y - cam.y) * cam.smoothing;\n                } catch {\n                    // Target doesn't have Transform2D\n                }\n            }\n        }\n\n        // Smooth zoom transition\n        if (cam.zoom !== cam.targetZoom) {\n            cam.zoom += (cam.targetZoom - cam.zoom) * cam.smoothing;\n            // Clamp zoom\n            cam.zoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, cam.zoom));\n        }\n    }\n\n    /**\n     * Set camera to follow an entity.\n     */\n    follow(cameraEntity: Entity, targetEntity: Entity | null): void {\n        const cam = cameraEntity.get(Camera2D);\n        cam.followEntity = targetEntity ? targetEntity.eid : 0;\n    }\n\n    /**\n     * Center camera on multiple entities (weighted by optional areas).\n     */\n    centerOn(cameraEntity: Entity, entities: Entity[], weights?: number[]): void {\n        if (entities.length === 0) return;\n\n        const cam = cameraEntity.get(Camera2D);\n        let totalWeight = 0;\n        let centerX = 0;\n        let centerY = 0;\n\n        for (let i = 0; i < entities.length; i++) {\n            const entity = entities[i];\n            if (entity.destroyed) continue;\n\n            try {\n                const transform = entity.get(Transform2D);\n                const weight = weights?.[i] ?? 1;\n\n                centerX += transform.x * weight;\n                centerY += transform.y * weight;\n                totalWeight += weight;\n            } catch {\n                // Entity doesn't have Transform2D\n            }\n        }\n\n        if (totalWeight > 0) {\n            cam.x += (centerX / totalWeight - cam.x) * cam.smoothing;\n            cam.y += (centerY / totalWeight - cam.y) * cam.smoothing;\n        }\n    }\n\n    /**\n     * Convert world coordinates to screen coordinates.\n     */\n    worldToScreen(cameraEntity: Entity, worldX: number, worldY: number): { x: number; y: number } {\n        const cam = cameraEntity.get(Camera2D);\n        return {\n            x: (worldX - cam.x) * cam.zoom + cam.viewportWidth / 2,\n            y: (worldY - cam.y) * cam.zoom + cam.viewportHeight / 2\n        };\n    }\n\n    /**\n     * Convert screen coordinates to world coordinates.\n     */\n    screenToWorld(cameraEntity: Entity, screenX: number, screenY: number): { x: number; y: number } {\n        const cam = cameraEntity.get(Camera2D);\n        return {\n            x: (screenX - cam.viewportWidth / 2) / cam.zoom + cam.x,\n            y: (screenY - cam.viewportHeight / 2) / cam.zoom + cam.y\n        };\n    }\n\n    /**\n     * Set zoom with optional target position.\n     */\n    setZoom(cameraEntity: Entity, zoom: number, immediate: boolean = false): void {\n        const cam = cameraEntity.get(Camera2D);\n        const clampedZoom = Math.max(this.options.minZoom, Math.min(this.options.maxZoom, zoom));\n        cam.targetZoom = clampedZoom;\n        if (immediate) {\n            cam.zoom = clampedZoom;\n        }\n    }\n\n    /**\n     * Get visible bounds in world coordinates.\n     */\n    getVisibleBounds(cameraEntity: Entity): { left: number; top: number; right: number; bottom: number } {\n        const cam = cameraEntity.get(Camera2D);\n        const halfWidth = (cam.viewportWidth / 2) / cam.zoom;\n        const halfHeight = (cam.viewportHeight / 2) / cam.zoom;\n\n        return {\n            left: cam.x - halfWidth,\n            top: cam.y - halfHeight,\n            right: cam.x + halfWidth,\n            bottom: cam.y + halfHeight\n        };\n    }\n\n    /**\n     * Check if a world point is visible.\n     */\n    isPointVisible(cameraEntity: Entity, worldX: number, worldY: number, margin: number = 0): boolean {\n        const bounds = this.getVisibleBounds(cameraEntity);\n        return worldX >= bounds.left - margin &&\n               worldX <= bounds.right + margin &&\n               worldY >= bounds.top - margin &&\n               worldY <= bounds.bottom + margin;\n    }\n}\n", "/**\r\n * Determinism Guard\r\n *\r\n * Warns developers when non-deterministic functions are called during simulation.\r\n * Suggests deterministic alternatives like dRandom() and dSqrt().\r\n */\r\n\r\nimport type { Game } from '../game';\r\n\r\ninterface OriginalFunctions {\r\n    mathRandom?: typeof Math.random;\r\n    mathSqrt?: typeof Math.sqrt;\r\n    dateNow?: typeof Date.now;\r\n    performanceNow?: typeof performance.now;\r\n}\r\n\r\nconst originalFunctions: OriginalFunctions = {};\r\nlet installedGame: Game | null = null;\r\nlet warnedFunctions: Set<string> = new Set();\r\n\r\nfunction isSimulating(): boolean {\r\n    return installedGame?.world?._isSimulating ?? false;\r\n}\r\n\r\nfunction warnOnce(key: string, message: string) {\r\n    if (!warnedFunctions.has(key)) {\r\n        warnedFunctions.add(key);\r\n        console.warn(message);\r\n    }\r\n}\r\n\r\n/**\r\n * Enable determinism guard for a game instance.\r\n * Warns when dangerous functions are called during simulation.\r\n *\r\n * @example\r\n * const game = createGame();\r\n * enableDeterminismGuard(game);\r\n */\r\nexport function enableDeterminismGuard(game: Game): void {\r\n    if (installedGame) {\r\n        console.warn('Determinism guard already installed for another game instance');\r\n        return;\r\n    }\r\n\r\n    installedGame = game;\r\n    warnedFunctions.clear();\r\n\r\n    // Intercept Math.random\r\n    originalFunctions.mathRandom = Math.random;\r\n    Math.random = function(): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Math.random',\r\n                '\u26A0\uFE0F Math.random() is non-deterministic!\\n' +\r\n                '   Use dRandom() instead for deterministic random numbers.\\n' +\r\n                '   Example: const r = dRandom();'\r\n            );\r\n        }\r\n        return originalFunctions.mathRandom!();\r\n    };\r\n\r\n    // Intercept Math.sqrt\r\n    originalFunctions.mathSqrt = Math.sqrt;\r\n    Math.sqrt = function(x: number): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Math.sqrt',\r\n                '\u26A0\uFE0F Math.sqrt() is non-deterministic!\\n' +\r\n                '   Use dSqrt() instead for deterministic square root.\\n' +\r\n                '   Example: const dist = dSqrt(dx * dx + dy * dy);'\r\n            );\r\n        }\r\n        return originalFunctions.mathSqrt!(x);\r\n    };\r\n\r\n    // Intercept Date.now\r\n    originalFunctions.dateNow = Date.now;\r\n    Date.now = function(): number {\r\n        if (isSimulating()) {\r\n            warnOnce('Date.now',\r\n                '\u26A0\uFE0F Date.now() is non-deterministic!\\n' +\r\n                '   Use game.time instead for deterministic timing.\\n' +\r\n                '   Example: const respawnAt = game.time + 3000;'\r\n            );\r\n        }\r\n        return originalFunctions.dateNow!();\r\n    };\r\n\r\n    // Intercept performance.now\r\n    if (typeof performance !== 'undefined') {\r\n        originalFunctions.performanceNow = performance.now.bind(performance);\r\n        performance.now = function(): number {\r\n            if (isSimulating()) {\r\n                warnOnce('performance.now',\r\n                    '\u26A0\uFE0F performance.now() is non-deterministic!\\n' +\r\n                    '   Use game.time instead for deterministic timing.'\r\n                );\r\n            }\r\n            return originalFunctions.performanceNow!();\r\n        };\r\n    }\r\n\r\n    console.log('\uD83D\uDEE1\uFE0F Determinism guard enabled');\r\n}\r\n\r\n/**\r\n * Disable determinism guard and restore original functions.\r\n */\r\nexport function disableDeterminismGuard(): void {\r\n    if (originalFunctions.mathRandom) {\r\n        Math.random = originalFunctions.mathRandom;\r\n    }\r\n    if (originalFunctions.mathSqrt) {\r\n        Math.sqrt = originalFunctions.mathSqrt;\r\n    }\r\n    if (originalFunctions.dateNow) {\r\n        Date.now = originalFunctions.dateNow;\r\n    }\r\n    if (originalFunctions.performanceNow && typeof performance !== 'undefined') {\r\n        performance.now = originalFunctions.performanceNow;\r\n    }\r\n\r\n    installedGame = null;\r\n    warnedFunctions.clear();\r\n\r\n    // Clear stored references\r\n    Object.keys(originalFunctions).forEach(key => {\r\n        delete (originalFunctions as any)[key];\r\n    });\r\n}\r\n", "// Auto-generated by build-browser.js\nexport const ENGINE_VERSION = 'ad7b993';\nexport const ENGINE_BUILD_DATE = '2026-01-06T21:57:58.850Z';\n", "/**\r\n * Debug UI - Simple stats overlay for game instances\r\n *\r\n * Usage:\r\n *   Modu.enableDebugUI(game);  // Pass game instance\r\n *   Modu.setDebugHash(() => computeMyHash()); // Optional: show live state hash\r\n *\r\n * Also enables determinism guard to warn about non-deterministic function calls.\r\n */\r\n\r\nimport { enableDeterminismGuard } from './determinism-guard';\r\nimport type { Game } from '../game';\r\nimport { ENGINE_VERSION } from '../version';\r\n\r\n/** Interface for objects that can be displayed in debug UI */\r\nexport interface DebugUITarget {\r\n    getClientId(): string | null;\r\n    getFrame(): number;\r\n    getNodeUrl(): string | null;\r\n    getLastSnapshot(): { hash: string | null; frame: number; size: number; entityCount: number };\r\n    getServerFps(): number;\r\n    getRoomId(): string | null;\r\n    getUploadRate(): number;\r\n    getDownloadRate(): number;\r\n    getClients(): string[];\r\n    getStateHash(): string;\r\n    isAuthority?(): boolean;\r\n    getDriftStats?(): { determinismPercent: number; totalChecks: number; matchingFieldCount: number; totalFieldCount: number };\r\n}\r\n\r\nexport interface DebugUIOptions {\r\n    /** Position: 'top-right' (default), 'top-left', 'bottom-right', 'bottom-left' */\r\n    position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';\r\n}\r\n\r\nlet debugDiv: HTMLDivElement | null = null;\r\nlet updateInterval: number | null = null;\r\nlet hashCallback: (() => string | number) | null = null;\r\nlet debugTarget: DebugUITarget | null = null;\r\n\r\n// FPS tracking\r\nlet lastFrameTime = 0;\r\nlet frameCount = 0;\r\nlet renderFps = 0;\r\nlet fpsUpdateTime = 0;\r\n\r\n/**\r\n * Set a callback to compute the current state hash for debug display.\r\n * The hash will be shown in the debug UI and should change as bodies move.\r\n */\r\nexport function setDebugHash(callback: () => string | number): void {\r\n    hashCallback = callback;\r\n}\r\n\r\n/**\r\n * Enable debug UI overlay - shows frame, client, node, snapshot info automatically\r\n * @param target - Object implementing DebugUITarget interface\r\n * @param options - UI options\r\n */\r\nexport function enableDebugUI(target?: DebugUITarget, options: DebugUIOptions = {}): HTMLDivElement {\r\n    if (debugDiv) return debugDiv;\r\n\r\n    // Store target reference for updates\r\n    debugTarget = target || null;\r\n\r\n    // Enable determinism guard if target is a Game instance\r\n    if (target && 'world' in target) {\r\n        enableDeterminismGuard(target as unknown as Game);\r\n    }\r\n\r\n    const pos = options.position || 'top-right';\r\n\r\n    debugDiv = document.createElement('div');\r\n    debugDiv.id = 'modu-debug-ui';\r\n    debugDiv.style.cssText = `\r\n        position: fixed;\r\n        ${pos.includes('top') ? 'top: 10px' : 'bottom: 10px'};\r\n        ${pos.includes('right') ? 'right: 10px' : 'left: 10px'};\r\n        background: rgba(0, 0, 0, 0.8);\r\n        color: #0f0;\r\n        font: 12px monospace;\r\n        padding: 8px 12px;\r\n        border-radius: 4px;\r\n        z-index: 10000;\r\n        min-width: 180px;\r\n        pointer-events: none;\r\n    `;\r\n    document.body.appendChild(debugDiv);\r\n\r\n    // Update loop\r\n    const update = (now: number) => {\r\n        if (!debugDiv) return;\r\n\r\n        // Calculate render FPS\r\n        frameCount++;\r\n        if (now - fpsUpdateTime >= 1000) {\r\n            renderFps = frameCount;\r\n            frameCount = 0;\r\n            fpsUpdateTime = now;\r\n        }\r\n\r\n        const eng = debugTarget;\r\n        if (!eng) {\r\n            debugDiv.innerHTML = '<div style=\"color:#f00\">No engine instance</div>';\r\n            return;\r\n        }\r\n\r\n        const clientId = eng.getClientId();\r\n        const frame = eng.getFrame();\r\n        const nodeUrl = eng.getNodeUrl();\r\n        const lastSnap = eng.getLastSnapshot();\r\n        const fps = eng.getServerFps();\r\n        const roomId = eng.getRoomId();\r\n        const up = eng.getUploadRate();\r\n        const down = eng.getDownloadRate();\r\n        const clients = eng.getClients();\r\n        const isAuthority = (eng as any).isAuthority?.() || false;\r\n\r\n        // Compute live state hash (use custom callback if set, otherwise use engine's hash)\r\n        let currentHash = '--------';\r\n        try {\r\n            if (hashCallback) {\r\n                const hash = hashCallback();\r\n                currentHash = typeof hash === 'number' ? hash.toString(16).padStart(8, '0') : String(hash).slice(0, 8);\r\n            } else {\r\n                currentHash = eng.getStateHash();\r\n            }\r\n        } catch (e) {\r\n            currentHash = 'error';\r\n        }\r\n\r\n        // Format bandwidth with appropriate unit\r\n        const formatBandwidth = (bytes: number): string => {\r\n            if (bytes >= 1024) {\r\n                return (bytes / 1024).toFixed(1) + ' kB/s';\r\n            }\r\n            return Math.round(bytes) + ' B/s';\r\n        };\r\n        const upStr = formatBandwidth(up);\r\n        const downStr = formatBandwidth(down);\r\n\r\n        // Get drift stats (field-by-field comparison)\r\n        const driftStats = (eng as any).getDriftStats?.() || { determinismPercent: 100, totalChecks: 0, matchingFieldCount: 0, totalFieldCount: 0 };\r\n        const detPct = (Math.floor(driftStats.determinismPercent * 10) / 10).toFixed(1);\r\n        const detColor = driftStats.determinismPercent === 100 ? '#0f0' :\r\n                        driftStats.determinismPercent >= 99 ? '#ff0' : '#f00';\r\n\r\n        // Format sync status\r\n        let syncStatus: string;\r\n        if (isAuthority) {\r\n            syncStatus = '<span style=\"color:#888\">I\\'m authority</span>';\r\n        } else if (driftStats.totalChecks === 0) {\r\n            syncStatus = '<span style=\"color:#888\">waiting...</span>';\r\n        } else {\r\n            syncStatus = `<span style=\"color:${detColor}\">${detPct}%</span> <span style=\"color:#888\">(${driftStats.matchingFieldCount}/${driftStats.totalFieldCount})</span>`;\r\n        }\r\n\r\n        // Format received snapshot info with frames ago\r\n        const framesAgo = lastSnap.frame ? frame - lastSnap.frame : 0;\r\n        const snapInfo = lastSnap.hash ? `${lastSnap.hash.slice(0, 8)} <span style=\"color:#888\">(${framesAgo} ago)</span>` : 'none';\r\n\r\n        // Format size with appropriate units\r\n        const formatSize = (bytes: number): string => {\r\n            if (bytes >= 1024 * 1024) {\r\n                return (bytes / (1024 * 1024)).toFixed(2) + ' MB';\r\n            } else if (bytes >= 1024) {\r\n                return (bytes / 1024).toFixed(1) + ' KB';\r\n            }\r\n            return bytes + ' B';\r\n        };\r\n        const sizeStr = lastSnap.size > 0 ? formatSize(lastSnap.size) : '-';\r\n        const entityStr = lastSnap.entityCount > 0 ? String(lastSnap.entityCount) : '-';\r\n\r\n        // Section header style\r\n        const sectionStyle = 'color:#666;font-size:10px;margin-top:6px;margin-bottom:2px;border-bottom:1px solid #333;';\r\n\r\n        debugDiv.innerHTML = `\r\n            <div style=\"${sectionStyle}\">ROOM</div>\r\n            <div>ID: <span style=\"color:#fff\">${roomId || '-'}</span></div>\r\n            <div>Players: <span style=\"color:#ff0\">${clients.length}</span></div>\r\n            <div>Frame: <span style=\"color:#fff\">${frame}</span></div>\r\n            <div>URL: <span style=\"color:#0ff\">${nodeUrl || '-'}</span></div>\r\n\r\n            <div style=\"${sectionStyle}\">ME</div>\r\n            <div>Authority: <span style=\"color:${isAuthority ? '#0ff' : '#888'}\">${isAuthority ? 'Yes' : 'No'}</span></div>\r\n            <div>Client: <span style=\"color:#ff0\">${clientId ? clientId.slice(0, 8) : '-'}</span></div>\r\n\r\n            <div style=\"${sectionStyle}\">ENGINE</div>\r\n            <div>Commit: <span style=\"color:#888\">${ENGINE_VERSION}</span></div>\r\n            <div>FPS: <span style=\"color:#0f0\">${renderFps}</span> render, <span style=\"color:#0f0\">${fps}</span> tick</div>\r\n            <div>Net: <span style=\"color:#0f0\">${upStr}</span> up, <span style=\"color:#f80\">${downStr}</span> down</div>\r\n\r\n            <div style=\"${sectionStyle}\">SNAPSHOT</div>\r\n            <div>Current: <span style=\"color:#f0f\">${currentHash}</span></div>\r\n            <div>Received: <span style=\"color:#f80\">${snapInfo}</span></div>\r\n            <div>Size: <span style=\"color:#fff\">${sizeStr}</span>, Entities: <span style=\"color:#fff\">${entityStr}</span></div>\r\n            <div>Last Sync: ${syncStatus}</div>\r\n        `;\r\n    };\r\n\r\n    // Update every frame\r\n    const loop = (now: number) => {\r\n        update(now);\r\n        updateInterval = requestAnimationFrame(loop) as unknown as number;\r\n    };\r\n    fpsUpdateTime = performance.now();\r\n    requestAnimationFrame(loop);\r\n\r\n    return debugDiv;\r\n}\r\n\r\n/**\r\n * Disable debug UI\r\n */\r\nexport function disableDebugUI(): void {\r\n    if (updateInterval) {\r\n        cancelAnimationFrame(updateInterval);\r\n        updateInterval = null;\r\n    }\r\n    if (debugDiv) {\r\n        debugDiv.remove();\r\n        debugDiv = null;\r\n    }\r\n    debugTarget = null;\r\n}\r\n\r\n/**\r\n * Check if debug UI is enabled\r\n */\r\nexport function isDebugUIEnabled(): boolean {\r\n    return debugDiv !== null;\r\n}\r\n", "/**\r\n * Physics 2D Module\r\n *\r\n * Deterministic 2D physics engine with fixed-point math.\r\n * All components use 16.16 fixed-point integers for 100% determinism.\r\n */\r\n\r\n// Shapes and AABB\r\nexport { Shape2DType, CircleShape, BoxShape2D, Shape2D, AABB2D, aabb2DOverlap, aabb2DUnion, aabb2DArea, createCircle, createBox2D, createBox2DFromSize } from './shapes';\r\n\r\n// Collision Layers\r\nexport { CollisionFilter, Layers, DEFAULT_FILTER, createFilter, shouldCollide, filterCollidingWith, filterExcluding } from './layers';\r\n\r\n// Rigid Body\r\nexport { BodyType2D, Vec2, vec2, vec2Zero, vec2Clone, vec2Add, vec2Sub, vec2Scale, vec2Dot, vec2LengthSq, vec2Cross, RigidBody2D, resetBody2DIdCounter, getBody2DIdCounter, setBody2DIdCounter, createBody2D, setBody2DMass, setBody2DVelocity, applyImpulse2D, applyForce2D } from './rigid-body';\r\n\r\n// Collision Detection and Response\r\nexport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\r\n\r\n// Physics World\r\nexport { World2D, createWorld2D, addBody2D, removeBody2D, stepWorld2D, saveWorldState2D, loadWorldState2D, BodyState2D, WorldState2D } from './world';\r\n\r\n// Spatial Partitioning\r\nexport { SpatialHash2D } from './spatial-hash';\r\nexport { QuadTree2D } from './quad-tree';\r\n\r\n// Triggers/Sensors\r\nexport { TriggerEvent, TriggerState, makeTrigger } from './trigger';\r\n", "/**\r\n * 2D Physics Shapes\r\n *\r\n * Defines 2D collision shapes: Circle and Box (AABB).\r\n * Uses fixed-point math for determinism.\r\n */\r\n\r\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpMin, fpMax } from '../../math/fixed';\r\n\r\n// ============================================\r\n// Types\r\n// ============================================\r\n\r\nexport enum Shape2DType {\r\n    Circle = 0,\r\n    Box = 1,\r\n}\r\n\r\nexport interface CircleShape {\r\n    type: Shape2DType.Circle;\r\n    radius: Fixed;\r\n}\r\n\r\nexport interface BoxShape2D {\r\n    type: Shape2DType.Box;\r\n    halfWidth: Fixed;   // Half extent on X axis\r\n    halfHeight: Fixed;  // Half extent on Y axis\r\n}\r\n\r\nexport type Shape2D = CircleShape | BoxShape2D;\r\n\r\n// ============================================\r\n// AABB (Axis-Aligned Bounding Box)\r\n// ============================================\r\n\r\nexport interface AABB2D {\r\n    minX: Fixed;\r\n    minY: Fixed;\r\n    maxX: Fixed;\r\n    maxY: Fixed;\r\n}\r\n\r\n/**\r\n * Check if two AABBs overlap.\r\n */\r\nexport function aabb2DOverlap(a: AABB2D, b: AABB2D): boolean {\r\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\r\n           a.minY <= b.maxY && a.maxY >= b.minY;\r\n}\r\n\r\n/**\r\n * Compute the union of two AABBs.\r\n */\r\nexport function aabb2DUnion(a: AABB2D, b: AABB2D): AABB2D {\r\n    return {\r\n        minX: fpMin(a.minX, b.minX),\r\n        minY: fpMin(a.minY, b.minY),\r\n        maxX: fpMax(a.maxX, b.maxX),\r\n        maxY: fpMax(a.maxY, b.maxY),\r\n    };\r\n}\r\n\r\n/**\r\n * Compute the area of an AABB.\r\n */\r\nexport function aabb2DArea(aabb: AABB2D): Fixed {\r\n    const width = aabb.maxX - aabb.minX;\r\n    const height = aabb.maxY - aabb.minY;\r\n    return fpMul(width as Fixed, height as Fixed);\r\n}\r\n\r\n// ============================================\r\n// Shape Factories\r\n// ============================================\r\n\r\n/**\r\n * Create a circle shape.\r\n */\r\nexport function createCircle(radius: number): CircleShape {\r\n    return {\r\n        type: Shape2DType.Circle,\r\n        radius: toFixed(radius),\r\n    };\r\n}\r\n\r\n/**\r\n * Create a box shape from half-extents.\r\n */\r\nexport function createBox2D(halfWidth: number, halfHeight: number): BoxShape2D {\r\n    return {\r\n        type: Shape2DType.Box,\r\n        halfWidth: toFixed(halfWidth),\r\n        halfHeight: toFixed(halfHeight),\r\n    };\r\n}\r\n\r\n/**\r\n * Create a box shape from full dimensions.\r\n * Uses bit shift for deterministic halving.\r\n */\r\nexport function createBox2DFromSize(width: number, height: number): BoxShape2D {\r\n    // Use bit shift instead of floating-point division for determinism\r\n    const halfWidth = (toFixed(width) >> 1) as Fixed;\r\n    const halfHeight = (toFixed(height) >> 1) as Fixed;\r\n    return {\r\n        type: Shape2DType.Box,\r\n        halfWidth,\r\n        halfHeight,\r\n    };\r\n}\r\n", "/**\r\n * Collision Layers\r\n *\r\n * Controls which bodies can collide with each other using bitmasks.\r\n * Layer = \"what am I\", Mask = \"what do I collide with\"\r\n *\r\n * Shared between 2D and 3D physics engines.\r\n */\r\n\r\n// ============================================\r\n// Collision Filter\r\n// ============================================\r\n\r\nexport interface CollisionFilter {\r\n    /** Which layer this body belongs to (single bit) */\r\n    layer: number;\r\n    /** Which layers this body collides with (bitmask) */\r\n    mask: number;\r\n}\r\n\r\n// ============================================\r\n// Default Layers\r\n// ============================================\r\n\r\nexport const Layers = {\r\n    NONE: 0,\r\n    DEFAULT: 1 << 0,      // 1\r\n    PLAYER: 1 << 1,       // 2\r\n    ENEMY: 1 << 2,        // 4\r\n    PROJECTILE: 1 << 3,   // 8\r\n    ITEM: 1 << 4,         // 16\r\n    TRIGGER: 1 << 5,      // 32\r\n    WORLD: 1 << 6,        // 64\r\n    PROP: 1 << 7,         // 128\r\n    // Layers 8-15 reserved for game-specific use\r\n    CUSTOM_1: 1 << 8,\r\n    CUSTOM_2: 1 << 9,\r\n    CUSTOM_3: 1 << 10,\r\n    CUSTOM_4: 1 << 11,\r\n    CUSTOM_5: 1 << 12,\r\n    CUSTOM_6: 1 << 13,\r\n    CUSTOM_7: 1 << 14,\r\n    CUSTOM_8: 1 << 15,\r\n    ALL: 0xFFFF           // All layers\r\n} as const;\r\n\r\n// ============================================\r\n// Default Filter\r\n// ============================================\r\n\r\n/**\r\n * Default collision filter - collides with everything\r\n */\r\nexport const DEFAULT_FILTER: CollisionFilter = {\r\n    layer: Layers.DEFAULT,\r\n    mask: Layers.ALL\r\n};\r\n\r\n// ============================================\r\n// Filter Helpers\r\n// ============================================\r\n\r\n/**\r\n * Create a collision filter\r\n */\r\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\r\n    return { layer, mask };\r\n}\r\n\r\n/**\r\n * Check if two filters allow collision\r\n * Both must have the other in their mask\r\n */\r\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\r\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\r\n}\r\n\r\n/**\r\n * Create a filter that collides with specific layers\r\n */\r\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\r\n    let mask = 0;\r\n    for (const l of collidesWithLayers) {\r\n        mask |= l;\r\n    }\r\n    return { layer, mask };\r\n}\r\n\r\n/**\r\n * Create a filter that collides with everything except specific layers\r\n */\r\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\r\n    let mask = Layers.ALL;\r\n    for (const l of excludeLayers) {\r\n        mask &= ~l;\r\n    }\r\n    return { layer, mask };\r\n}\r\n", "/**\n * 2D Rigid Body\n *\n * Defines 2D rigid body with position, rotation (angle), velocity.\n * Uses fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2D, Shape2DType, CircleShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);\nconst FRICTION_DEFAULT = toFixed(0.5);\n\n// Pre-computed fixed-point constants for deterministic inertia calculations\nconst FP_ONE_TWELFTH = 5461 as Fixed;  // 65536 / 12 = 5461.33... -> 5461\n\n// ============================================\n// Types\n// ============================================\n\nexport enum BodyType2D {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n/**\n * 2D Vector using fixed-point math.\n */\nexport interface Vec2 {\n    x: Fixed;\n    y: Fixed;\n}\n\nexport function vec2Zero(): Vec2 {\n    return { x: 0, y: 0 };\n}\n\nexport function vec2(x: number, y: number): Vec2 {\n    return { x: toFixed(x), y: toFixed(y) };\n}\n\nexport function vec2Clone(v: Vec2): Vec2 {\n    return { x: v.x, y: v.y };\n}\n\nexport function vec2Add(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x + b.x) as Fixed, y: (a.y + b.y) as Fixed };\n}\n\nexport function vec2Sub(a: Vec2, b: Vec2): Vec2 {\n    return { x: (a.x - b.x) as Fixed, y: (a.y - b.y) as Fixed };\n}\n\nexport function vec2Scale(v: Vec2, s: Fixed): Vec2 {\n    return { x: fpMul(v.x, s), y: fpMul(v.y, s) };\n}\n\nexport function vec2Dot(a: Vec2, b: Vec2): Fixed {\n    return (fpMul(a.x, b.x) + fpMul(a.y, b.y)) as Fixed;\n}\n\nexport function vec2LengthSq(v: Vec2): Fixed {\n    return (fpMul(v.x, v.x) + fpMul(v.y, v.y)) as Fixed;\n}\n\nexport function vec2Cross(a: Vec2, b: Vec2): Fixed {\n    // 2D cross product returns scalar (z component of 3D cross)\n    return (fpMul(a.x, b.y) - fpMul(a.y, b.x)) as Fixed;\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody2D {\n    id: number;\n    type: BodyType2D;\n    shape: Shape2D;\n    label: string;\n\n    // Transform\n    position: Vec2;\n    angle: Fixed;  // Rotation in radians (not quaternion like 3D)\n\n    // Velocity\n    linearVelocity: Vec2;\n    angularVelocity: Fixed;  // Radians per second\n\n    // Mass properties\n    mass: Fixed;\n    invMass: Fixed;\n    inertia: Fixed;\n    invInertia: Fixed;\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotation: boolean;\n    isSensor: boolean;\n    isBullet: boolean;  // Enable CCD (continuous collision detection) for fast-moving objects\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId2D = 1;\n\nexport function resetBody2DIdCounter(): void {\n    nextBodyId2D = 1;\n}\n\nexport function getBody2DIdCounter(): number {\n    return nextBodyId2D;\n}\n\nexport function setBody2DIdCounter(value: number): void {\n    nextBodyId2D = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody2D(\n    type: BodyType2D,\n    shape: Shape2D,\n    x: number,\n    y: number,\n    label?: string\n): RigidBody2D {\n    const mass = type === BodyType2D.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType2D.Dynamic ? FP_ONE : 0;\n\n    // Calculate moment of inertia using pre-computed constants\n    let inertia = 0;\n    if (type === BodyType2D.Dynamic) {\n        if (shape.type === Shape2DType.Circle) {\n            // I = (1/2) * m * r\u00B2\n            const r = (shape as CircleShape).radius;\n            inertia = fpMul(fpMul(mass, FP_HALF), fpMul(r, r));\n        } else {\n            // I = (1/12) * m * (w\u00B2 + h\u00B2)\n            // Use bit shift for *2 instead of fpMul with toFixed(2)\n            const w = (shape.halfWidth << 1) as Fixed;\n            const h = (shape.halfHeight << 1) as Fixed;\n            inertia = fpMul(fpMul(mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\n        }\n    }\n\n    // Always increment counter for new bodies (ID will be overwritten for snapshot restoration)\n    const bodyId = nextBodyId2D++;\n    const bodyLabel = label || 'body2d_' + bodyId;\n\n    return {\n        id: bodyId,\n        type,\n        shape,\n        label: bodyLabel,\n        position: vec2(x, y),\n        angle: 0,\n        linearVelocity: vec2Zero(),\n        angularVelocity: 0,\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotation: false,\n        isSensor: false,\n        isBullet: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBody2DMass(body: RigidBody2D, mass: number): void {\n    if (body.type !== BodyType2D.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBody2DVelocity(body: RigidBody2D, vx: number, vy: number): void {\n    body.linearVelocity = vec2(vx, vy);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse2D(body: RigidBody2D, impulse: Vec2, point?: Vec2): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(impulse, body.invMass));\n\n    if (point && !body.lockRotation) {\n        const r = vec2Sub(point, body.position);\n        const torque = vec2Cross(r, impulse);\n        body.angularVelocity = (body.angularVelocity + fpMul(torque, body.invInertia)) as Fixed;\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce2D(body: RigidBody2D, force: Vec2, dt: Fixed): void {\n    if (body.type !== BodyType2D.Dynamic || body.invMass === 0) return;\n    const impulse = vec2Scale(force, dt);\n    applyImpulse2D(body, impulse);\n}\n", "/**\n * 2D Collision Detection and Response\n *\n * Uses Box2D-style collision detection:\n * - SAT (Separating Axis Theorem) for box-box\n * - Closest point on box for circle-box\n * - Direct distance for circle-circle\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt, fpMin, fpMax, fpSin, fpCos } from '../../math/fixed';\nimport { Shape2DType, Shape2D, CircleShape, BoxShape2D, AABB2D } from './shapes';\nimport { RigidBody2D, Vec2, vec2, vec2Zero, vec2Sub, vec2Add, vec2Scale, vec2Dot, vec2LengthSq, BodyType2D } from './rigid-body';\n\n// ============================================\n// Contact\n// ============================================\n\nexport interface Contact2D {\n    bodyA: RigidBody2D;\n    bodyB: RigidBody2D;\n    point: Vec2;\n    normal: Vec2;  // Points from A to B\n    depth: Fixed;\n}\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB2D(body: RigidBody2D): AABB2D {\n    const { position, shape, angle } = body;\n\n    if (shape.type === Shape2DType.Circle) {\n        const radius = (shape as CircleShape).radius;\n        return {\n            minX: (position.x - radius) as Fixed,\n            minY: (position.y - radius) as Fixed,\n            maxX: (position.x + radius) as Fixed,\n            maxY: (position.y + radius) as Fixed,\n        };\n    } else {\n        const box = shape as BoxShape2D;\n        const halfWidth = box.halfWidth;\n        const halfHeight = box.halfHeight;\n\n        if (angle === 0) {\n            return {\n                minX: (position.x - halfWidth) as Fixed,\n                minY: (position.y - halfHeight) as Fixed,\n                maxX: (position.x + halfWidth) as Fixed,\n                maxY: (position.y + halfHeight) as Fixed,\n            };\n        }\n\n        // Rotated box - compute bounding box\n        const cosAngle = fpCos(angle);\n        const sinAngle = fpSin(angle);\n        const absCos = fpAbs(cosAngle);\n        const absSin = fpAbs(sinAngle);\n\n        const extentX = (fpMul(halfWidth, absCos) + fpMul(halfHeight, absSin)) as Fixed;\n        const extentY = (fpMul(halfWidth, absSin) + fpMul(halfHeight, absCos)) as Fixed;\n\n        return {\n            minX: (position.x - extentX) as Fixed,\n            minY: (position.y - extentY) as Fixed,\n            maxX: (position.x + extentX) as Fixed,\n            maxY: (position.y + extentY) as Fixed,\n        };\n    }\n}\n\n// ============================================\n// Collision Detection\n// ============================================\n\nexport function detectCollision2D(bodyA: RigidBody2D, bodyB: RigidBody2D): Contact2D | null {\n    const shapeA = bodyA.shape;\n    const shapeB = bodyB.shape;\n\n    // Circle-Circle\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Circle) {\n        return detectCircleCircle(bodyA, bodyB);\n    }\n\n    // Box-Box\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Box) {\n        return detectBoxBox(bodyA, bodyB);\n    }\n\n    // Circle-Box (ensure circle is always first for consistent normal direction)\n    if (shapeA.type === Shape2DType.Circle && shapeB.type === Shape2DType.Box) {\n        return detectCircleBox(bodyA, bodyB);\n    }\n    if (shapeA.type === Shape2DType.Box && shapeB.type === Shape2DType.Circle) {\n        const contact = detectCircleBox(bodyB, bodyA);\n        if (contact) {\n            // Swap bodies and flip normal to maintain A->B convention\n            return {\n                bodyA: bodyA,\n                bodyB: bodyB,\n                point: contact.point,\n                normal: { x: (-contact.normal.x) as Fixed, y: (-contact.normal.y) as Fixed },\n                depth: contact.depth\n            };\n        }\n        return null;\n    }\n\n    return null;\n}\n\n/**\n * Circle vs Circle collision detection\n */\nfunction detectCircleCircle(circleA: RigidBody2D, circleB: RigidBody2D): Contact2D | null {\n    const radiusA = (circleA.shape as CircleShape).radius;\n    const radiusB = (circleB.shape as CircleShape).radius;\n    const sumRadius = (radiusA + radiusB) as Fixed;\n\n    // Vector from A to B\n    const deltaX = (circleB.position.x - circleA.position.x) as Fixed;\n    const deltaY = (circleB.position.y - circleA.position.y) as Fixed;\n    const distanceSq = (fpMul(deltaX, deltaX) + fpMul(deltaY, deltaY)) as Fixed;\n    const minDistSq = fpMul(sumRadius, sumRadius);\n\n    if (distanceSq >= minDistSq) return null;\n\n    const distance = fpSqrt(distanceSq);\n    const penetration = (sumRadius - distance) as Fixed;\n\n    // Normal points from A to B\n    let normalX: Fixed, normalY: Fixed;\n    if (distance > 0) {\n        const invDist = fpDiv(FP_ONE, distance);\n        normalX = fpMul(deltaX, invDist);\n        normalY = fpMul(deltaY, invDist);\n    } else {\n        // Circles at same position - arbitrary normal\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n    }\n\n    // Contact point on surface of A\n    const contactX = (circleA.position.x + fpMul(normalX, radiusA)) as Fixed;\n    const contactY = (circleA.position.y + fpMul(normalY, radiusA)) as Fixed;\n\n    return {\n        bodyA: circleA,\n        bodyB: circleB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Box vs Box collision detection (AABB - assumes no rotation)\n */\nfunction detectBoxBox(boxA: RigidBody2D, boxB: RigidBody2D): Contact2D | null {\n    const shapeA = boxA.shape as BoxShape2D;\n    const shapeB = boxB.shape as BoxShape2D;\n\n    // Vector from A to B\n    const deltaX = (boxB.position.x - boxA.position.x) as Fixed;\n    const deltaY = (boxB.position.y - boxA.position.y) as Fixed;\n\n    // Overlap on each axis\n    const overlapX = ((shapeA.halfWidth + shapeB.halfWidth) - fpAbs(deltaX)) as Fixed;\n    const overlapY = ((shapeA.halfHeight + shapeB.halfHeight) - fpAbs(deltaY)) as Fixed;\n\n    if (overlapX <= 0 || overlapY <= 0) return null;\n\n    // Use axis with minimum overlap (SAT)\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (overlapX < overlapY) {\n        penetration = overlapX;\n        normalX = deltaX > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n        normalY = 0 as Fixed;\n    } else {\n        penetration = overlapY;\n        normalX = 0 as Fixed;\n        normalY = deltaY > 0 ? FP_ONE : (-FP_ONE) as Fixed;\n    }\n\n    // Contact point at midpoint\n    const contactX = ((boxA.position.x + boxB.position.x) >> 1) as Fixed;\n    const contactY = ((boxA.position.y + boxB.position.y) >> 1) as Fixed;\n\n    return {\n        bodyA: boxA,\n        bodyB: boxB,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n/**\n * Circle vs Box collision detection\n * Box2D-style: find closest point on box, check distance to circle center\n */\nfunction detectCircleBox(circle: RigidBody2D, box: RigidBody2D): Contact2D | null {\n    const radius = (circle.shape as CircleShape).radius;\n    const boxShape = box.shape as BoxShape2D;\n\n    // Circle center in box's local space (box at origin)\n    const localX = (circle.position.x - box.position.x) as Fixed;\n    const localY = (circle.position.y - box.position.y) as Fixed;\n\n    // Clamp to box bounds to find closest point\n    const clampedX = fpMax((-boxShape.halfWidth) as Fixed, fpMin(boxShape.halfWidth, localX));\n    const clampedY = fpMax((-boxShape.halfHeight) as Fixed, fpMin(boxShape.halfHeight, localY));\n\n    // Check if circle center is inside box\n    const centerInside = fpAbs(localX) < boxShape.halfWidth && fpAbs(localY) < boxShape.halfHeight;\n\n    let normalX: Fixed, normalY: Fixed;\n    let penetration: Fixed;\n\n    if (centerInside) {\n        // Circle center is inside box - find closest face\n        const distToRight = (boxShape.halfWidth - localX) as Fixed;\n        const distToLeft = (boxShape.halfWidth + localX) as Fixed;\n        const distToTop = (boxShape.halfHeight - localY) as Fixed;\n        const distToBottom = (boxShape.halfHeight + localY) as Fixed;\n\n        // Find minimum distance to any face\n        let minDist = distToRight;\n        normalX = FP_ONE;\n        normalY = 0 as Fixed;\n\n        if (distToLeft < minDist) {\n            minDist = distToLeft;\n            normalX = (-FP_ONE) as Fixed;\n            normalY = 0 as Fixed;\n        }\n        if (distToTop < minDist) {\n            minDist = distToTop;\n            normalX = 0 as Fixed;\n            normalY = FP_ONE;\n        }\n        if (distToBottom < minDist) {\n            minDist = distToBottom;\n            normalX = 0 as Fixed;\n            normalY = (-FP_ONE) as Fixed;\n        }\n\n        // Penetration is distance to face plus radius\n        penetration = (minDist + radius) as Fixed;\n    } else {\n        // Circle center is outside box - normal case\n        const diffX = (localX - clampedX) as Fixed;\n        const diffY = (localY - clampedY) as Fixed;\n        const distanceSq = (fpMul(diffX, diffX) + fpMul(diffY, diffY)) as Fixed;\n\n        // No collision if distance > radius\n        if (distanceSq >= fpMul(radius, radius)) return null;\n\n        const distance = fpSqrt(distanceSq);\n        penetration = (radius - distance) as Fixed;\n\n        if (distance > 0) {\n            const invDist = fpDiv(FP_ONE, distance);\n            // Normal points from circle toward box (from A to B)\n            // diffX/diffY points from box surface toward circle, so negate\n            normalX = fpMul((-diffX) as Fixed, invDist);\n            normalY = fpMul((-diffY) as Fixed, invDist);\n        } else {\n            // Edge case: circle exactly on box corner\n            normalX = FP_ONE;\n            normalY = 0 as Fixed;\n        }\n    }\n\n    // Contact point on circle surface (toward box)\n    const contactX = (circle.position.x + fpMul(normalX, radius)) as Fixed;\n    const contactY = (circle.position.y + fpMul(normalY, radius)) as Fixed;\n\n    return {\n        bodyA: circle,\n        bodyB: box,\n        point: { x: contactX, y: contactY },\n        normal: { x: normalX, y: normalY },\n        depth: penetration\n    };\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\n/**\n * Resolve collision by applying position correction and velocity impulses.\n *\n * For kinematic bodies: position correction only (no velocity response)\n * For dynamic bodies: both position and velocity correction\n */\nexport function resolveCollision2D(contact: Contact2D): void {\n    const { bodyA, bodyB, normal, depth } = contact;\n\n    // Skip triggers\n    if (bodyA.isSensor || bodyB.isSensor) return;\n\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Static-Static: nothing to do\n    if (typeA === BodyType2D.Static && typeB === BodyType2D.Static) return;\n\n    // Apply position correction based on body types\n    applyPositionCorrection(bodyA, bodyB, normal, depth);\n\n    // Apply velocity impulses only for dynamic bodies\n    if (typeA === BodyType2D.Dynamic || typeB === BodyType2D.Dynamic) {\n        applyVelocityImpulse(bodyA, bodyB, normal);\n    }\n}\n\n/**\n * Apply position correction to separate overlapping bodies.\n * Called once per contact, not iterated.\n */\nfunction applyPositionCorrection(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    depth: Fixed\n): void {\n    const typeA = bodyA.type;\n    const typeB = bodyB.type;\n\n    // Determine how to distribute the correction\n    const aMovable = typeA !== BodyType2D.Static;\n    const bMovable = typeB !== BodyType2D.Static;\n\n    if (!aMovable && !bMovable) return;\n\n    // Tiny slop to prevent jitter (0.01 units)\n    const slop = toFixed(0.01);\n    const correctionDepth = fpMax(0 as Fixed, (depth - slop) as Fixed);\n\n    if (correctionDepth <= 0) return;\n\n    if (aMovable && bMovable) {\n        // Both movable: split correction equally\n        const halfCorrection = (correctionDepth >> 1) as Fixed;\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, halfCorrection)) as Fixed;\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, halfCorrection)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, halfCorrection)) as Fixed;\n    } else if (aMovable) {\n        // Only A moves\n        bodyA.position.x = (bodyA.position.x - fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyA.position.y = (bodyA.position.y - fpMul(normal.y, correctionDepth)) as Fixed;\n    } else {\n        // Only B moves\n        bodyB.position.x = (bodyB.position.x + fpMul(normal.x, correctionDepth)) as Fixed;\n        bodyB.position.y = (bodyB.position.y + fpMul(normal.y, correctionDepth)) as Fixed;\n    }\n}\n\n/**\n * Apply velocity impulse for dynamic body collisions.\n */\nfunction applyVelocityImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2\n): void {\n    // Get effective inverse masses (0 for non-dynamic)\n    const invMassA = bodyA.type === BodyType2D.Dynamic ? bodyA.invMass : 0 as Fixed;\n    const invMassB = bodyB.type === BodyType2D.Dynamic ? bodyB.invMass : 0 as Fixed;\n    const totalInvMass = (invMassA + invMassB) as Fixed;\n\n    if (totalInvMass === 0) return;\n\n    // Relative velocity (B relative to A)\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    // Velocity along collision normal\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Don't resolve if separating\n    if (velAlongNormal > 0) return;\n\n    // Coefficient of restitution (bounciness)\n    const restitution = fpMin(bodyA.restitution, bodyB.restitution);\n\n    // Impulse magnitude\n    const impulseMag = fpDiv(\n        fpMul((-(FP_ONE + restitution)) as Fixed, velAlongNormal),\n        totalInvMass\n    );\n\n    // Apply impulse\n    const impulseX = fpMul(normal.x, impulseMag);\n    const impulseY = fpMul(normal.y, impulseMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(impulseX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(impulseY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(impulseX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(impulseY, invMassB)) as Fixed;\n    }\n\n    // Friction impulse\n    applyFrictionImpulse(bodyA, bodyB, normal, impulseMag, invMassA, invMassB, totalInvMass);\n}\n\n/**\n * Apply friction impulse tangent to collision normal.\n */\nfunction applyFrictionImpulse(\n    bodyA: RigidBody2D,\n    bodyB: RigidBody2D,\n    normal: Vec2,\n    normalImpulse: Fixed,\n    invMassA: Fixed,\n    invMassB: Fixed,\n    totalInvMass: Fixed\n): void {\n    // Recalculate relative velocity after normal impulse\n    const relVelX = (bodyB.linearVelocity.x - bodyA.linearVelocity.x) as Fixed;\n    const relVelY = (bodyB.linearVelocity.y - bodyA.linearVelocity.y) as Fixed;\n\n    const velAlongNormal = (fpMul(relVelX, normal.x) + fpMul(relVelY, normal.y)) as Fixed;\n\n    // Tangent velocity\n    const tangentX = (relVelX - fpMul(normal.x, velAlongNormal)) as Fixed;\n    const tangentY = (relVelY - fpMul(normal.y, velAlongNormal)) as Fixed;\n    const tangentLenSq = (fpMul(tangentX, tangentX) + fpMul(tangentY, tangentY)) as Fixed;\n\n    if (tangentLenSq === 0) return;\n\n    const tangentLen = fpSqrt(tangentLenSq);\n    const invTangentLen = fpDiv(FP_ONE, tangentLen);\n    const tangentNormX = fpMul(tangentX, invTangentLen);\n    const tangentNormY = fpMul(tangentY, invTangentLen);\n\n    // Friction coefficient\n    const friction = fpMul(bodyA.friction, bodyB.friction);\n\n    // Friction impulse magnitude\n    const tangentVel = (fpMul(relVelX, tangentNormX) + fpMul(relVelY, tangentNormY)) as Fixed;\n    let frictionMag = fpDiv(-tangentVel, totalInvMass);\n\n    // Coulomb friction: clamp to mu * normal force\n    const maxFriction = fpMul(friction, fpAbs(normalImpulse));\n    if (fpAbs(frictionMag) > maxFriction) {\n        frictionMag = frictionMag > 0 ? maxFriction : (-maxFriction) as Fixed;\n    }\n\n    // Apply friction\n    const frictionX = fpMul(tangentNormX, frictionMag);\n    const frictionY = fpMul(tangentNormY, frictionMag);\n\n    if (bodyA.type === BodyType2D.Dynamic) {\n        bodyA.linearVelocity.x = (bodyA.linearVelocity.x - fpMul(frictionX, invMassA)) as Fixed;\n        bodyA.linearVelocity.y = (bodyA.linearVelocity.y - fpMul(frictionY, invMassA)) as Fixed;\n    }\n    if (bodyB.type === BodyType2D.Dynamic) {\n        bodyB.linearVelocity.x = (bodyB.linearVelocity.x + fpMul(frictionX, invMassB)) as Fixed;\n        bodyB.linearVelocity.y = (bodyB.linearVelocity.y + fpMul(frictionY, invMassB)) as Fixed;\n    }\n}\n", "/**\r\n * Spatial Hash Grid for O(1) Broad Phase Collision Detection\r\n *\r\n * Divides the world into fixed-size cells. Bodies are hashed to cells\r\n * based on their position. Collision queries only check nearby cells.\r\n *\r\n * Handles oversized entities (larger than cell size) by checking them\r\n * against all other entities - since there are typically few of these,\r\n * the O(n) cost is acceptable.\r\n *\r\n * Optimal for .io games with many uniform-sized entities (food, bullets)\r\n * plus a few large obstacles or grown players.\r\n */\r\n\r\nimport { RigidBody2D } from './rigid-body';\r\nimport { Fixed, toFloat } from '../../math/fixed';\r\nimport { Shape2DType, CircleShape, BoxShape2D } from './shapes';\r\n\r\n// ============================================\r\n// Helper: Get body radius for size comparison\r\n// ============================================\r\n\r\nfunction getBodyRadius(body: RigidBody2D): number {\r\n    if (body.shape.type === Shape2DType.Circle) {\r\n        return toFloat((body.shape as CircleShape).radius);\r\n    } else {\r\n        const box = body.shape as BoxShape2D;\r\n        // Use diagonal half-length as radius\r\n        const hw = toFloat(box.halfWidth);\r\n        const hh = toFloat(box.halfHeight);\r\n        return Math.sqrt(hw * hw + hh * hh);\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Spatial Hash Grid\r\n// ============================================\r\n\r\nexport class SpatialHash2D {\r\n    private cellSize: number;\r\n    private invCellSize: number;\r\n    private cells: Map<number, RigidBody2D[]> = new Map();\r\n    private bodyToCell: Map<RigidBody2D, number> = new Map();\r\n\r\n    // Oversized entities (diameter > cellSize) - checked against all others\r\n    private oversized: RigidBody2D[] = [];\r\n    // All regular (non-oversized) bodies for oversized checks\r\n    private allRegular: RigidBody2D[] = [];\r\n\r\n    /**\r\n     * Create a spatial hash grid.\r\n     * @param cellSize Size of each cell. Entities larger than this are\r\n     *                 handled specially (checked against all others).\r\n     */\r\n    constructor(cellSize: number = 64) {\r\n        this.cellSize = cellSize;\r\n        this.invCellSize = 1 / cellSize;\r\n    }\r\n\r\n    /**\r\n     * Hash a position to a cell key.\r\n     * Uses bit packing for fast integer key: (x << 16) | y\r\n     */\r\n    private hashPosition(x: number, y: number): number {\r\n        const cellX = Math.floor(x * this.invCellSize) & 0xFFFF;\r\n        const cellY = Math.floor(y * this.invCellSize) & 0xFFFF;\r\n        return (cellX << 16) | cellY;\r\n    }\r\n\r\n    /**\r\n     * Clear all cells (call at start of each frame).\r\n     */\r\n    clear(): void {\r\n        this.cells.clear();\r\n        this.bodyToCell.clear();\r\n        this.oversized.length = 0;\r\n        this.allRegular.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Insert a body into the grid.\r\n     * Oversized bodies (diameter > cellSize) are tracked separately.\r\n     */\r\n    insert(body: RigidBody2D): void {\r\n        const radius = getBodyRadius(body);\r\n        const diameter = radius * 2;\r\n\r\n        // Oversized entities are checked against everything\r\n        if (diameter > this.cellSize) {\r\n            this.oversized.push(body);\r\n            return;\r\n        }\r\n\r\n        // Regular entities go into spatial hash\r\n        this.allRegular.push(body);\r\n\r\n        const x = toFloat(body.position.x);\r\n        const y = toFloat(body.position.y);\r\n        const key = this.hashPosition(x, y);\r\n\r\n        let cell = this.cells.get(key);\r\n        if (!cell) {\r\n            cell = [];\r\n            this.cells.set(key, cell);\r\n        }\r\n        cell.push(body);\r\n        this.bodyToCell.set(body, key);\r\n    }\r\n\r\n    /**\r\n     * Insert all bodies into the grid.\r\n     */\r\n    insertAll(bodies: RigidBody2D[]): void {\r\n        for (const body of bodies) {\r\n            this.insert(body);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all bodies in the same cell as a position.\r\n     */\r\n    queryPoint(x: number, y: number): RigidBody2D[] {\r\n        const key = this.hashPosition(x, y);\r\n        return this.cells.get(key) || [];\r\n    }\r\n\r\n    /**\r\n     * Get all bodies in the same and adjacent cells (3x3 neighborhood).\r\n     * This handles bodies near cell boundaries.\r\n     */\r\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\r\n        const x = toFloat(body.position.x);\r\n        const y = toFloat(body.position.y);\r\n        const cellX = Math.floor(x * this.invCellSize);\r\n        const cellY = Math.floor(y * this.invCellSize);\r\n\r\n        const result: RigidBody2D[] = [];\r\n\r\n        // Check 3x3 grid of cells\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            for (let dy = -1; dy <= 1; dy++) {\r\n                const nx = (cellX + dx) & 0xFFFF;\r\n                const ny = (cellY + dy) & 0xFFFF;\r\n                const key = (nx << 16) | ny;\r\n                const cell = this.cells.get(key);\r\n                if (cell) {\r\n                    for (const other of cell) {\r\n                        if (other !== body) {\r\n                            result.push(other);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Query bodies within a radius (for larger entities that span multiple cells).\r\n     */\r\n    queryRadius(x: number, y: number, radius: number): RigidBody2D[] {\r\n        const cellRadius = Math.ceil(radius * this.invCellSize);\r\n        const cellX = Math.floor(x * this.invCellSize);\r\n        const cellY = Math.floor(y * this.invCellSize);\r\n\r\n        const result: RigidBody2D[] = [];\r\n        const seen = new Set<RigidBody2D>();\r\n\r\n        for (let dx = -cellRadius; dx <= cellRadius; dx++) {\r\n            for (let dy = -cellRadius; dy <= cellRadius; dy++) {\r\n                const nx = (cellX + dx) & 0xFFFF;\r\n                const ny = (cellY + dy) & 0xFFFF;\r\n                const key = (nx << 16) | ny;\r\n                const cell = this.cells.get(key);\r\n                if (cell) {\r\n                    for (const body of cell) {\r\n                        if (!seen.has(body)) {\r\n                            seen.add(body);\r\n                            result.push(body);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Iterate over potential collision pairs, calling the callback for each.\r\n     * Each pair is visited exactly once. No Set or deduplication needed -\r\n     * the algorithm structure guarantees uniqueness.\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        for (const [key, cell] of this.cells) {\r\n            // Check within same cell - pairs (i, j) where i < j are unique\r\n            for (let i = 0; i < cell.length; i++) {\r\n                for (let j = i + 1; j < cell.length; j++) {\r\n                    callback(cell[i], cell[j]);\r\n                }\r\n            }\r\n\r\n            // Check against neighbor cells with HIGHER keys only\r\n            // This ensures each cross-cell pair is checked exactly once\r\n            const cellX = (key >> 16) & 0xFFFF;\r\n            const cellY = key & 0xFFFF;\r\n\r\n            // Only check neighbors with higher cell keys to avoid duplicates\r\n            const neighbors = [\r\n                ((cellX + 1) & 0xFFFF) << 16 | cellY,           // Right (+x)\r\n                (cellX << 16) | ((cellY + 1) & 0xFFFF),         // Below (+y)\r\n                (((cellX + 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF), // Below-right (+x,+y)\r\n            ];\r\n\r\n            for (const neighborKey of neighbors) {\r\n                // Only process if neighbor key > current key (avoids duplicates)\r\n                if (neighborKey <= key) continue;\r\n\r\n                const neighborCell = this.cells.get(neighborKey);\r\n                if (!neighborCell) continue;\r\n\r\n                for (const a of cell) {\r\n                    for (const b of neighborCell) {\r\n                        callback(a, b);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Below-left neighbor needs special handling (has lower x but higher y)\r\n            const belowLeftKey = (((cellX - 1) & 0xFFFF) << 16) | ((cellY + 1) & 0xFFFF);\r\n            const belowLeftCell = this.cells.get(belowLeftKey);\r\n            if (belowLeftCell) {\r\n                for (const a of cell) {\r\n                    for (const b of belowLeftCell) {\r\n                        callback(a, b);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Handle oversized entities - check against ALL other entities\r\n        // This is O(oversized * total) but there are typically very few oversized entities\r\n        const oversized = this.oversized;\r\n        const allRegular = this.allRegular;\r\n\r\n        // Oversized vs oversized\r\n        for (let i = 0; i < oversized.length; i++) {\r\n            for (let j = i + 1; j < oversized.length; j++) {\r\n                callback(oversized[i], oversized[j]);\r\n            }\r\n        }\r\n\r\n        // Oversized vs all regular entities\r\n        for (const big of oversized) {\r\n            for (const small of allRegular) {\r\n                callback(big, small);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get potential collision pairs as an array.\r\n     * For large body counts, prefer forEachPair() to avoid array allocation.\r\n     */\r\n    getPotentialPairs(): Array<[RigidBody2D, RigidBody2D]> {\r\n        const pairs: Array<[RigidBody2D, RigidBody2D]> = [];\r\n        this.forEachPair((a, b) => pairs.push([a, b]));\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Get statistics for debugging.\r\n     */\r\n    getStats(): { cellCount: number; maxPerCell: number; avgPerCell: number; oversizedCount: number } {\r\n        let maxPerCell = 0;\r\n        let totalBodies = 0;\r\n\r\n        for (const cell of this.cells.values()) {\r\n            maxPerCell = Math.max(maxPerCell, cell.length);\r\n            totalBodies += cell.length;\r\n        }\r\n\r\n        return {\r\n            cellCount: this.cells.size,\r\n            maxPerCell,\r\n            avgPerCell: this.cells.size > 0 ? totalBodies / this.cells.size : 0,\r\n            oversizedCount: this.oversized.length\r\n        };\r\n    }\r\n}\r\n", "/**\r\n * 2D Physics World\r\n *\r\n * Manages the 2D physics simulation including gravity, collision detection,\r\n * and integration of velocities and positions.\r\n */\r\n\r\nimport { Fixed, FP_ONE, FP_HALF, toFixed, toFloat, fpMul, fpDiv, fpAbs } from '../../math/fixed';\r\nimport { aabb2DOverlap, Shape2D, Shape2DType, CircleShape, BoxShape2D } from './shapes';\r\nimport { RigidBody2D, BodyType2D, Vec2, vec2, vec2Zero, vec2Add, vec2Scale, vec2LengthSq, createBody2D, setBody2DIdCounter, getBody2DIdCounter } from './rigid-body';\r\nimport { Contact2D, computeAABB2D, detectCollision2D, resolveCollision2D } from './collision';\r\nimport { shouldCollide, CollisionFilter, DEFAULT_FILTER } from './layers';\r\nimport { TriggerState, TriggerEvent } from './trigger';\r\nimport { SpatialHash2D } from './spatial-hash';\r\n\r\n// ============================================\r\n// Constants\r\n// ============================================\r\n\r\nconst GRAVITY_2D: Vec2 = { x: 0, y: toFixed(-30) };  // -30 units/s\u00B2 (down in Y)\r\nconst LINEAR_DAMPING = toFixed(0.1);\r\nconst ANGULAR_DAMPING = toFixed(0.1);\r\nconst SLEEP_THRESHOLD = toFixed(0.12);\r\nconst SLEEP_FRAMES_REQUIRED = 20;\r\n\r\n// Default spatial hash cell size - should be >= largest entity diameter\r\nconst DEFAULT_CELL_SIZE = 64;\r\n\r\n// ============================================\r\n// Trigger Event 2D\r\n// ============================================\r\n\r\nexport interface TriggerEvent2D {\r\n    trigger: RigidBody2D;\r\n    other: RigidBody2D;\r\n}\r\n\r\n// ============================================\r\n// Contact Listener\r\n// ============================================\r\n\r\nexport interface ContactListener2D {\r\n    onContact(bodyA: RigidBody2D, bodyB: RigidBody2D): void;\r\n}\r\n\r\n// ============================================\r\n// World Interface\r\n// ============================================\r\n\r\nexport interface World2D {\r\n    bodies: RigidBody2D[];\r\n    gravity: Vec2;\r\n    dt: Fixed;\r\n    contactListener?: ContactListener2D;\r\n    /** Reference to Physics2D system for type-based collision handling */\r\n    physics2d?: any;\r\n    /** Step the physics simulation */\r\n    step(): void;\r\n}\r\n\r\nexport function createWorld2D(dt: number = 1 / 60): World2D {\r\n    const world: World2D = {\r\n        bodies: [],\r\n        gravity: { x: GRAVITY_2D.x, y: GRAVITY_2D.y },\r\n        dt: toFixed(dt),\r\n        step() {\r\n            stepWorld2D(world);\r\n        }\r\n    };\r\n    return world;\r\n}\r\n\r\nexport function addBody2D(world: World2D, body: RigidBody2D): void {\r\n    world.bodies.push(body);\r\n}\r\n\r\nexport function removeBody2D(world: World2D, body: RigidBody2D): void {\r\n    const index = world.bodies.indexOf(body);\r\n    if (index >= 0) {\r\n        world.bodies.splice(index, 1);\r\n    }\r\n}\r\n\r\n// ============================================\r\n// World Step\r\n// ============================================\r\n\r\nexport function stepWorld2D(world: World2D): { contacts: Contact2D[]; triggers: TriggerEvent2D[] } {\r\n    const { gravity, dt } = world;\r\n    const contacts: Contact2D[] = [];\r\n    const triggerOverlaps: TriggerEvent2D[] = [];\r\n\r\n    // Collect collision pairs for deterministic callback firing AFTER detection\r\n    const collisionPairs: Array<{ entityA: any; entityB: any; labelA: string; labelB: string }> = [];\r\n\r\n    // Sort bodies by label for deterministic collision processing\r\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\r\n\r\n    // Integrate velocities (apply gravity)\r\n    for (const body of bodies) {\r\n        if (body.type !== BodyType2D.Dynamic) continue;\r\n        if (body.isSleeping) continue;\r\n\r\n        // Apply gravity\r\n        body.linearVelocity = vec2Add(body.linearVelocity, vec2Scale(gravity, dt));\r\n\r\n        // Apply damping\r\n        const linearDamp = (FP_ONE - LINEAR_DAMPING) as Fixed;\r\n        const angularDamp = (FP_ONE - ANGULAR_DAMPING) as Fixed;\r\n\r\n        body.linearVelocity = vec2Scale(body.linearVelocity, linearDamp);\r\n        body.angularVelocity = fpMul(body.angularVelocity, angularDamp);\r\n    }\r\n\r\n    // Collision detection using spatial hash for O(1) broad phase\r\n    // Cell size should be >= largest entity diameter for optimal performance\r\n    const spatialHash = new SpatialHash2D(DEFAULT_CELL_SIZE);\r\n    spatialHash.insertAll(bodies);\r\n\r\n    // Process potential collision pairs directly (no intermediate array allocation)\r\n    spatialHash.forEachPair((bodyA, bodyB) => {\r\n        // Skip static-static (no collision needed)\r\n        if (bodyA.type === BodyType2D.Static && bodyB.type === BodyType2D.Static) return;\r\n        if (!shouldCollide(bodyA.filter, bodyB.filter)) return;\r\n\r\n        // Broad phase: AABB overlap test (spatial hash gives candidates, still need precise AABB)\r\n        const aabbA = computeAABB2D(bodyA);\r\n        const aabbB = computeAABB2D(bodyB);\r\n        if (!aabb2DOverlap(aabbA, aabbB)) return;\r\n\r\n        // Narrow phase: precise collision detection\r\n        const contact = detectCollision2D(bodyA, bodyB);\r\n\r\n        if (!contact) return;\r\n\r\n        // Collect entity pairs for callback firing (all collisions including sensors)\r\n        const entityA = bodyA.userData;\r\n        const entityB = bodyB.userData;\r\n        if (entityA || entityB) {\r\n            collisionPairs.push({\r\n                entityA,\r\n                entityB,\r\n                labelA: bodyA.label,\r\n                labelB: bodyB.label\r\n            });\r\n        }\r\n\r\n        // Sensors: detect overlap but skip physics response\r\n        if (bodyA.isSensor || bodyB.isSensor) {\r\n            if (bodyA.isSensor) triggerOverlaps.push({ trigger: bodyA, other: bodyB });\r\n            if (bodyB.isSensor) triggerOverlaps.push({ trigger: bodyB, other: bodyA });\r\n            return;\r\n        }\r\n\r\n        // Store contact and fire contact listener\r\n        contacts.push(contact);\r\n        if (world.contactListener) world.contactListener.onContact(bodyA, bodyB);\r\n\r\n        // Resolve collision (position + velocity)\r\n        resolveCollision2D(contact);\r\n    });\r\n\r\n    // Fire entity collision callbacks AFTER all detection is complete\r\n    // Sort by both labels to ensure deterministic ordering across clients\r\n    collisionPairs.sort((a, b) => {\r\n        const cmp = a.labelA.localeCompare(b.labelA);\r\n        return cmp !== 0 ? cmp : a.labelB.localeCompare(b.labelB);\r\n    });\r\n\r\n    for (const pair of collisionPairs) {\r\n        // Check active status at callback time (may have changed during earlier callbacks)\r\n        if (pair.entityA?.active === false || pair.entityB?.active === false) continue;\r\n\r\n        // Try Physics2D type-based handlers first (preferred - auto-restored)\r\n        if (world.physics2d?.handleCollision?.(pair.entityA, pair.entityB)) {\r\n            continue; // Handler found and called, skip entity.onCollision\r\n        }\r\n\r\n        // Fall back to entity.onCollision (legacy - requires manual restore in onSnapshot)\r\n        if (pair.entityA?.onCollision) {\r\n            pair.entityA.onCollision(pair.entityB);\r\n        }\r\n        if (pair.entityB?.onCollision) {\r\n            pair.entityB.onCollision(pair.entityA);\r\n        }\r\n    }\r\n\r\n    // Integrate positions\r\n    for (const body of bodies) {\r\n        if (body.type === BodyType2D.Static) continue;\r\n        if (body.isSleeping) continue;\r\n\r\n        // Clamp tiny velocities\r\n        const linearClamp = toFixed(0.05);\r\n        const angularClamp = toFixed(0.01);\r\n\r\n        if (fpAbs(body.linearVelocity.x) < linearClamp) body.linearVelocity.x = 0;\r\n        if (fpAbs(body.linearVelocity.y) < linearClamp) body.linearVelocity.y = 0;\r\n        if (fpAbs(body.angularVelocity) < angularClamp) body.angularVelocity = 0;\r\n\r\n        // Update position\r\n        body.position = vec2Add(body.position, vec2Scale(body.linearVelocity, dt));\r\n\r\n        // Update angle\r\n        if (!body.lockRotation && body.angularVelocity !== 0) {\r\n            body.angle = (body.angle + fpMul(body.angularVelocity, dt)) as Fixed;\r\n        }\r\n\r\n        // Sleep detection\r\n        const speedSq = vec2LengthSq(body.linearVelocity);\r\n        const angSpeedSq = fpMul(body.angularVelocity, body.angularVelocity);\r\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\r\n\r\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\r\n            body.sleepFrames++;\r\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\r\n                body.isSleeping = true;\r\n                body.linearVelocity = vec2Zero();\r\n                body.angularVelocity = 0;\r\n            }\r\n        } else {\r\n            body.sleepFrames = 0;\r\n            body.isSleeping = false;\r\n        }\r\n    }\r\n\r\n    return { contacts, triggers: triggerOverlaps };\r\n}\r\n\r\n// ============================================\r\n// State Serialization\r\n// ============================================\r\n\r\n/**\r\n * Serialized shape data for snapshots.\r\n * Contains all information needed to recreate a shape.\r\n */\r\nexport interface ShapeState2D {\r\n    type: Shape2DType;\r\n    // Circle\r\n    radius?: Fixed;\r\n    // Box\r\n    halfWidth?: Fixed;\r\n    halfHeight?: Fixed;\r\n}\r\n\r\n/**\r\n * Complete body state for snapshots.\r\n * Contains ALL information needed to recreate a body from scratch.\r\n * This is critical for late joiners who have an empty world.\r\n */\r\nexport interface BodyState2D {\r\n    // Identity\r\n    id: number;\r\n    label: string;\r\n    bodyType: BodyType2D;\r\n\r\n    // Shape (required for body creation)\r\n    shape: ShapeState2D;\r\n\r\n    // Transform\r\n    px: Fixed;\r\n    py: Fixed;\r\n    angle: Fixed;\r\n\r\n    // Velocity\r\n    vx: Fixed;\r\n    vy: Fixed;\r\n    av: Fixed;\r\n\r\n    // Material properties\r\n    mass: Fixed;\r\n    restitution: Fixed;\r\n    friction: Fixed;\r\n\r\n    // State flags\r\n    isSleeping: boolean;\r\n    sleepFrames: number;\r\n    lockRotation: boolean;\r\n    isSensor: boolean;\r\n    isBullet: boolean;\r\n\r\n    // Collision filter\r\n    filter: CollisionFilter;\r\n\r\n    // User data (game-specific)\r\n    userData?: any;\r\n}\r\n\r\nexport interface WorldState2D {\r\n    bodies: BodyState2D[];\r\n}\r\n\r\nexport interface WorldStateWithHash2D {\r\n    state: WorldState2D;\r\n    hash: number;\r\n}\r\n\r\n/**\r\n * Serialize a shape to ShapeState2D.\r\n */\r\nfunction serializeShape(shape: Shape2D): ShapeState2D {\r\n    if (shape.type === Shape2DType.Circle) {\r\n        return {\r\n            type: Shape2DType.Circle,\r\n            radius: (shape as CircleShape).radius,\r\n        };\r\n    } else {\r\n        const box = shape as BoxShape2D;\r\n        return {\r\n            type: Shape2DType.Box,\r\n            halfWidth: box.halfWidth,\r\n            halfHeight: box.halfHeight,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Deserialize ShapeState2D back to Shape2D.\r\n */\r\nfunction deserializeShape(state: ShapeState2D): Shape2D {\r\n    if (state.type === Shape2DType.Circle) {\r\n        return {\r\n            type: Shape2DType.Circle,\r\n            radius: state.radius!,\r\n        } as CircleShape;\r\n    } else {\r\n        return {\r\n            type: Shape2DType.Box,\r\n            halfWidth: state.halfWidth!,\r\n            halfHeight: state.halfHeight!,\r\n        } as BoxShape2D;\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize a single body to BodyState2D.\r\n * Contains ALL information needed to recreate the body.\r\n */\r\nfunction serializeBody(b: RigidBody2D): BodyState2D {\r\n    return {\r\n        id: b.id,\r\n        label: b.label,\r\n        bodyType: b.type,\r\n        shape: serializeShape(b.shape),\r\n        px: b.position.x,\r\n        py: b.position.y,\r\n        angle: b.angle,\r\n        vx: b.linearVelocity.x,\r\n        vy: b.linearVelocity.y,\r\n        av: b.angularVelocity,\r\n        mass: b.mass,\r\n        restitution: b.restitution,\r\n        friction: b.friction,\r\n        isSleeping: b.isSleeping,\r\n        sleepFrames: b.sleepFrames,\r\n        lockRotation: b.lockRotation,\r\n        isSensor: b.isSensor,\r\n        isBullet: b.isBullet,\r\n        filter: { ...b.filter },\r\n        userData: b.userData,\r\n    };\r\n}\r\n\r\n/**\r\n * Save world state - use saveWorldStateWithHash2D for efficiency when you need both\r\n */\r\nexport function saveWorldState2D(world: World2D): WorldState2D {\r\n    return {\r\n        bodies: world.bodies.map(serializeBody)\r\n    };\r\n}\r\n\r\n/**\r\n * Save world state AND compute hash in a single pass.\r\n * More efficient than calling saveWorldState2D + separate hash function.\r\n */\r\nexport function saveWorldStateWithHash2D(world: World2D): WorldStateWithHash2D {\r\n    const bodies: BodyState2D[] = [];\r\n    let hash = 0;\r\n\r\n    // Single pass: serialize and hash simultaneously\r\n    for (const b of world.bodies) {\r\n        const bs = serializeBody(b);\r\n        bodies.push(bs);\r\n\r\n        // Compute hash inline - include all determinism-relevant state\r\n        hash = ((hash << 5) - hash + bs.id) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.bodyType) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.shape.type) >>> 0;\r\n        if (bs.shape.radius !== undefined) {\r\n            hash = ((hash << 5) - hash + bs.shape.radius) >>> 0;\r\n        }\r\n        if (bs.shape.halfWidth !== undefined) {\r\n            hash = ((hash << 5) - hash + bs.shape.halfWidth) >>> 0;\r\n            hash = ((hash << 5) - hash + bs.shape.halfHeight!) >>> 0;\r\n        }\r\n        hash = ((hash << 5) - hash + bs.px) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.py) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.vx) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.vy) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.angle) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.av) >>> 0;\r\n        hash = ((hash << 5) - hash + bs.mass) >>> 0;\r\n    }\r\n\r\n    return { state: { bodies }, hash };\r\n}\r\n\r\n/**\r\n * Create a body from serialized state.\r\n * This is used for late joiners who need to recreate bodies from scratch.\r\n */\r\nfunction createBodyFromState(bs: BodyState2D): RigidBody2D {\r\n    const shape = deserializeShape(bs.shape);\r\n\r\n    // We need to create the body with the correct ID\r\n    // Temporarily set the counter to ensure consistent IDs\r\n    const savedCounter = getBody2DIdCounter();\r\n\r\n    // Create body at position (0, 0) - we'll set exact position after\r\n    // Use toFloat to convert fixed-point back to float for createBody2D\r\n    const body = createBody2D(bs.bodyType, shape, 0, 0, bs.label);\r\n\r\n    // Override the auto-generated ID with the snapshot ID\r\n    body.id = bs.id;\r\n\r\n    // Restore the counter (createBody2D incremented it)\r\n    // The next new body will use the max ID from snapshot + 1\r\n    setBody2DIdCounter(savedCounter);\r\n\r\n    // Set all properties from snapshot\r\n    body.position = { x: bs.px, y: bs.py };\r\n    body.angle = bs.angle;\r\n    body.linearVelocity = { x: bs.vx, y: bs.vy };\r\n    body.angularVelocity = bs.av;\r\n\r\n    // Mass properties - need to recalculate invMass and inertia\r\n    body.mass = bs.mass;\r\n    body.invMass = bs.mass > 0 ? fpDiv(FP_ONE, bs.mass) : 0;\r\n\r\n    // Recalculate inertia based on shape and mass\r\n    if (bs.bodyType === BodyType2D.Dynamic && bs.mass > 0) {\r\n        if (shape.type === Shape2DType.Circle) {\r\n            const r = (shape as CircleShape).radius;\r\n            body.inertia = fpMul(fpMul(bs.mass, FP_HALF), fpMul(r, r));\r\n        } else {\r\n            const box = shape as BoxShape2D;\r\n            const w = (box.halfWidth << 1) as Fixed;\r\n            const h = (box.halfHeight << 1) as Fixed;\r\n            const FP_ONE_TWELFTH = 5461 as Fixed;\r\n            body.inertia = fpMul(fpMul(bs.mass, FP_ONE_TWELFTH), (fpMul(w, w) + fpMul(h, h)) as Fixed);\r\n        }\r\n        body.invInertia = body.inertia > 0 ? fpDiv(FP_ONE, body.inertia) : 0;\r\n    }\r\n\r\n    // Material\r\n    body.restitution = bs.restitution;\r\n    body.friction = bs.friction;\r\n\r\n    // State\r\n    body.isSleeping = bs.isSleeping;\r\n    body.sleepFrames = bs.sleepFrames;\r\n    body.lockRotation = bs.lockRotation;\r\n    body.isSensor = bs.isSensor;\r\n    body.isBullet = bs.isBullet ?? false;\r\n\r\n    // Collision filter\r\n    body.filter = { ...bs.filter };\r\n\r\n    // User data\r\n    body.userData = bs.userData;\r\n\r\n    return body;\r\n}\r\n\r\n/**\r\n * Load world state from snapshot.\r\n *\r\n * IMPORTANT: This function fully recreates the world from the snapshot.\r\n * It handles both:\r\n * 1. Existing worlds (rollback) - updates existing bodies, removes/adds as needed\r\n * 2. Empty worlds (late joiners) - creates all bodies from scratch\r\n *\r\n * The snapshot contains complete body information including shape data,\r\n * so bodies can be fully recreated without any prior state.\r\n */\r\nexport function loadWorldState2D(world: World2D, state: WorldState2D): void {\r\n    // Sort snapshot bodies by label for deterministic iteration\r\n    const sortedBodies = [...state.bodies].sort((a, b) => a.label.localeCompare(b.label));\r\n\r\n    // Build a set of labels in the snapshot\r\n    const snapshotLabels = new Set(sortedBodies.map(bs => bs.label));\r\n\r\n    // Remove bodies not in snapshot\r\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\r\n        if (!snapshotLabels.has(world.bodies[i].label)) {\r\n            world.bodies.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    // Build map of existing bodies\r\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\r\n\r\n    // Track the highest ID we see to update the counter\r\n    let maxId = 0;\r\n\r\n    for (const bs of sortedBodies) {\r\n        if (bs.id > maxId) maxId = bs.id;\r\n\r\n        const existingBody = bodyMap.get(bs.label);\r\n\r\n        if (existingBody) {\r\n            // Update existing body\r\n            existingBody.position = { x: bs.px, y: bs.py };\r\n            existingBody.angle = bs.angle;\r\n            existingBody.linearVelocity = { x: bs.vx, y: bs.vy };\r\n            existingBody.angularVelocity = bs.av;\r\n            existingBody.isSleeping = bs.isSleeping;\r\n            existingBody.sleepFrames = bs.sleepFrames;\r\n            existingBody.lockRotation = bs.lockRotation;\r\n            existingBody.isSensor = bs.isSensor;\r\n            existingBody.restitution = bs.restitution;\r\n            existingBody.friction = bs.friction;\r\n            existingBody.filter = { ...bs.filter };\r\n            if (bs.userData !== undefined) {\r\n                existingBody.userData = bs.userData;\r\n            }\r\n        } else {\r\n            // Create new body from snapshot - this is critical for late joiners\r\n            const newBody = createBodyFromState(bs);\r\n            world.bodies.push(newBody);\r\n        }\r\n    }\r\n\r\n    // Update the body ID counter to be higher than any ID in the snapshot\r\n    // This ensures new bodies created after loading won't have conflicting IDs\r\n    const currentCounter = getBody2DIdCounter();\r\n    if (maxId >= currentCounter) {\r\n        setBody2DIdCounter(maxId + 1);\r\n    }\r\n\r\n    // Sort world bodies by label for deterministic order\r\n    world.bodies.sort((a, b) => a.label.localeCompare(b.label));\r\n}\r\n", "/**\r\n * QuadTree for Dynamic Spatial Partitioning\r\n *\r\n * Recursively subdivides space based on entity density.\r\n * Adapts to mixed entity sizes and non-uniform distributions.\r\n * Ideal for .io games where players grow from tiny to huge.\r\n */\r\n\r\nimport { RigidBody2D } from './rigid-body';\r\nimport { computeAABB2D } from './collision';\r\nimport { toFloat } from '../../math/fixed';\r\n\r\n// ============================================\r\n// Configuration\r\n// ============================================\r\n\r\nconst DEFAULT_MAX_ENTITIES = 8;   // Max entities before subdivision\r\nconst DEFAULT_MAX_DEPTH = 8;      // Max tree depth (prevents infinite subdivision)\r\n\r\n// ============================================\r\n// AABB Helpers\r\n// ============================================\r\n\r\ninterface Bounds {\r\n    minX: number;\r\n    minY: number;\r\n    maxX: number;\r\n    maxY: number;\r\n}\r\n\r\nfunction boundsContains(bounds: Bounds, x: number, y: number): boolean {\r\n    return x >= bounds.minX && x <= bounds.maxX &&\r\n           y >= bounds.minY && y <= bounds.maxY;\r\n}\r\n\r\nfunction boundsIntersects(a: Bounds, b: Bounds): boolean {\r\n    return a.minX <= b.maxX && a.maxX >= b.minX &&\r\n           a.minY <= b.maxY && a.maxY >= b.minY;\r\n}\r\n\r\nfunction getBodyBounds(body: RigidBody2D): Bounds {\r\n    const aabb = computeAABB2D(body);\r\n    return {\r\n        minX: toFloat(aabb.minX),\r\n        minY: toFloat(aabb.minY),\r\n        maxX: toFloat(aabb.maxX),\r\n        maxY: toFloat(aabb.maxY)\r\n    };\r\n}\r\n\r\n// ============================================\r\n// QuadTree Node\r\n// ============================================\r\n\r\nclass QuadTreeNode {\r\n    bounds: Bounds;\r\n    depth: number;\r\n    maxEntities: number;\r\n    maxDepth: number;\r\n\r\n    // Entities stored in this node (entities that span multiple children stay here)\r\n    entities: RigidBody2D[] = [];\r\n\r\n    // Child quadrants: NW, NE, SW, SE (null until subdivided)\r\n    children: [QuadTreeNode, QuadTreeNode, QuadTreeNode, QuadTreeNode] | null = null;\r\n\r\n    constructor(bounds: Bounds, depth: number, maxEntities: number, maxDepth: number) {\r\n        this.bounds = bounds;\r\n        this.depth = depth;\r\n        this.maxEntities = maxEntities;\r\n        this.maxDepth = maxDepth;\r\n    }\r\n\r\n    /**\r\n     * Insert an entity into the tree.\r\n     */\r\n    insert(body: RigidBody2D, bodyBounds: Bounds): void {\r\n        // If we have children, try to insert into a child\r\n        if (this.children) {\r\n            const index = this.getChildIndex(bodyBounds);\r\n            if (index !== -1) {\r\n                this.children[index].insert(body, bodyBounds);\r\n                return;\r\n            }\r\n            // Entity spans multiple quadrants - store in this node\r\n            this.entities.push(body);\r\n            return;\r\n        }\r\n\r\n        // No children yet - store in this node\r\n        this.entities.push(body);\r\n\r\n        // Subdivide if we have too many entities and haven't reached max depth\r\n        if (this.entities.length > this.maxEntities && this.depth < this.maxDepth) {\r\n            this.subdivide();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subdivide this node into 4 children.\r\n     */\r\n    private subdivide(): void {\r\n        const { minX, minY, maxX, maxY } = this.bounds;\r\n        const midX = (minX + maxX) / 2;\r\n        const midY = (minY + maxY) / 2;\r\n\r\n        this.children = [\r\n            new QuadTreeNode({ minX, minY, maxX: midX, maxY: midY }, this.depth + 1, this.maxEntities, this.maxDepth),           // NW (top-left)\r\n            new QuadTreeNode({ minX: midX, minY, maxX, maxY: midY }, this.depth + 1, this.maxEntities, this.maxDepth),           // NE (top-right)\r\n            new QuadTreeNode({ minX, minY: midY, maxX: midX, maxY }, this.depth + 1, this.maxEntities, this.maxDepth),           // SW (bottom-left)\r\n            new QuadTreeNode({ minX: midX, minY: midY, maxX, maxY }, this.depth + 1, this.maxEntities, this.maxDepth),           // SE (bottom-right)\r\n        ];\r\n\r\n        // Re-insert entities into children\r\n        const oldEntities = this.entities;\r\n        this.entities = [];\r\n\r\n        for (const body of oldEntities) {\r\n            const bodyBounds = getBodyBounds(body);\r\n            const index = this.getChildIndex(bodyBounds);\r\n            if (index !== -1) {\r\n                this.children[index].insert(body, bodyBounds);\r\n            } else {\r\n                // Entity spans multiple quadrants - keep in this node\r\n                this.entities.push(body);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the child index for an entity, or -1 if it spans multiple children.\r\n     */\r\n    private getChildIndex(bodyBounds: Bounds): number {\r\n        const { minX, minY, maxX, maxY } = this.bounds;\r\n        const midX = (minX + maxX) / 2;\r\n        const midY = (minY + maxY) / 2;\r\n\r\n        const inTop = bodyBounds.maxY <= midY;\r\n        const inBottom = bodyBounds.minY >= midY;\r\n        const inLeft = bodyBounds.maxX <= midX;\r\n        const inRight = bodyBounds.minX >= midX;\r\n\r\n        if (inTop && inLeft) return 0;  // NW\r\n        if (inTop && inRight) return 1; // NE\r\n        if (inBottom && inLeft) return 2; // SW\r\n        if (inBottom && inRight) return 3; // SE\r\n\r\n        return -1; // Spans multiple quadrants\r\n    }\r\n\r\n    /**\r\n     * Query all entities that might collide with the given bounds.\r\n     */\r\n    query(queryBounds: Bounds, result: RigidBody2D[]): void {\r\n        // Check entities in this node\r\n        for (const body of this.entities) {\r\n            result.push(body);\r\n        }\r\n\r\n        // Check children\r\n        if (this.children) {\r\n            for (const child of this.children) {\r\n                if (boundsIntersects(child.bounds, queryBounds)) {\r\n                    child.query(queryBounds, result);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate all potential collision pairs (iterative version).\r\n     * Uses stack-based traversal to avoid recursive overhead.\r\n     */\r\n    forEachPairIterative(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        // Stack entries: [node, ancestorStartIndex]\r\n        const stack: Array<{ node: QuadTreeNode; ancestorStart: number }> = [];\r\n        const ancestors: RigidBody2D[] = [];\r\n\r\n        stack.push({ node: this, ancestorStart: 0 });\r\n\r\n        while (stack.length > 0) {\r\n            const { node, ancestorStart } = stack.pop()!;\r\n\r\n            // Trim ancestors to correct level\r\n            ancestors.length = ancestorStart;\r\n\r\n            // Check pairs within this node's entities\r\n            const entities = node.entities;\r\n            for (let i = 0; i < entities.length; i++) {\r\n                for (let j = i + 1; j < entities.length; j++) {\r\n                    callback(entities[i], entities[j]);\r\n                }\r\n            }\r\n\r\n            // Check this node's entities against ancestors\r\n            for (let i = 0; i < ancestorStart; i++) {\r\n                for (const entity of entities) {\r\n                    callback(ancestors[i], entity);\r\n                }\r\n            }\r\n\r\n            // Add this node's entities to ancestors for children\r\n            const newAncestorStart = ancestors.length;\r\n            for (const entity of entities) {\r\n                ancestors.push(entity);\r\n            }\r\n\r\n            // Push children in reverse order (so NW is processed first)\r\n            if (node.children) {\r\n                for (let i = 3; i >= 0; i--) {\r\n                    stack.push({ node: node.children[i], ancestorStart: ancestors.length });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate all potential collision pairs.\r\n     * Callback receives each unique pair exactly once.\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void, ancestors: RigidBody2D[] = []): void {\r\n        this.forEachPairIterative(callback);\r\n    }\r\n\r\n    /**\r\n     * Get statistics about this subtree.\r\n     */\r\n    getStats(): { nodeCount: number; maxDepth: number; entityCount: number } {\r\n        let nodeCount = 1;\r\n        let maxDepth = this.depth;\r\n        let entityCount = this.entities.length;\r\n\r\n        if (this.children) {\r\n            for (const child of this.children) {\r\n                const childStats = child.getStats();\r\n                nodeCount += childStats.nodeCount;\r\n                maxDepth = Math.max(maxDepth, childStats.maxDepth);\r\n                entityCount += childStats.entityCount;\r\n            }\r\n        }\r\n\r\n        return { nodeCount, maxDepth, entityCount };\r\n    }\r\n}\r\n\r\n// ============================================\r\n// QuadTree2D Public API\r\n// ============================================\r\n\r\nexport class QuadTree2D {\r\n    private root: QuadTreeNode | null = null;\r\n    private maxEntities: number;\r\n    private maxDepth: number;\r\n\r\n    constructor(maxEntities: number = DEFAULT_MAX_ENTITIES, maxDepth: number = DEFAULT_MAX_DEPTH) {\r\n        this.maxEntities = maxEntities;\r\n        this.maxDepth = maxDepth;\r\n    }\r\n\r\n    /**\r\n     * Clear the tree.\r\n     */\r\n    clear(): void {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Insert all bodies into the tree.\r\n     * Automatically computes world bounds from entities.\r\n     */\r\n    insertAll(bodies: RigidBody2D[]): void {\r\n        if (bodies.length === 0) return;\r\n\r\n        // Compute world bounds from all entities (with padding)\r\n        let minX = Infinity, minY = Infinity;\r\n        let maxX = -Infinity, maxY = -Infinity;\r\n\r\n        for (const body of bodies) {\r\n            const bounds = getBodyBounds(body);\r\n            minX = Math.min(minX, bounds.minX);\r\n            minY = Math.min(minY, bounds.minY);\r\n            maxX = Math.max(maxX, bounds.maxX);\r\n            maxY = Math.max(maxY, bounds.maxY);\r\n        }\r\n\r\n        // Add small padding to avoid edge cases\r\n        const padding = 1;\r\n        this.root = new QuadTreeNode(\r\n            { minX: minX - padding, minY: minY - padding, maxX: maxX + padding, maxY: maxY + padding },\r\n            0,\r\n            this.maxEntities,\r\n            this.maxDepth\r\n        );\r\n\r\n        // Insert all bodies\r\n        for (const body of bodies) {\r\n            const bounds = getBodyBounds(body);\r\n            this.root.insert(body, bounds);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Query entities that might collide with the given body.\r\n     */\r\n    queryNearby(body: RigidBody2D): RigidBody2D[] {\r\n        if (!this.root) return [];\r\n        const result: RigidBody2D[] = [];\r\n        const bounds = getBodyBounds(body);\r\n        this.root.query(bounds, result);\r\n        return result.filter(b => b !== body);\r\n    }\r\n\r\n    /**\r\n     * Iterate all potential collision pairs.\r\n     * Each pair is visited exactly once.\r\n     * Order is deterministic (depth-first, NW\u2192NE\u2192SW\u2192SE).\r\n     */\r\n    forEachPair(callback: (a: RigidBody2D, b: RigidBody2D) => void): void {\r\n        if (!this.root) return;\r\n        this.root.forEachPair(callback);\r\n    }\r\n\r\n    /**\r\n     * Get tree statistics for debugging.\r\n     */\r\n    getStats(): { nodeCount: number; maxDepth: number; entityCount: number } {\r\n        if (!this.root) return { nodeCount: 0, maxDepth: 0, entityCount: 0 };\r\n        return this.root.getStats();\r\n    }\r\n}\r\n", "/**\n * Trigger System\n *\n * Handles trigger (sensor) bodies that detect overlap without physics response.\n * Generic implementation shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Body Interface (minimal contract)\n// ============================================\n\n/**\n * Minimal interface for a physics body used by triggers.\n * Both RigidBody (3D) and RigidBody2D implement this.\n */\nexport interface TriggerBody {\n    label: string;\n    isSensor: boolean;\n}\n\n// ============================================\n// Trigger Event\n// ============================================\n\nexport interface TriggerEvent<T extends TriggerBody = TriggerBody> {\n    trigger: T;\n    other: T;\n}\n\ntype TriggerCallback<T extends TriggerBody> = (event: TriggerEvent<T>) => void;\n\n// ============================================\n// Trigger State\n// ============================================\n\nexport class TriggerState<T extends TriggerBody = TriggerBody> {\n    private overlaps = new Map<string, { trigger: T; other: T }>();\n    private enterCallbacks: TriggerCallback<T>[] = [];\n    private stayCallbacks: TriggerCallback<T>[] = [];\n    private exitCallbacks: TriggerCallback<T>[] = [];\n\n    onEnter(cb: TriggerCallback<T>): void { this.enterCallbacks.push(cb); }\n    onStay(cb: TriggerCallback<T>): void { this.stayCallbacks.push(cb); }\n    onExit(cb: TriggerCallback<T>): void { this.exitCallbacks.push(cb); }\n\n    processOverlaps(currentOverlaps: TriggerEvent<T>[]): void {\n        const currentKeys = new Set<string>();\n        const sortedOverlaps = [...currentOverlaps].sort((a, b) => {\n            return this.makeKey(a.trigger, a.other).localeCompare(this.makeKey(b.trigger, b.other));\n        });\n\n        for (const overlap of sortedOverlaps) {\n            const key = this.makeKey(overlap.trigger, overlap.other);\n            currentKeys.add(key);\n\n            if (this.overlaps.has(key)) {\n                for (const cb of this.stayCallbacks) cb(overlap);\n            } else {\n                this.overlaps.set(key, overlap);\n                for (const cb of this.enterCallbacks) cb(overlap);\n            }\n        }\n\n        const sortedExistingKeys = [...this.overlaps.keys()].sort();\n        for (const key of sortedExistingKeys) {\n            if (!currentKeys.has(key)) {\n                const overlap = this.overlaps.get(key)!;\n                this.overlaps.delete(key);\n                for (const cb of this.exitCallbacks) cb(overlap);\n            }\n        }\n    }\n\n    clear(): void {\n        this.overlaps.clear();\n    }\n\n    removeBody(body: T): void {\n        const keysToRemove: string[] = [];\n        for (const [key, overlap] of this.overlaps) {\n            if (overlap.trigger === body || overlap.other === body) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.sort();\n        for (const key of keysToRemove) {\n            const overlap = this.overlaps.get(key)!;\n            this.overlaps.delete(key);\n            for (const cb of this.exitCallbacks) cb(overlap);\n        }\n    }\n\n    getOverlappingBodies(trigger: T): T[] {\n        const bodies: T[] = [];\n        for (const overlap of this.overlaps.values()) {\n            if (overlap.trigger === trigger) {\n                bodies.push(overlap.other);\n            }\n        }\n        return bodies.sort((a, b) => a.label.localeCompare(b.label));\n    }\n\n    isBodyInTrigger(trigger: T, body: T): boolean {\n        return this.overlaps.has(this.makeKey(trigger, body));\n    }\n\n    overlapCount(): number {\n        return this.overlaps.size;\n    }\n\n    saveState(): [string, string][] {\n        const pairs: [string, string][] = [];\n        for (const overlap of this.overlaps.values()) {\n            pairs.push([overlap.trigger.label, overlap.other.label]);\n        }\n        return pairs.sort((a, b) => a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]));\n    }\n\n    private pendingPairs: [string, string][] = [];\n\n    loadState(pairs: [string, string][]): void {\n        this.overlaps.clear();\n        this.pendingPairs = pairs;\n    }\n\n    syncWithWorld(bodies: T[]): void {\n        const bodyByLabel = new Map<string, T>();\n        for (const body of bodies) bodyByLabel.set(body.label, body);\n\n        for (const [triggerLabel, otherLabel] of this.pendingPairs) {\n            const trigger = bodyByLabel.get(triggerLabel);\n            const other = bodyByLabel.get(otherLabel);\n            if (trigger && other) {\n                this.overlaps.set(this.makeKey(trigger, other), { trigger, other });\n            }\n        }\n        this.pendingPairs = [];\n    }\n\n    private makeKey(trigger: T, other: T): string {\n        return `${trigger.label}:${other.label}`;\n    }\n}\n\n// ============================================\n// Helper Function\n// ============================================\n\n/**\n * Mark a body as a trigger (sensor).\n * Works with any body type that has an isSensor property.\n */\nexport function makeTrigger<T extends TriggerBody>(body: T): T {\n    body.isSensor = true;\n    return body;\n}\n", "/**\n * Physics2D System for ECS\n *\n * Integrates the deterministic 2D physics engine with the ECS.\n * This system:\n * - Reads Transform2D + Body2D components\n * - Creates/manages physics bodies internally\n * - Steps the physics simulation\n * - Writes results back to Transform2D component\n * - Handles collision callbacks\n */\n\nimport { World } from '../../core/world';\nimport { Entity } from '../../core/entity';\nimport { ComponentType, hasComponent } from '../../core/component';\nimport { Transform2D, Body2D, BODY_DYNAMIC, BODY_STATIC, BODY_KINEMATIC, SHAPE_CIRCLE, SHAPE_RECT } from '../../components';\nimport { INDEX_MASK } from '../../core/constants';\nimport { toFixed, toFloat } from '../../math';\n\n// Forward declaration for Game to avoid circular import\ninterface GameLike {\n    world: World;\n    physics: Physics2DSystem | null;\n}\n\n// Import physics engine primitives (same folder now)\nimport {\n    World2D,\n    createWorld2D,\n    stepWorld2D,\n    addBody2D,\n    removeBody2D,\n    RigidBody2D,\n    BodyType2D,\n    createBody2D,\n    createCircle,\n    createBox2DFromSize,\n    resetBody2DIdCounter\n} from '.';\n\n/**\n * Collision handler type.\n */\nexport type CollisionHandler = (entityA: Entity, entityB: Entity) => void;\n\n/**\n * Physics2D System configuration.\n */\nexport interface Physics2DSystemConfig {\n    gravity?: { x: number; y: number };\n    dt?: number;  // Timestep (default: 1/60)\n}\n\n/**\n * Physics2D System - manages physics simulation for ECS entities.\n *\n * Can be used as a plugin via game.addPlugin() or standalone via attach().\n *\n * @example\n * // Plugin pattern (recommended)\n * const physics = game.addPlugin(Physics2DSystem, { gravity: { x: 0, y: 0 } });\n *\n * // Standalone pattern (legacy)\n * const physics = createPhysics2DSystem({ gravity: { x: 0, y: 0 } });\n * physics.attach(game.world);\n * game.physics = physics;\n */\nexport class Physics2DSystem {\n    /** Physics world */\n    readonly physicsWorld: World2D;\n\n    /** ECS World reference */\n    private world: World | null = null;\n\n    /** Map entity ID to physics body */\n    private entityToBody: Map<number, RigidBody2D> = new Map();\n\n    /** Map body ID to entity ID */\n    private bodyToEntity: Map<number, number> = new Map();\n\n    /** Collision handlers by type pair */\n    private collisionHandlers: Map<string, CollisionHandler> = new Map();\n\n    /** Entities pending body creation */\n    private pendingEntities: Set<number> = new Set();\n\n    /**\n     * Create a Physics2D system.\n     *\n     * @param gameOrConfig - Game instance (plugin mode) or config (standalone mode)\n     * @param config - Config when using plugin mode\n     */\n    constructor(gameOrConfig?: GameLike | Physics2DSystemConfig, config?: Physics2DSystemConfig) {\n        // Determine if first arg is a Game or config\n        let actualConfig: Physics2DSystemConfig;\n        let game: GameLike | null = null;\n\n        if (gameOrConfig && 'world' in gameOrConfig) {\n            // Plugin mode: first arg is Game\n            game = gameOrConfig;\n            actualConfig = config ?? {};\n        } else {\n            // Standalone mode: first arg is config\n            actualConfig = (gameOrConfig as Physics2DSystemConfig) ?? {};\n        }\n\n        this.physicsWorld = createWorld2D(actualConfig.dt ?? 1 / 60);\n\n        if (actualConfig.gravity) {\n            this.physicsWorld.gravity = {\n                x: toFixed(actualConfig.gravity.x),\n                y: toFixed(actualConfig.gravity.y)\n            };\n        }\n\n        // Set up collision callback via contactListener (for non-sensor collisions)\n        const system = this;\n        this.physicsWorld.contactListener = {\n            onContact(bodyA: RigidBody2D, bodyB: RigidBody2D) {\n                system.handleCollision(bodyA, bodyB);\n            }\n        };\n\n        // Set up physics2d reference for sensor collisions\n        // The physics world uses this for type-based collision handling\n        (this.physicsWorld as any).physics2d = {\n            handleCollision: (entityA: Entity, entityB: Entity) => {\n                return this.handleCollisionByType(entityA, entityB);\n            }\n        };\n\n        // Auto-attach if game was provided\n        if (game) {\n            this.attach(game.world);\n            game.physics = this;\n        }\n    }\n\n    /**\n     * Attach to an ECS World.\n     * Registers prePhysics and physics systems.\n     */\n    attach(world: World): this {\n        this.world = world;\n\n        // Register prePhysics system - sync component data to bodies\n        world.addSystem(() => this.syncBodiesToPhysics(), { phase: 'prePhysics', order: 0 });\n\n        // Register physics system - step simulation\n        world.addSystem(() => this.step(), { phase: 'physics', order: 0 });\n\n        // Register postPhysics system - sync results back to components\n        world.addSystem(() => this.syncPhysicsToComponents(), { phase: 'postPhysics', order: 0 });\n\n        return this;\n    }\n\n    /**\n     * Register collision handler for two entity types.\n     *\n     * For different types (e.g., 'cell', 'food'), the handler is called once\n     * with arguments in the registered order.\n     *\n     * For same types (e.g., 'cell', 'cell'), the handler is called twice -\n     * once as (A, B) and once as (B, A). This lets you write \"first acts on second\"\n     * logic without manually checking both directions.\n     *\n     * @example\n     * // Cell eats food - called once per collision\n     * physics.onCollision('cell', 'food', (cell, food) => {\n     *     food.destroy();\n     * });\n     *\n     * // Cell eats smaller cell - called twice, just check if first > second\n     * physics.onCollision('cell', 'cell', (eater, prey) => {\n     *     if (eater.get(Sprite).radius > prey.get(Sprite).radius * 1.2) {\n     *         prey.destroy();\n     *     }\n     * });\n     */\n    onCollision(typeA: string, typeB: string, handler: CollisionHandler): this {\n        const key1 = `${typeA}:${typeB}`;\n        const key2 = `${typeB}:${typeA}`;\n\n        this.collisionHandlers.set(key1, handler);\n\n        // For different types, register reverse lookup that swaps arguments\n        if (typeA !== typeB) {\n            this.collisionHandlers.set(key2, (a, b) => handler(b, a));\n        }\n\n        return this;\n    }\n\n    /**\n     * Set gravity.\n     */\n    setGravity(x: number, y: number): this {\n        this.physicsWorld.gravity = { x: toFixed(x), y: toFixed(y) };\n        return this;\n    }\n\n    /**\n     * Create or get physics body for entity.\n     */\n    private ensureBody(entity: Entity): RigidBody2D | null {\n        const eid = entity.eid;\n\n        // Check if body already exists\n        let body = this.entityToBody.get(eid);\n        if (body) return body;\n\n        // Check if entity has required components\n        if (!entity.has(Transform2D) || !entity.has(Body2D)) {\n            return null;\n        }\n\n        // Get component data\n        const transform = entity.get(Transform2D);\n        const bodyData = entity.get(Body2D);\n\n        // Determine body type\n        let bodyType: BodyType2D;\n        switch (bodyData.bodyType) {\n            case BODY_STATIC:\n                bodyType = BodyType2D.Static;\n                break;\n            case BODY_KINEMATIC:\n                bodyType = BodyType2D.Kinematic;\n                break;\n            default:\n                bodyType = BodyType2D.Dynamic;\n        }\n\n        // Determine shape\n        let shape;\n        if (bodyData.shapeType === SHAPE_CIRCLE || bodyData.radius > 0) {\n            shape = createCircle(bodyData.radius || 10);\n        } else {\n            shape = createBox2DFromSize(bodyData.width || 10, bodyData.height || 10);\n        }\n\n        // Create body\n        body = createBody2D(bodyType, shape, transform.x, transform.y);\n        body.angle = toFixed(transform.angle);\n        body.linearVelocity = { x: toFixed(bodyData.vx), y: toFixed(bodyData.vy) };\n        body.isSensor = bodyData.isSensor;\n\n        // CRITICAL: All new bodies start awake for determinism\n        // Without this, late joiners would have awake bodies while existing clients\n        // have sleeping bodies, causing physics simulation divergence\n        body.isSleeping = false;\n        body.sleepFrames = 0;\n\n        // Store entity reference in body's userData\n        body.userData = entity;\n        body.label = eid.toString();\n\n        // Add to physics world\n        addBody2D(this.physicsWorld, body);\n\n        // Track mapping\n        this.entityToBody.set(eid, body);\n        this.bodyToEntity.set(body.id, eid);\n\n        return body;\n    }\n\n    /**\n     * Remove physics body for entity.\n     */\n    removeBody(entity: Entity): void {\n        const eid = entity.eid;\n        const body = this.entityToBody.get(eid);\n\n        if (body) {\n            removeBody2D(this.physicsWorld, body);\n            this.entityToBody.delete(eid);\n            this.bodyToEntity.delete(body.id);\n        }\n    }\n\n    /**\n     * Sync component data to physics bodies (prePhysics).\n     */\n    private syncBodiesToPhysics(): void {\n        if (!this.world) return;\n\n        // Iterate all entities with Body2D\n        for (const entity of this.world.query(Body2D)) {\n            // Ensure body exists\n            const body = this.ensureBody(entity);\n            if (!body) continue;\n\n            // Sync position from component for kinematic and static bodies\n            // (both can be moved by game code, only dynamic bodies are physics-driven)\n            const bodyData = entity.get(Body2D);\n            if (bodyData.bodyType === BODY_KINEMATIC || bodyData.bodyType === BODY_STATIC) {\n                const transform = entity.get(Transform2D);\n                body.position.x = toFixed(transform.x);\n                body.position.y = toFixed(transform.y);\n                body.angle = toFixed(transform.angle);\n            }\n\n            // Apply impulses (instant velocity change)\n            if (bodyData.impulseX !== 0 || bodyData.impulseY !== 0) {\n                bodyData.vx += bodyData.impulseX;\n                bodyData.vy += bodyData.impulseY;\n                bodyData.impulseX = 0;\n                bodyData.impulseY = 0;\n            }\n\n            // Apply forces (add to velocity)\n            if (bodyData.forceX !== 0 || bodyData.forceY !== 0) {\n                bodyData.vx += bodyData.forceX;\n                bodyData.vy += bodyData.forceY;\n                bodyData.forceX = 0;\n                bodyData.forceY = 0;\n            }\n\n            // Apply damping\n            if (bodyData.damping > 0) {\n                const damp = 1 - bodyData.damping;\n                bodyData.vx *= damp;\n                bodyData.vy *= damp;\n            }\n\n            // Sync velocity for all body types\n            const newVelX = toFixed(bodyData.vx);\n            const newVelY = toFixed(bodyData.vy);\n            body.linearVelocity.x = newVelX;\n            body.linearVelocity.y = newVelY;\n\n            // Wake up body if velocity is non-zero (prevents sleeping bodies from ignoring velocity)\n            if (newVelX !== 0 || newVelY !== 0) {\n                body.isSleeping = false;\n                body.sleepFrames = 0;\n            }\n\n            // Update shape radius if changed\n            if (body.shape.type === 0) { // Circle\n                const currentRadius = (body.shape as any).radius;\n                const newRadius = toFixed(bodyData.radius);\n                if (currentRadius !== newRadius) {\n                    (body.shape as any).radius = newRadius;\n                }\n            }\n        }\n\n        // Clean up bodies for destroyed entities\n        for (const [eid, body] of this.entityToBody) {\n            if (this.world.isDestroyed(eid)) {\n                removeBody2D(this.physicsWorld, body);\n                this.entityToBody.delete(eid);\n                this.bodyToEntity.delete(body.id);\n            }\n        }\n    }\n\n    /**\n     * Step physics simulation.\n     */\n    private step(): void {\n        stepWorld2D(this.physicsWorld);\n    }\n\n    /**\n     * Sync physics results back to components (postPhysics).\n     */\n    private syncPhysicsToComponents(): void {\n        for (const [eid, body] of this.entityToBody) {\n            const entity = this.world?.getEntity(eid);\n            if (!entity || entity.destroyed) continue;\n\n            const transform = entity.get(Transform2D);\n            const bodyData = entity.get(Body2D);\n\n            // Sync position and angle from physics\n            transform.x = toFloat(body.position.x);\n            transform.y = toFloat(body.position.y);\n            transform.angle = toFloat(body.angle);\n\n            // Sync velocity\n            bodyData.vx = toFloat(body.linearVelocity.x);\n            bodyData.vy = toFloat(body.linearVelocity.y);\n        }\n    }\n\n    /**\n     * Handle collision between two bodies.\n     */\n    private handleCollision(bodyA: RigidBody2D, bodyB: RigidBody2D): void {\n        const entityA = bodyA.userData as Entity;\n        const entityB = bodyB.userData as Entity;\n\n        if (!entityA || !entityB) return;\n        if (entityA.destroyed || entityB.destroyed) return;\n\n        this.handleCollisionByType(entityA, entityB);\n    }\n\n    /**\n     * Handle collision by entity types. Returns true if a handler was found.\n     * Used by physics world for both regular and sensor collisions.\n     */\n    private handleCollisionByType(entityA: Entity, entityB: Entity): boolean {\n        if (!entityA || !entityB) return false;\n        if (entityA.destroyed || entityB.destroyed) return false;\n\n        // Look up handler by type pair\n        const key = `${entityA.type}:${entityB.type}`;\n        const handler = this.collisionHandlers.get(key);\n\n        if (handler) {\n            handler(entityA, entityB);\n\n            // For same-type collisions, call handler in reverse direction too\n            // This lets handlers assume \"first arg acts on second\" without manual checks\n            if (entityA.type === entityB.type && !entityA.destroyed && !entityB.destroyed) {\n                handler(entityB, entityA);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Get body for entity (for advanced use).\n     */\n    getBody(entity: Entity): RigidBody2D | undefined {\n        return this.entityToBody.get(entity.eid);\n    }\n\n    /**\n     * Get entity for body (for advanced use).\n     */\n    getEntityForBody(body: RigidBody2D): Entity | null {\n        const eid = this.bodyToEntity.get(body.id);\n        if (eid === undefined) return null;\n        return this.world?.getEntity(eid) ?? null;\n    }\n\n    /**\n     * Clear all physics state.\n     * Used during snapshot restoration to ensure fresh physics state.\n     */\n    clear(): void {\n        for (const body of this.entityToBody.values()) {\n            removeBody2D(this.physicsWorld, body);\n        }\n        this.entityToBody.clear();\n        this.bodyToEntity.clear();\n\n        // CRITICAL: Reset body ID counter to ensure deterministic body IDs\n        // Without this, recreated bodies would have different IDs than the original,\n        // potentially causing collision order differences and simulation divergence\n        resetBody2DIdCounter();\n    }\n\n    /**\n     * Wake all physics bodies.\n     * Used after snapshot load/send to ensure deterministic state.\n     * Without this, existing clients have sleeping bodies while late joiners\n     * have awake bodies, causing physics divergence.\n     */\n    wakeAllBodies(): void {\n        for (const body of this.physicsWorld.bodies) {\n            body.isSleeping = false;\n            body.sleepFrames = 0;\n        }\n    }\n}\n\n/**\n * Create a Physics2D system.\n */\nexport function createPhysics2DSystem(config: Physics2DSystemConfig = {}): Physics2DSystem {\n    return new Physics2DSystem(config);\n}\n", "/**\n * Physics Module\n *\n * Deterministic 3D physics engine with fixed-point math.\n * All components use 16.16 fixed-point integers for 100% determinism.\n */\n\n// Shapes and AABB\nexport { ShapeType, BoxShape, SphereShape, Shape, createBox, createSphere, AABB, aabbOverlap } from './shapes';\n\n// Collision Layers\nexport { CollisionFilter, Layers, DEFAULT_FILTER, createFilter, shouldCollide, filterCollidingWith, filterExcluding } from './layers';\n\n// Rigid Body\nexport { BodyType, RigidBody, resetBodyIdCounter, getBodyIdCounter, setBodyIdCounter, createBody, setBodyMass, setBodyVelocity, applyImpulse, applyForce } from './rigid-body';\n\n// Collision Detection and Response\nexport { ContactPoint, Contact, computeAABB, detectCollision, resolveCollision } from './collision';\n\n// Physics World\nexport { World, createWorld, addBody, removeBody, isGrounded, stepWorld } from './world';\n\n// Raycasting\nexport { RayHit, raycast } from './raycast';\n\n// State Serialization\nexport { BodyState, WorldState, saveWorldState, loadWorldState } from './state';\n\n// Triggers/Sensors\nexport { TriggerEvent, TriggerState, makeTrigger } from './trigger';\n", "/**\n * Collision Shapes\n *\n * Defines shape types for rigid body collision detection.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, toFixed } from '../../math/fixed';\nimport { Vec3, vec3FromFloats } from '../../math/vec';\n\n// ============================================\n// Shape Types\n// ============================================\n\nexport enum ShapeType {\n    Box = 0,\n    Sphere = 1,\n}\n\nexport interface BoxShape {\n    type: ShapeType.Box;\n    halfExtents: Vec3;  // Half-size in each dimension\n}\n\nexport interface SphereShape {\n    type: ShapeType.Sphere;\n    radius: Fixed;\n}\n\nexport type Shape = BoxShape | SphereShape;\n\nexport function createBox(hx: number, hy: number, hz: number): BoxShape {\n    return { type: ShapeType.Box, halfExtents: vec3FromFloats(hx, hy, hz) };\n}\n\nexport function createSphere(radius: number): SphereShape {\n    return { type: ShapeType.Sphere, radius: toFixed(radius) };\n}\n\n// ============================================\n// AABB (Axis-Aligned Bounding Box)\n// ============================================\n\nexport interface AABB {\n    min: Vec3;\n    max: Vec3;\n}\n\nexport function aabbOverlap(a: AABB, b: AABB): boolean {\n    return a.max.x >= b.min.x && a.min.x <= b.max.x &&\n        a.max.y >= b.min.y && a.min.y <= b.max.y &&\n        a.max.z >= b.min.z && a.min.z <= b.max.z;\n}\n", "/**\n * Collision Layers\n *\n * Controls which bodies can collide with each other using bitmasks.\n * Layer = \"what am I\", Mask = \"what do I collide with\"\n *\n * Shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Collision Filter\n// ============================================\n\nexport interface CollisionFilter {\n    /** Which layer this body belongs to (single bit) */\n    layer: number;\n    /** Which layers this body collides with (bitmask) */\n    mask: number;\n}\n\n// ============================================\n// Default Layers\n// ============================================\n\nexport const Layers = {\n    NONE: 0,\n    DEFAULT: 1 << 0,      // 1\n    PLAYER: 1 << 1,       // 2\n    ENEMY: 1 << 2,        // 4\n    PROJECTILE: 1 << 3,   // 8\n    ITEM: 1 << 4,         // 16\n    TRIGGER: 1 << 5,      // 32\n    WORLD: 1 << 6,        // 64\n    PROP: 1 << 7,         // 128\n    // Layers 8-15 reserved for game-specific use\n    CUSTOM_1: 1 << 8,\n    CUSTOM_2: 1 << 9,\n    CUSTOM_3: 1 << 10,\n    CUSTOM_4: 1 << 11,\n    CUSTOM_5: 1 << 12,\n    CUSTOM_6: 1 << 13,\n    CUSTOM_7: 1 << 14,\n    CUSTOM_8: 1 << 15,\n    ALL: 0xFFFF           // All layers\n} as const;\n\n// ============================================\n// Default Filter\n// ============================================\n\n/**\n * Default collision filter - collides with everything\n */\nexport const DEFAULT_FILTER: CollisionFilter = {\n    layer: Layers.DEFAULT,\n    mask: Layers.ALL\n};\n\n// ============================================\n// Filter Helpers\n// ============================================\n\n/**\n * Create a collision filter\n */\nexport function createFilter(layer: number, mask: number = Layers.ALL): CollisionFilter {\n    return { layer, mask };\n}\n\n/**\n * Check if two filters allow collision\n * Both must have the other in their mask\n */\nexport function shouldCollide(a: CollisionFilter, b: CollisionFilter): boolean {\n    return (a.mask & b.layer) !== 0 && (b.mask & a.layer) !== 0;\n}\n\n/**\n * Create a filter that collides with specific layers\n */\nexport function filterCollidingWith(layer: number, ...collidesWithLayers: number[]): CollisionFilter {\n    let mask = 0;\n    for (const l of collidesWithLayers) {\n        mask |= l;\n    }\n    return { layer, mask };\n}\n\n/**\n * Create a filter that collides with everything except specific layers\n */\nexport function filterExcluding(layer: number, ...excludeLayers: number[]): CollisionFilter {\n    let mask = Layers.ALL;\n    for (const l of excludeLayers) {\n        mask &= ~l;\n    }\n    return { layer, mask };\n}\n", "/**\n * Rigid Body\n *\n * Defines rigid body types and operations for physics simulation.\n * All values use fixed-point math for determinism.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv } from '../../math/fixed';\nimport { Vec3, vec3Zero, vec3FromFloats, vec3Add, vec3Scale, vec3Sub, vec3Cross } from '../../math/vec';\nimport { Quat, quatIdentity } from '../../math/quat';\nimport { Shape, ShapeType, SphereShape } from './shapes';\nimport { CollisionFilter, DEFAULT_FILTER } from './layers';\n\n// ============================================\n// Constants\n// ============================================\n\nconst RESTITUTION_DEFAULT = toFixed(0.0);  // No bounce for stable resting\nconst FRICTION_DEFAULT = toFixed(0.5);      // Moderate friction\n\n// ============================================\n// Body Types\n// ============================================\n\nexport enum BodyType {\n    Static = 0,     // Never moves\n    Kinematic = 1,  // Moved by user, no physics response\n    Dynamic = 2,    // Full physics simulation\n}\n\n// ============================================\n// Rigid Body Interface\n// ============================================\n\nexport interface RigidBody {\n    id: number;\n    type: BodyType;\n    shape: Shape;\n\n    // Label for deterministic ordering - MUST be unique and consistent across all clients\n    // Examples: \"ground\", \"box_0\", \"box_1\", \"player_abc123\"\n    label: string;\n\n    // Transform\n    position: Vec3;\n    rotation: Quat;\n\n    // Velocity\n    linearVelocity: Vec3;\n    angularVelocity: Vec3;\n\n    // Mass properties\n    mass: Fixed;           // 0 for static/kinematic\n    invMass: Fixed;        // 1/mass, 0 for static/kinematic\n    inertia: Fixed;        // Moment of inertia (simplified scalar)\n    invInertia: Fixed;     // 1/inertia\n\n    // Material\n    restitution: Fixed;\n    friction: Fixed;\n\n    // State\n    isSleeping: boolean;\n    sleepFrames: number;\n\n    // Flags\n    lockRotationX: boolean;\n    lockRotationY: boolean;\n    lockRotationZ: boolean;\n    isTrigger: boolean;  // If true, detects overlap but doesn't apply physics response\n\n    // Collision filtering\n    filter: CollisionFilter;\n\n    // User data\n    userData: any;\n}\n\n// ============================================\n// Body ID Management\n// ============================================\n\nlet nextBodyId = 1;\n\nexport function resetBodyIdCounter(): void {\n    nextBodyId = 1;\n}\n\nexport function getBodyIdCounter(): number {\n    return nextBodyId;\n}\n\nexport function setBodyIdCounter(value: number): void {\n    nextBodyId = value;\n}\n\n// ============================================\n// Body Creation\n// ============================================\n\nexport function createBody(type: BodyType, shape: Shape, x: number, y: number, z: number, label?: string): RigidBody {\n    const mass = type === BodyType.Dynamic ? toFixed(1) : 0;\n    const invMass = type === BodyType.Dynamic ? FP_ONE : 0;\n\n    // Simplified inertia calculation\n    let inertia = 0;\n    if (type === BodyType.Dynamic) {\n        if (shape.type === ShapeType.Box) {\n            // I = (1/12) * m * (h\u00B2 + d\u00B2) for each axis - use average\n            const h = shape.halfExtents;\n            inertia = fpMul(mass, fpMul(toFixed(1 / 6),\n                fpMul(h.x, h.x) + fpMul(h.y, h.y) + fpMul(h.z, h.z)));\n        } else {\n            // I = (2/5) * m * r\u00B2 for solid sphere\n            const r = (shape as SphereShape).radius;\n            inertia = fpMul(mass, fpMul(toFixed(0.4), fpMul(r, r)));\n        }\n    }\n\n    const bodyLabel = label || 'body_' + nextBodyId;\n    const bodyId = nextBodyId++;\n\n    return {\n        id: bodyId,\n        label: bodyLabel,\n        type,\n        shape,\n        position: vec3FromFloats(x, y, z),\n        rotation: quatIdentity(),\n        linearVelocity: vec3Zero(),\n        angularVelocity: vec3Zero(),\n        mass,\n        invMass,\n        inertia: inertia || FP_ONE,\n        invInertia: inertia ? fpDiv(FP_ONE, inertia) : 0,\n        restitution: RESTITUTION_DEFAULT,\n        friction: FRICTION_DEFAULT,\n        isSleeping: false,\n        sleepFrames: 0,\n        lockRotationX: false,\n        lockRotationY: false,\n        lockRotationZ: false,\n        isTrigger: false,\n        filter: { ...DEFAULT_FILTER },\n        userData: null,\n    };\n}\n\n// ============================================\n// Body Operations\n// ============================================\n\nexport function setBodyMass(body: RigidBody, mass: number): void {\n    if (body.type !== BodyType.Dynamic) return;\n    body.mass = toFixed(mass);\n    body.invMass = mass > 0 ? fpDiv(FP_ONE, body.mass) : 0;\n}\n\nexport function setBodyVelocity(body: RigidBody, vx: number, vy: number, vz: number): void {\n    body.linearVelocity = vec3FromFloats(vx, vy, vz);\n    body.isSleeping = false;\n}\n\nexport function applyImpulse(body: RigidBody, impulse: Vec3, point?: Vec3): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n\n    body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(impulse, body.invMass));\n\n    if (point) {\n        const r = vec3Sub(point, body.position);\n        const torque = vec3Cross(r, impulse);\n        body.angularVelocity = vec3Add(body.angularVelocity, vec3Scale(torque, body.invInertia));\n    }\n\n    body.isSleeping = false;\n}\n\nexport function applyForce(body: RigidBody, force: Vec3, dt: Fixed): void {\n    if (body.type !== BodyType.Dynamic || body.invMass === 0) return;\n    const impulse = vec3Scale(force, dt);\n    applyImpulse(body, impulse);\n}\n", "/**\n * Collision Detection and Response\n *\n * Handles narrow-phase collision detection between shapes and\n * impulse-based collision response.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpMin, fpSqrt, fpClamp } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Sub, vec3Add, vec3Scale, vec3Neg, vec3Dot, vec3Cross, vec3LengthSq, vec3Normalize } from '../../math/vec';\nimport { quatRotateVec3, quatConjugate } from '../../math/quat';\nimport { ShapeType, SphereShape, BoxShape, AABB } from './shapes';\nimport { RigidBody, BodyType, applyImpulse } from './rigid-body';\n\n// ============================================\n// Constants\n// ============================================\n\nconst POSITION_CORRECTION = toFixed(0.6);  // Slightly less aggressive correction\nconst SLOP = toFixed(0.05);                 // Penetration allowance to reduce jitter\nconst WAKE_VELOCITY_THRESHOLD = toFixed(1.5);  // Threshold for waking sleeping bodies\n\n// ============================================\n// AABB Computation\n// ============================================\n\nexport function computeAABB(body: RigidBody): AABB {\n    const pos = body.position;\n    const shape = body.shape;\n\n    if (shape.type === ShapeType.Sphere) {\n        const r = shape.radius;\n        return {\n            min: { x: pos.x - r, y: pos.y - r, z: pos.z - r },\n            max: { x: pos.x + r, y: pos.y + r, z: pos.z + r }\n        };\n    } else {\n        // For rotated boxes, compute world-space AABB by projecting onto each world axis\n        const h = shape.halfExtents;\n\n        // Get the box axes in world space\n        const axisX = quatRotateVec3(body.rotation, vec3(FP_ONE, 0, 0));\n        const axisY = quatRotateVec3(body.rotation, vec3(0, FP_ONE, 0));\n        const axisZ = quatRotateVec3(body.rotation, vec3(0, 0, FP_ONE));\n\n        // Compute the extent along each world axis\n        const extentX = fpAbs(fpMul(axisX.x, h.x)) + fpAbs(fpMul(axisY.x, h.y)) + fpAbs(fpMul(axisZ.x, h.z));\n        const extentY = fpAbs(fpMul(axisX.y, h.x)) + fpAbs(fpMul(axisY.y, h.y)) + fpAbs(fpMul(axisZ.y, h.z));\n        const extentZ = fpAbs(fpMul(axisX.z, h.x)) + fpAbs(fpMul(axisY.z, h.y)) + fpAbs(fpMul(axisZ.z, h.z));\n\n        return {\n            min: { x: pos.x - extentX, y: pos.y - extentY, z: pos.z - extentZ },\n            max: { x: pos.x + extentX, y: pos.y + extentY, z: pos.z + extentZ }\n        };\n    }\n}\n\n// ============================================\n// Contact Types\n// ============================================\n\nexport interface ContactPoint {\n    point: Vec3;\n    penetration: Fixed;\n}\n\nexport interface Contact {\n    bodyA: RigidBody;\n    bodyB: RigidBody;\n    normal: Vec3;          // Points from B toward A (standard convention)\n    points: ContactPoint[]; // Multiple contact points (contact manifold)\n}\n\n// ============================================\n// Collision Detection Functions\n// ============================================\n\nfunction sphereSphereCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as SphereShape;\n    const shapeB = b.shape as SphereShape;\n\n    const diff = vec3Sub(a.position, b.position);  // Points from B to A\n    const distSq = vec3LengthSq(diff);\n    const minDist = shapeA.radius + shapeB.radius;\n    const minDistSq = fpMul(minDist, minDist);\n\n    if (distSq >= minDistSq) return null;\n\n    const dist = fpSqrt(distSq);\n    const normal = dist > 0 ? vec3Scale(diff, fpDiv(FP_ONE, dist)) : vec3(FP_ONE, 0, 0);\n    const penetration = minDist - dist;\n    const point = vec3Sub(a.position, vec3Scale(normal, shapeA.radius));\n\n    return { bodyA: a, bodyB: b, normal, points: [{ point, penetration }] };\n}\n\nfunction sphereBoxCollision(sphere: RigidBody, box: RigidBody): Contact | null {\n    const sphereShape = sphere.shape as SphereShape;\n    const boxShape = box.shape as BoxShape;\n\n    // Transform sphere center into box's local space (accounting for rotation)\n    const worldDiff = vec3Sub(sphere.position, box.position);\n    const invRotation = quatConjugate(box.rotation);\n    const localSphere = quatRotateVec3(invRotation, worldDiff);\n    const h = boxShape.halfExtents;\n\n    // Find closest point on box to sphere center (in local space)\n    const closestLocal: Vec3 = {\n        x: fpClamp(localSphere.x, -h.x, h.x),\n        y: fpClamp(localSphere.y, -h.y, h.y),\n        z: fpClamp(localSphere.z, -h.z, h.z)\n    };\n\n    const diffLocal = vec3Sub(localSphere, closestLocal);\n    const distSq = vec3LengthSq(diffLocal);\n    const radiusSq = fpMul(sphereShape.radius, sphereShape.radius);\n\n    if (distSq >= radiusSq) return null;\n\n    const dist = fpSqrt(distSq);\n\n    let normalLocal: Vec3;\n    let penetration: Fixed;\n\n    if (dist > 0) {\n        normalLocal = vec3Scale(diffLocal, fpDiv(FP_ONE, dist));\n        penetration = sphereShape.radius - dist;\n    } else {\n        // Sphere center inside box - find shortest axis to push out\n        const dx = h.x - fpAbs(localSphere.x);\n        const dy = h.y - fpAbs(localSphere.y);\n        const dz = h.z - fpAbs(localSphere.z);\n\n        if (dx <= dy && dx <= dz) {\n            normalLocal = localSphere.x >= 0 ? vec3(FP_ONE, 0, 0) : vec3(-FP_ONE, 0, 0);\n            penetration = dx + sphereShape.radius;\n        } else if (dy <= dz) {\n            normalLocal = localSphere.y >= 0 ? vec3(0, FP_ONE, 0) : vec3(0, -FP_ONE, 0);\n            penetration = dy + sphereShape.radius;\n        } else {\n            normalLocal = localSphere.z >= 0 ? vec3(0, 0, FP_ONE) : vec3(0, 0, -FP_ONE);\n            penetration = dz + sphereShape.radius;\n        }\n    }\n\n    // Transform contact point and normal back to world space\n    const worldClosest = vec3Add(box.position, quatRotateVec3(box.rotation, closestLocal));\n    const worldNormal = quatRotateVec3(box.rotation, normalLocal);\n\n    return { bodyA: sphere, bodyB: box, normal: worldNormal, points: [{ point: worldClosest, penetration }] };\n}\n\nfunction boxBoxCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const shapeA = a.shape as BoxShape;\n    const shapeB = b.shape as BoxShape;\n    const hA = shapeA.halfExtents;\n    const hB = shapeB.halfExtents;\n\n    // Get rotated axes for both boxes\n    const axesA = [\n        quatRotateVec3(a.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(a.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(a.rotation, vec3(0, 0, FP_ONE))\n    ];\n    const axesB = [\n        quatRotateVec3(b.rotation, vec3(FP_ONE, 0, 0)),\n        quatRotateVec3(b.rotation, vec3(0, FP_ONE, 0)),\n        quatRotateVec3(b.rotation, vec3(0, 0, FP_ONE))\n    ];\n\n    const extentsA = [hA.x, hA.y, hA.z];\n    const extentsB = [hB.x, hB.y, hB.z];\n    const d = vec3Sub(b.position, a.position);\n\n    let minPen = 0x7FFFFFFF as Fixed;\n    let bestNormal = vec3(0, FP_ONE, 0);\n\n    // Project extent onto axis\n    function project(axes: Vec3[], extents: Fixed[], axis: Vec3): Fixed {\n        return fpAbs(fpMul(vec3Dot(axes[0], axis), extents[0])) +\n               fpAbs(fpMul(vec3Dot(axes[1], axis), extents[1])) +\n               fpAbs(fpMul(vec3Dot(axes[2], axis), extents[2]));\n    }\n\n    // Test separation on axis, returns false if separated\n    function testAxis(axis: Vec3): boolean {\n        const lenSq = vec3LengthSq(axis);\n        if (lenSq < toFixed(0.0001)) return true; // Skip degenerate\n\n        const len = fpSqrt(lenSq);\n        const n = vec3Scale(axis, fpDiv(FP_ONE, len));\n\n        const pA = project(axesA, extentsA, n);\n        const pB = project(axesB, extentsB, n);\n        const dist = fpAbs(vec3Dot(d, n));\n        const pen = (pA + pB) - dist;\n\n        if (pen <= 0) return false;\n        if (pen < minPen) {\n            minPen = pen;\n            bestNormal = vec3Dot(d, n) < 0 ? n : vec3Neg(n);\n        }\n        return true;\n    }\n\n    // Test 15 SAT axes\n    for (let i = 0; i < 3; i++) {\n        if (!testAxis(axesA[i])) return null;\n        if (!testAxis(axesB[i])) return null;\n    }\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            if (!testAxis(vec3Cross(axesA[i], axesB[j]))) return null;\n        }\n    }\n\n    // Generate proper contact manifold based on the type of contact\n    const contactPoints: ContactPoint[] = [];\n\n    // Determine which body's face is the reference (the one whose normal we're using)\n    const volumeA = fpMul(fpMul(hA.x, hA.y), hA.z);\n    const volumeB = fpMul(fpMul(hB.x, hB.y), hB.z);\n\n    // Find all vertices of the incident body (smaller one) that are below the reference face\n    const incidentBody = volumeB <= volumeA ? b : a;\n    const incidentHalf = volumeB <= volumeA ? hB : hA;\n    const referenceBody = volumeB <= volumeA ? a : b;\n\n    // For each vertex of the incident body, project onto reference face and check penetration\n    const signs: [number, number, number][] = [\n        [-1, -1, -1], [-1, -1, 1], [-1, 1, -1], [-1, 1, 1],\n        [1, -1, -1], [1, -1, 1], [1, 1, -1], [1, 1, 1]\n    ];\n\n    // Calculate reference face plane normal\n    const refFaceNormal = volumeB <= volumeA ? bestNormal : vec3Neg(bestNormal);\n\n    interface VertexContact {\n        point: Vec3;\n        depth: Fixed;\n    }\n    const vertexContacts: VertexContact[] = [];\n\n    const refAxes = volumeB <= volumeA ? axesA : axesB;\n    const refHalf = volumeB <= volumeA ? hA : hB;\n\n    for (const [sx, sy, sz] of signs) {\n        const localV = vec3(\n            fpMul(incidentHalf.x, toFixed(sx)),\n            fpMul(incidentHalf.y, toFixed(sy)),\n            fpMul(incidentHalf.z, toFixed(sz))\n        );\n        const worldV = vec3Add(incidentBody.position, quatRotateVec3(incidentBody.rotation, localV));\n\n        // Calculate how deep this vertex is along the collision normal direction\n        const toVertex = vec3Sub(worldV, referenceBody.position);\n        const normalDist = vec3Dot(toVertex, refFaceNormal);\n\n        // Get the reference body's extent along the normal\n        const refExtent = fpMul(fpAbs(vec3Dot(refAxes[0], refFaceNormal)), refHalf.x) +\n                          fpMul(fpAbs(vec3Dot(refAxes[1], refFaceNormal)), refHalf.y) +\n                          fpMul(fpAbs(vec3Dot(refAxes[2], refFaceNormal)), refHalf.z);\n\n        const depth = normalDist + refExtent;\n\n        if (depth > 0) {\n            vertexContacts.push({ point: worldV, depth });\n        }\n    }\n\n    // Sort by depth and take the deepest vertices (up to 4 for face contact)\n    // Use position as tiebreaker for deterministic stable sort\n    vertexContacts.sort((a, b) => {\n        const depthDiff = b.depth - a.depth;\n        if (depthDiff !== 0) return depthDiff;\n        // Tiebreaker using point position for determinism\n        return (a.point.x - b.point.x) || (a.point.y - b.point.y) || (a.point.z - b.point.z);\n    });\n\n    // Use vertices with similar depth (within threshold of deepest)\n    const DEPTH_THRESHOLD = toFixed(0.05);\n    const maxDepth = vertexContacts.length > 0 ? vertexContacts[0].depth : 0 as Fixed;\n\n    for (const vc of vertexContacts) {\n        if (vc.depth > maxDepth - DEPTH_THRESHOLD) {\n            contactPoints.push({ point: vc.point, penetration: vc.depth });\n        }\n        if (contactPoints.length >= 4) break; // Max 4 contact points\n    }\n\n    // Fallback: use the SAT penetration point\n    if (contactPoints.length === 0) {\n        const midPoint = vec3Scale(vec3Add(a.position, b.position), FP_HALF);\n        contactPoints.push({ point: midPoint, penetration: minPen });\n    }\n\n    return { bodyA: a, bodyB: b, normal: bestNormal, points: contactPoints };\n}\n\nexport function detectCollision(a: RigidBody, b: RigidBody): Contact | null {\n    const typeA = a.shape.type;\n    const typeB = b.shape.type;\n\n    if (typeA === ShapeType.Sphere && typeB === ShapeType.Sphere) {\n        return sphereSphereCollision(a, b);\n    } else if (typeA === ShapeType.Sphere && typeB === ShapeType.Box) {\n        return sphereBoxCollision(a, b);\n    } else if (typeA === ShapeType.Box && typeB === ShapeType.Sphere) {\n        const contact = sphereBoxCollision(b, a);\n        if (contact) {\n            // Swap bodies and flip normal\n            return {\n                bodyA: a,\n                bodyB: b,\n                normal: vec3Neg(contact.normal),\n                points: contact.points\n            };\n        }\n        return null;\n    } else {\n        return boxBoxCollision(a, b);\n    }\n}\n\n// ============================================\n// Collision Response\n// ============================================\n\nexport function resolveCollision(contact: Contact): void {\n    const { bodyA, bodyB, normal, points } = contact;\n\n    // Skip if both are static/kinematic or no contact points\n    if (bodyA.invMass === 0 && bodyB.invMass === 0) return;\n    if (points.length === 0) return;\n\n    // Calculate relative velocity along collision normal to determine wake conditions\n    const relVelForWake = vec3Sub(bodyA.linearVelocity, bodyB.linearVelocity);\n    const impactVelocity = fpAbs(vec3Dot(relVelForWake, normal));\n\n    // Check if this is a resting contact (bodies gently settling, not impacting)\n    const isRestingContact = impactVelocity < WAKE_VELOCITY_THRESHOLD;\n\n    // If one body is sleeping and this is a resting contact, keep it sleeping\n    // Apply position correction only without waking\n    if (isRestingContact && (bodyA.isSleeping || bodyB.isSleeping)) {\n        for (const cp of points) {\n            const penetration = cp.penetration;\n            if (penetration > SLOP) {\n                const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n                if (pureInvMassSum > 0) {\n                    const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n                    const correctionVec = vec3Scale(normal, correction);\n\n                    // Only move non-sleeping bodies\n                    if (bodyA.invMass > 0 && !bodyA.isSleeping) {\n                        bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n                    }\n                    if (bodyB.invMass > 0 && !bodyB.isSleeping) {\n                        bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    const numContacts = points.length;\n    const invNumContacts = fpDiv(FP_ONE, toFixed(numContacts));\n\n    // Restitution (use minimum)\n    const e = fpMin(bodyA.restitution, bodyB.restitution);\n    const frictionCoeff = fpDiv(bodyA.friction + bodyB.friction, toFixed(2));\n\n    // Process each contact point\n    for (const cp of points) {\n        const point = cp.point;\n        const penetration = cp.penetration;\n\n        // Calculate radius vectors from center of mass to contact point\n        const rA = vec3Sub(point, bodyA.position);\n        const rB = vec3Sub(point, bodyB.position);\n\n        // Calculate velocity at contact point (including rotation)\n        const velA = vec3Add(bodyA.linearVelocity, vec3Cross(bodyA.angularVelocity, rA));\n        const velB = vec3Add(bodyB.linearVelocity, vec3Cross(bodyB.angularVelocity, rB));\n        const relVel = vec3Sub(velA, velB);\n\n        const velAlongNormal = vec3Dot(relVel, normal);\n\n        // Only resolve if approaching\n        if (velAlongNormal < 0) {\n            // Calculate impulse magnitude\n            const rACrossN = vec3Cross(rA, normal);\n            const rBCrossN = vec3Cross(rB, normal);\n\n            const angularInertiaA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rACrossN, rACrossN), bodyA.invInertia);\n            const angularInertiaB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                ? 0 : fpMul(vec3Dot(rBCrossN, rBCrossN), bodyB.invInertia);\n\n            const invMassSum = bodyA.invMass + bodyB.invMass + angularInertiaA + angularInertiaB;\n            let j = fpMul(-(FP_ONE + e), velAlongNormal);\n            j = fpDiv(j, invMassSum);\n            j = fpMul(j, invNumContacts);  // Distribute across contacts\n\n            const impulse = vec3Scale(normal, j);\n\n            if (bodyA.invMass > 0) {\n                applyImpulse(bodyA, impulse, point);\n            }\n            if (bodyB.invMass > 0) {\n                applyImpulse(bodyB, vec3Neg(impulse), point);\n            }\n\n            // Friction\n            const tangent = vec3Sub(relVel, vec3Scale(normal, velAlongNormal));\n            const tangentLenSq = vec3LengthSq(tangent);\n\n            if (tangentLenSq > toFixed(0.0001)) {\n                const tangentNorm = vec3Normalize(tangent);\n                const rACrossT = vec3Cross(rA, tangentNorm);\n                const rBCrossT = vec3Cross(rB, tangentNorm);\n\n                const angularInertiaTA = (bodyA.lockRotationX && bodyA.lockRotationY && bodyA.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rACrossT, rACrossT), bodyA.invInertia);\n                const angularInertiaTB = (bodyB.lockRotationX && bodyB.lockRotationY && bodyB.lockRotationZ)\n                    ? 0 : fpMul(vec3Dot(rBCrossT, rBCrossT), bodyB.invInertia);\n\n                const invMassSumT = bodyA.invMass + bodyB.invMass + angularInertiaTA + angularInertiaTB;\n                const tangentSpeed = fpSqrt(tangentLenSq);\n                let jt = fpDiv(tangentSpeed, invMassSumT);\n                jt = fpMul(jt, invNumContacts);  // Distribute\n\n                const maxFriction = fpMul(fpAbs(j), frictionCoeff);\n                if (jt > maxFriction) jt = maxFriction;\n\n                const frictionImpulse = vec3Scale(tangentNorm, -jt);\n\n                if (bodyA.invMass > 0) {\n                    applyImpulse(bodyA, frictionImpulse, point);\n                }\n                if (bodyB.invMass > 0) {\n                    applyImpulse(bodyB, vec3Neg(frictionImpulse), point);\n                }\n            }\n        }\n\n        // Position correction for this contact\n        if (penetration > SLOP) {\n            const pureInvMassSum = bodyA.invMass + bodyB.invMass;\n            const correction = fpMul(fpDiv(penetration - SLOP, pureInvMassSum), POSITION_CORRECTION);\n            const scaledCorrection = fpMul(correction, invNumContacts);  // Distribute\n            const correctionVec = vec3Scale(normal, scaledCorrection);\n\n            if (bodyA.invMass > 0) {\n                bodyA.position = vec3Add(bodyA.position, vec3Scale(correctionVec, bodyA.invMass));\n            }\n            if (bodyB.invMass > 0) {\n                bodyB.position = vec3Sub(bodyB.position, vec3Scale(correctionVec, bodyB.invMass));\n            }\n        }\n    }\n}\n", "/**\n * Trigger System\n *\n * Handles trigger (sensor) bodies that detect overlap without physics response.\n * Generic implementation shared between 2D and 3D physics engines.\n */\n\n// ============================================\n// Body Interface (minimal contract)\n// ============================================\n\n/**\n * Minimal interface for a physics body used by triggers.\n * Both RigidBody (3D) and RigidBody2D implement this.\n */\nexport interface TriggerBody {\n    label: string;\n    isTrigger: boolean;\n}\n\n// ============================================\n// Trigger Event\n// ============================================\n\nexport interface TriggerEvent<T extends TriggerBody = TriggerBody> {\n    trigger: T;\n    other: T;\n}\n\ntype TriggerCallback<T extends TriggerBody> = (event: TriggerEvent<T>) => void;\n\n// ============================================\n// Trigger State\n// ============================================\n\nexport class TriggerState<T extends TriggerBody = TriggerBody> {\n    private overlaps = new Map<string, { trigger: T; other: T }>();\n    private enterCallbacks: TriggerCallback<T>[] = [];\n    private stayCallbacks: TriggerCallback<T>[] = [];\n    private exitCallbacks: TriggerCallback<T>[] = [];\n\n    onEnter(cb: TriggerCallback<T>): void { this.enterCallbacks.push(cb); }\n    onStay(cb: TriggerCallback<T>): void { this.stayCallbacks.push(cb); }\n    onExit(cb: TriggerCallback<T>): void { this.exitCallbacks.push(cb); }\n\n    processOverlaps(currentOverlaps: TriggerEvent<T>[]): void {\n        const currentKeys = new Set<string>();\n        const sortedOverlaps = [...currentOverlaps].sort((a, b) => {\n            return this.makeKey(a.trigger, a.other).localeCompare(this.makeKey(b.trigger, b.other));\n        });\n\n        for (const overlap of sortedOverlaps) {\n            const key = this.makeKey(overlap.trigger, overlap.other);\n            currentKeys.add(key);\n\n            if (this.overlaps.has(key)) {\n                for (const cb of this.stayCallbacks) cb(overlap);\n            } else {\n                this.overlaps.set(key, overlap);\n                for (const cb of this.enterCallbacks) cb(overlap);\n            }\n        }\n\n        const sortedExistingKeys = [...this.overlaps.keys()].sort();\n        for (const key of sortedExistingKeys) {\n            if (!currentKeys.has(key)) {\n                const overlap = this.overlaps.get(key)!;\n                this.overlaps.delete(key);\n                for (const cb of this.exitCallbacks) cb(overlap);\n            }\n        }\n    }\n\n    clear(): void {\n        this.overlaps.clear();\n    }\n\n    removeBody(body: T): void {\n        const keysToRemove: string[] = [];\n        for (const [key, overlap] of this.overlaps) {\n            if (overlap.trigger === body || overlap.other === body) {\n                keysToRemove.push(key);\n            }\n        }\n        keysToRemove.sort();\n        for (const key of keysToRemove) {\n            const overlap = this.overlaps.get(key)!;\n            this.overlaps.delete(key);\n            for (const cb of this.exitCallbacks) cb(overlap);\n        }\n    }\n\n    getOverlappingBodies(trigger: T): T[] {\n        const bodies: T[] = [];\n        for (const overlap of this.overlaps.values()) {\n            if (overlap.trigger === trigger) {\n                bodies.push(overlap.other);\n            }\n        }\n        return bodies.sort((a, b) => a.label.localeCompare(b.label));\n    }\n\n    isBodyInTrigger(trigger: T, body: T): boolean {\n        return this.overlaps.has(this.makeKey(trigger, body));\n    }\n\n    overlapCount(): number {\n        return this.overlaps.size;\n    }\n\n    saveState(): [string, string][] {\n        const pairs: [string, string][] = [];\n        for (const overlap of this.overlaps.values()) {\n            pairs.push([overlap.trigger.label, overlap.other.label]);\n        }\n        return pairs.sort((a, b) => a[0].localeCompare(b[0]) || a[1].localeCompare(b[1]));\n    }\n\n    private pendingPairs: [string, string][] = [];\n\n    loadState(pairs: [string, string][]): void {\n        this.overlaps.clear();\n        this.pendingPairs = pairs;\n    }\n\n    syncWithWorld(bodies: T[]): void {\n        const bodyByLabel = new Map<string, T>();\n        for (const body of bodies) bodyByLabel.set(body.label, body);\n\n        for (const [triggerLabel, otherLabel] of this.pendingPairs) {\n            const trigger = bodyByLabel.get(triggerLabel);\n            const other = bodyByLabel.get(otherLabel);\n            if (trigger && other) {\n                this.overlaps.set(this.makeKey(trigger, other), { trigger, other });\n            }\n        }\n        this.pendingPairs = [];\n    }\n\n    private makeKey(trigger: T, other: T): string {\n        return `${trigger.label}:${other.label}`;\n    }\n}\n\n// ============================================\n// Helper Function\n// ============================================\n\n/**\n * Mark a body as a trigger (sensor).\n * Works with any body type that has an isTrigger property.\n */\nexport function makeTrigger<T extends TriggerBody>(body: T): T {\n    body.isTrigger = true;\n    return body;\n}\n", "/**\n * Physics World\n *\n * Manages the physics simulation including gravity, collision detection,\n * and integration of velocities and positions.\n */\n\nimport { Fixed, FP_ONE, FP_HALF, toFixed, fpMul, fpDiv, fpAbs, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Zero, vec3Clone, vec3Add, vec3Scale, vec3LengthSq } from '../../math/vec';\nimport { quatFromAxisAngle, quatMul, quatNormalize } from '../../math/quat';\nimport { aabbOverlap } from './shapes';\nimport { RigidBody, BodyType } from './rigid-body';\nimport { Contact, computeAABB, detectCollision, resolveCollision } from './collision';\nimport { shouldCollide } from './layers';\nimport { TriggerState, TriggerEvent } from './trigger';\n\n// ============================================\n// Constants\n// ============================================\n\nconst GRAVITY: Vec3 = { x: 0, y: toFixed(-30), z: 0 };  // -30 units/s\u00B2\nconst LINEAR_DAMPING = toFixed(0.1);      // 10% velocity loss per frame\nconst ANGULAR_DAMPING = toFixed(0.1);     // 10% angular velocity loss per frame\nconst SLEEP_THRESHOLD = toFixed(0.12);    // Sleep when nearly stopped\nconst SLEEP_FRAMES_REQUIRED = 20;         // ~0.33 seconds at 60fps before sleeping\nconst CONTACT_SLEEP_BONUS = 10;           // Extra sleep frames when in stable contact\nconst COLLISION_ITERATIONS = 8;           // Multiple iterations for stability\n\n// ============================================\n// World Interface\n// ============================================\n\nexport interface World {\n    bodies: RigidBody[];\n    gravity: Vec3;\n    dt: Fixed;  // Fixed timestep\n    triggers: TriggerState;  // Trigger/sensor event tracking\n    /** Step the physics simulation */\n    step(): Contact[];\n}\n\nexport function createWorld(dt: number = 1 / 60): World {\n    const world: World = {\n        bodies: [],\n        gravity: vec3Clone(GRAVITY),\n        dt: toFixed(dt),\n        triggers: new TriggerState(),\n        step() {\n            return stepWorld(world);\n        }\n    };\n    return world;\n}\n\nexport function addBody(world: World, body: RigidBody): void {\n    world.bodies.push(body);\n}\n\nexport function removeBody(world: World, body: RigidBody): void {\n    const index = world.bodies.indexOf(body);\n    if (index >= 0) {\n        world.bodies.splice(index, 1);\n        // Clean up trigger overlaps involving this body\n        world.triggers.removeBody(body);\n    }\n}\n\n// ============================================\n// Ground Check\n// ============================================\n\n/**\n * Check if a body is grounded (has a surface below it within threshold)\n * @param world The physics world\n * @param body The body to check\n * @param threshold Distance below to check (default 0.15)\n * @returns true if grounded\n */\nexport function isGrounded(world: World, body: RigidBody, threshold: number = 0.15): boolean {\n    const thresholdFP = toFixed(threshold);\n\n    for (const other of world.bodies) {\n        if (other === body) continue;\n\n        // Check if there's collision contact with normal pointing up\n        const contact = detectCollision(body, other);\n        if (contact && contact.normal.y > FP_HALF) {\n            // Normal pointing up means surface is below\n            return true;\n        }\n\n        // Also check slightly below current position\n        const savedY = body.position.y;\n        body.position.y = body.position.y - thresholdFP;\n        const contactBelow = detectCollision(body, other);\n        body.position.y = savedY;\n\n        if (contactBelow && contactBelow.normal.y > FP_HALF) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// ============================================\n// World Step\n// ============================================\n\nexport function stepWorld(world: World): Contact[] {\n    const { gravity, dt, triggers } = world;\n    const contacts: Contact[] = [];\n    const triggerOverlaps: TriggerEvent[] = [];\n\n    // CRITICAL: Sort bodies by label for deterministic collision processing order\n    const bodies = [...world.bodies].sort((a, b) => a.label.localeCompare(b.label));\n\n    // Track which bodies are in stable resting contact (for island sleeping)\n    const restingContactBodies = new Set<RigidBody>();\n    const sleepingContactBodies = new Set<RigidBody>();\n\n    // First pass: identify resting contacts and sleeping contact pairs\n    for (let i = 0; i < bodies.length; i++) {\n        for (let j = i + 1; j < bodies.length; j++) {\n            const a = bodies[i];\n            const b = bodies[j];\n\n            if (a.invMass === 0 && b.invMass === 0) continue;\n            if (!shouldCollide(a.filter, b.filter)) continue;\n\n            const aabbA = computeAABB(a);\n            const aabbB = computeAABB(b);\n            if (!aabbOverlap(aabbA, aabbB)) continue;\n\n            const contact = detectCollision(a, b);\n            if (contact) {\n                if (fpAbs(contact.normal.y) > FP_HALF) {\n                    restingContactBodies.add(a);\n                    restingContactBodies.add(b);\n\n                    if (a.isSleeping && b.type === BodyType.Dynamic) {\n                        const bSpeedSq = vec3LengthSq(b.linearVelocity) + vec3LengthSq(b.angularVelocity);\n                        if (bSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(b);\n                        }\n                    }\n                    if (b.isSleeping && a.type === BodyType.Dynamic) {\n                        const aSpeedSq = vec3LengthSq(a.linearVelocity) + vec3LengthSq(a.angularVelocity);\n                        if (aSpeedSq < fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD)) {\n                            sleepingContactBodies.add(a);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Integrate velocities (apply gravity)\n    for (const body of bodies) {\n        if (body.type !== BodyType.Dynamic) continue;\n        if (body.isSleeping) continue;\n\n        body.linearVelocity = vec3Add(body.linearVelocity, vec3Scale(gravity, dt));\n\n        let linearDamp = FP_ONE - LINEAR_DAMPING;\n        let angularDamp = FP_ONE - ANGULAR_DAMPING;\n\n        if (restingContactBodies.has(body)) {\n            linearDamp = fpMul(linearDamp, toFixed(0.95));\n            angularDamp = fpMul(angularDamp, toFixed(0.9));\n        }\n\n        body.linearVelocity = vec3Scale(body.linearVelocity, linearDamp);\n        body.angularVelocity = vec3Scale(body.angularVelocity, angularDamp);\n    }\n\n    // Multiple collision iterations for stability\n    for (let iter = 0; iter < COLLISION_ITERATIONS; iter++) {\n        for (let i = 0; i < bodies.length; i++) {\n            for (let j = i + 1; j < bodies.length; j++) {\n                const a = bodies[i];\n                const b = bodies[j];\n\n                if (a.invMass === 0 && b.invMass === 0) continue;\n                if (!shouldCollide(a.filter, b.filter)) continue;\n\n                const aabbA = computeAABB(a);\n                const aabbB = computeAABB(b);\n                if (!aabbOverlap(aabbA, aabbB)) continue;\n\n                const contact = detectCollision(a, b);\n                if (contact) {\n                    // Check if either body is a trigger\n                    const isTriggerCollision = a.isTrigger || b.isTrigger;\n\n                    if (isTriggerCollision) {\n                        // Record trigger overlap (only on first iteration)\n                        if (iter === 0) {\n                            // Determine which is the trigger\n                            if (a.isTrigger) {\n                                triggerOverlaps.push({ trigger: a, other: b });\n                            }\n                            if (b.isTrigger) {\n                                triggerOverlaps.push({ trigger: b, other: a });\n                            }\n                        }\n                        // Skip physics response for triggers\n                    } else {\n                        // Normal collision - apply physics response\n                        if (iter === 0) contacts.push(contact);\n                        resolveCollision(contact);\n                    }\n                }\n            }\n        }\n    }\n\n    // Process trigger events after collision detection\n    triggers.processOverlaps(triggerOverlaps);\n\n    // Integrate positions\n    for (const body of bodies) {\n        if (body.type === BodyType.Static) continue;\n        if (body.isSleeping) continue;\n\n        // Clamp tiny linear velocities to zero\n        const linearClampThreshold = toFixed(0.05);\n        if (fpAbs(body.linearVelocity.x) < linearClampThreshold) body.linearVelocity.x = 0;\n        if (fpAbs(body.linearVelocity.y) < linearClampThreshold) body.linearVelocity.y = 0;\n        if (fpAbs(body.linearVelocity.z) < linearClampThreshold) body.linearVelocity.z = 0;\n\n        body.position = vec3Add(body.position, vec3Scale(body.linearVelocity, dt));\n\n        // Skip rotation integration if all rotations are locked\n        if (body.lockRotationX && body.lockRotationY && body.lockRotationZ) {\n            continue;\n        }\n\n        // Apply rotation locks\n        let angVelX = body.lockRotationX ? 0 : body.angularVelocity.x;\n        let angVelY = body.lockRotationY ? 0 : body.angularVelocity.y;\n        let angVelZ = body.lockRotationZ ? 0 : body.angularVelocity.z;\n\n        // Clamp tiny angular velocities to zero\n        const angularClampThreshold = toFixed(0.01);\n        if (fpAbs(angVelX) < angularClampThreshold) angVelX = 0;\n        if (fpAbs(angVelY) < angularClampThreshold) angVelY = 0;\n        if (fpAbs(angVelZ) < angularClampThreshold) angVelZ = 0;\n\n        body.angularVelocity.x = angVelX;\n        body.angularVelocity.y = angVelY;\n        body.angularVelocity.z = angVelZ;\n\n        const angVelLengthSq = fpMul(angVelX, angVelX) + fpMul(angVelY, angVelY) + fpMul(angVelZ, angVelZ);\n\n        if (angVelLengthSq > 0) {\n            const angSpeed = fpSqrt(angVelLengthSq);\n            const angle = fpMul(angSpeed, dt);\n            const invSpeed = fpDiv(FP_ONE, angSpeed);\n            const axis = {\n                x: fpMul(angVelX, invSpeed),\n                y: fpMul(angVelY, invSpeed),\n                z: fpMul(angVelZ, invSpeed)\n            };\n            const rotDelta = quatFromAxisAngle(axis, angle);\n            body.rotation = quatNormalize(quatMul(rotDelta, body.rotation));\n        }\n\n        // Sleep detection\n        const speedSq = vec3LengthSq(body.linearVelocity);\n        const angSpeedSq = vec3LengthSq(body.angularVelocity);\n        const sleepThreshSq = fpMul(SLEEP_THRESHOLD, SLEEP_THRESHOLD);\n\n        if (speedSq < sleepThreshSq && angSpeedSq < sleepThreshSq) {\n            const sleepIncrement = sleepingContactBodies.has(body) ? (1 + CONTACT_SLEEP_BONUS) : 1;\n            body.sleepFrames += sleepIncrement;\n\n            if (body.sleepFrames >= SLEEP_FRAMES_REQUIRED) {\n                body.isSleeping = true;\n                body.linearVelocity = vec3Zero();\n                body.angularVelocity = vec3Zero();\n            }\n        } else {\n            body.sleepFrames = 0;\n            body.isSleeping = false;\n        }\n    }\n\n    return contacts;\n}\n", "/**\n * Raycasting\n *\n * Ray-body intersection tests for visibility checks,\n * hit detection, and other line-of-sight queries.\n */\n\nimport { Fixed, FP_ONE, toFixed, fpMul, fpDiv, fpSqrt } from '../../math/fixed';\nimport { Vec3, vec3, vec3Add, vec3Sub, vec3Scale, vec3Dot, vec3Normalize } from '../../math/vec';\nimport { ShapeType, SphereShape, BoxShape } from './shapes';\nimport { RigidBody } from './rigid-body';\nimport { World } from './world';\n\n// ============================================\n// Ray Hit Result\n// ============================================\n\nexport interface RayHit {\n    body: RigidBody;\n    point: Vec3;\n    normal: Vec3;\n    distance: Fixed;\n}\n\n// ============================================\n// Raycast Functions\n// ============================================\n\nexport function raycast(world: World, origin: Vec3, direction: Vec3, maxDistance: Fixed): RayHit | null {\n    const dir = vec3Normalize(direction);\n    let closestHit: RayHit | null = null;\n    let closestDist = maxDistance;\n\n    for (const body of world.bodies) {\n        const hit = raycastBody(body, origin, dir, closestDist);\n        if (hit && hit.distance < closestDist) {\n            closestDist = hit.distance;\n            closestHit = hit;\n        }\n    }\n\n    return closestHit;\n}\n\nfunction raycastBody(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    if (body.shape.type === ShapeType.Sphere) {\n        return raycastSphere(body, origin, dir, maxDist);\n    } else {\n        return raycastBox(body, origin, dir, maxDist);\n    }\n}\n\nfunction raycastSphere(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    const shape = body.shape as SphereShape;\n    const oc = vec3Sub(origin, body.position);\n\n    const a = vec3Dot(dir, dir);\n    const b = fpMul(toFixed(2), vec3Dot(oc, dir));\n    const c = vec3Dot(oc, oc) - fpMul(shape.radius, shape.radius);\n\n    const discriminant = fpMul(b, b) - fpMul(fpMul(toFixed(4), a), c);\n    if (discriminant < 0) return null;\n\n    const sqrtD = fpSqrt(discriminant);\n    let t = fpDiv(-b - sqrtD, fpMul(toFixed(2), a));\n\n    if (t < 0) {\n        t = fpDiv(-b + sqrtD, fpMul(toFixed(2), a));\n        if (t < 0) return null;\n    }\n\n    if (t > maxDist) return null;\n\n    const point = vec3Add(origin, vec3Scale(dir, t));\n    const normal = vec3Normalize(vec3Sub(point, body.position));\n\n    return { body, point, normal, distance: t };\n}\n\nfunction raycastBox(body: RigidBody, origin: Vec3, dir: Vec3, maxDist: Fixed): RayHit | null {\n    const shape = body.shape as BoxShape;\n    const h = shape.halfExtents;\n    const pos = body.position;\n\n    // AABB ray intersection\n    let tMin = -0x7FFFFFFF;\n    let tMax = 0x7FFFFFFF;\n    let normalAxis = 0;\n    let normalSign = 1;\n\n    // X axis\n    {\n        const invD = dir.x !== 0 ? fpDiv(FP_ONE, dir.x) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.x - h.x) - origin.x, invD);\n        let t1 = fpMul((pos.x + h.x) - origin.x, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 0; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    // Y axis\n    {\n        const invD = dir.y !== 0 ? fpDiv(FP_ONE, dir.y) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.y - h.y) - origin.y, invD);\n        let t1 = fpMul((pos.y + h.y) - origin.y, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 1; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    // Z axis\n    {\n        const invD = dir.z !== 0 ? fpDiv(FP_ONE, dir.z) : 0x7FFFFFFF;\n        let t0 = fpMul((pos.z - h.z) - origin.z, invD);\n        let t1 = fpMul((pos.z + h.z) - origin.z, invD);\n        if (invD < 0) [t0, t1] = [t1, t0];\n        if (t0 > tMin) { tMin = t0; normalAxis = 2; normalSign = invD < 0 ? 1 : -1; }\n        if (t1 < tMax) tMax = t1;\n        if (tMax < tMin) return null;\n    }\n\n    if (tMin < 0 || tMin > maxDist) return null;\n\n    const point = vec3Add(origin, vec3Scale(dir, tMin));\n    const normal = vec3(\n        normalAxis === 0 ? toFixed(normalSign) : 0,\n        normalAxis === 1 ? toFixed(normalSign) : 0,\n        normalAxis === 2 ? toFixed(normalSign) : 0\n    );\n\n    return { body, point, normal, distance: tMin };\n}\n", "/**\n * State Serialization\n *\n * Functions for saving and loading world state for rollback netcode.\n * Uses labels for body matching to ensure determinism across clients.\n */\n\nimport { Fixed } from '../../math/fixed';\nimport { World } from './world';\n\n// ============================================\n// State Interfaces\n// ============================================\n\nexport interface BodyState {\n    id: number;\n    label: string;  // Used for matching bodies across clients with different IDs\n    px: Fixed; py: Fixed; pz: Fixed;\n    qx: Fixed; qy: Fixed; qz: Fixed; qw: Fixed;\n    vx: Fixed; vy: Fixed; vz: Fixed;\n    avx: Fixed; avy: Fixed; avz: Fixed;\n    isSleeping: boolean;\n    sleepFrames: number;\n}\n\nexport interface WorldState {\n    bodies: BodyState[];\n}\n\n// ============================================\n// State Functions\n// ============================================\n\nexport function saveWorldState(world: World): WorldState {\n    return {\n        bodies: world.bodies.map(b => ({\n            id: b.id,\n            label: b.label,\n            px: b.position.x, py: b.position.y, pz: b.position.z,\n            qx: b.rotation.x, qy: b.rotation.y, qz: b.rotation.z, qw: b.rotation.w,\n            vx: b.linearVelocity.x, vy: b.linearVelocity.y, vz: b.linearVelocity.z,\n            avx: b.angularVelocity.x, avy: b.angularVelocity.y, avz: b.angularVelocity.z,\n            isSleeping: b.isSleeping,\n            sleepFrames: b.sleepFrames,\n        }))\n    };\n}\n\nexport function loadWorldState(world: World, state: WorldState): void {\n    // Build set of labels that should exist\n    const snapshotLabels = new Set(state.bodies.map(bs => bs.label));\n\n    // Remove bodies that exist in world but not in snapshot (created after snapshot was taken)\n    for (let i = world.bodies.length - 1; i >= 0; i--) {\n        if (!snapshotLabels.has(world.bodies[i].label)) {\n            world.bodies.splice(i, 1);\n        }\n    }\n\n    // Use label for matching - body IDs may differ across clients\n    const bodyMap = new Map(world.bodies.map(b => [b.label, b]));\n\n    for (const bs of state.bodies) {\n        const body = bodyMap.get(bs.label);\n        if (!body) continue;\n\n        body.position = { x: bs.px, y: bs.py, z: bs.pz };\n        body.rotation = { x: bs.qx, y: bs.qy, z: bs.qz, w: bs.qw };\n        body.linearVelocity = { x: bs.vx, y: bs.vy, z: bs.vz };\n        body.angularVelocity = { x: bs.avx, y: bs.avy, z: bs.avz };\n        body.isSleeping = bs.isSleeping;\n        body.sleepFrames = bs.sleepFrames;\n    }\n}\n", "/**\r\n * Rollback Networking for Deterministic Multiplayer\r\n *\r\n * Implements GGPO-style rollback netcode:\r\n * - Input delay buffer\r\n * - State snapshots for rollback\r\n * - Resimulation when late inputs arrive\r\n * - Input prediction for remote players\r\n *\r\n * Physics-agnostic: the game provides callbacks for state save/load/tick.\r\n * Works with modu-network for transport.\r\n */\r\n\r\n// Debug flag - set to true to enable verbose rollback logging\r\nconst DEBUG_ROLLBACK = false;\r\n\r\n// ============================================\r\n// Input Types\r\n// ============================================\r\n\r\nexport interface PlayerInput {\r\n    frame: number;\r\n    playerId: string;\r\n    data: any;           // Game-specific input data\r\n    predicted: boolean;  // Was this input predicted?\r\n}\r\n\r\nexport interface InputBuffer {\r\n    inputs: Map<number, PlayerInput[]>;  // frame -> inputs for that frame\r\n    lastConfirmedFrame: number;\r\n    lastReceivedFrame: Map<string, number>;  // playerId -> last frame we have confirmed input for\r\n}\r\n\r\n// ============================================\r\n// Snapshot Storage\r\n// ============================================\r\n\r\nexport interface Snapshot {\r\n    frame: number;\r\n    state: any;  // Opaque state - game decides what to save (entities, physics, etc.)\r\n}\r\n\r\n// ============================================\r\n// Rollback Manager\r\n// ============================================\r\n\r\nexport interface RollbackConfig {\r\n    inputDelay: number;        // Frames of local input delay (default: 2)\r\n    maxRollbackFrames: number; // Maximum frames to roll back (default: 8)\r\n    maxPredictionFrames: number; // Maximum frames to predict ahead (default: 8)\r\n    snapshotInterval: number;  // Save snapshot every N frames (default: 1)\r\n}\r\n\r\nexport interface RollbackManager {\r\n    // State\r\n    currentFrame: number;\r\n    localPlayerId: string;\r\n    players: Set<string>;\r\n\r\n    // Configuration\r\n    config: RollbackConfig;\r\n\r\n    // Input management\r\n    inputBuffer: InputBuffer;\r\n    localInputQueue: PlayerInput[];  // Delayed local inputs\r\n\r\n    // Snapshot management\r\n    snapshots: Map<number, Snapshot>;\r\n\r\n    // Callbacks (game provides these)\r\n    /** Save entire state (entities, physics, game data) - returns opaque state */\r\n    saveState: () => any;\r\n    /** Restore entire state */\r\n    loadState: (state: any) => void;\r\n    /** Execute one frame: apply inputs, step physics, update entities */\r\n    tick: (frame: number, inputs: PlayerInput[]) => void;\r\n    /** Compute sync checksum for state verification */\r\n    computeChecksum: () => number;\r\n\r\n    // Rollback tracking\r\n    /** Frame that needs rollback due to prediction mismatch (set by addInputToBuffer) */\r\n    pendingRollbackFrame?: number;\r\n\r\n    // Stats\r\n    rollbackCount: number;\r\n    maxRollbackDepth: number;\r\n    predictionMisses: number;\r\n}\r\n\r\nexport function createRollbackManager(\r\n    localPlayerId: string,\r\n    config: Partial<RollbackConfig> = {}\r\n): RollbackManager {\r\n    const inputDelay = config.inputDelay ?? 2;\r\n\r\n    return {\r\n        currentFrame: 0,\r\n        localPlayerId,\r\n        players: new Set([localPlayerId]),\r\n\r\n        config: {\r\n            inputDelay,\r\n            maxRollbackFrames: config.maxRollbackFrames ?? 8,\r\n            maxPredictionFrames: config.maxPredictionFrames ?? 8,\r\n            snapshotInterval: config.snapshotInterval ?? 1,\r\n        },\r\n\r\n        inputBuffer: {\r\n            inputs: new Map(),\r\n            lastConfirmedFrame: -1,\r\n            // Initialize lastReceivedFrame for local player\r\n            // This prevents confirmedFrame from being stuck at -1\r\n            lastReceivedFrame: new Map([[localPlayerId, 0]]),\r\n        },\r\n\r\n        localInputQueue: [],\r\n\r\n        snapshots: new Map(),\r\n\r\n        // These must be set by the game\r\n        saveState: () => ({}),\r\n        loadState: () => { },\r\n        tick: () => { },\r\n        computeChecksum: () => 0,\r\n\r\n        rollbackCount: 0,\r\n        maxRollbackDepth: 0,\r\n        predictionMisses: 0,\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Player Management\r\n// ============================================\r\n\r\nexport function addPlayer(manager: RollbackManager, playerId: string): void {\r\n    manager.players.add(playerId);\r\n    manager.inputBuffer.lastReceivedFrame.set(playerId, -1);\r\n}\r\n\r\n/**\r\n * Add a player who joins mid-game at a specific frame.\r\n * This properly initializes lastReceivedFrame and updates lastConfirmedFrame\r\n * to prevent the confirmation logic from getting stuck on frames before\r\n * the player joined (where they have no inputs).\r\n */\r\nexport function addPlayerAtFrame(manager: RollbackManager, playerId: string, joinFrame: number): void {\r\n    manager.players.add(playerId);\r\n    manager.inputBuffer.lastReceivedFrame.set(playerId, joinFrame);\r\n\r\n    // Update lastConfirmedFrame to skip frames before this player joined\r\n    // Otherwise updateConfirmedFrame will fail because the new player\r\n    // has no inputs for frames before their join\r\n    if (joinFrame - 1 > manager.inputBuffer.lastConfirmedFrame) {\r\n        manager.inputBuffer.lastConfirmedFrame = joinFrame - 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Clear snapshots older than a given frame.\r\n * Use this when adding a new player dynamically - it prevents rollback to\r\n * frames before the player's body existed in the physics world.\r\n *\r\n * Without this, a rollback to a snapshot without the player's body would cause\r\n * desync because the re-simulation would not include that player's physics.\r\n */\r\nexport function clearSnapshotsBefore(manager: RollbackManager, frame: number): void {\r\n    for (const snapshotFrame of manager.snapshots.keys()) {\r\n        if (snapshotFrame < frame) {\r\n            manager.snapshots.delete(snapshotFrame);\r\n        }\r\n    }\r\n    // Also clear inputs before this frame to prevent rollback triggering\r\n    for (const inputFrame of manager.inputBuffer.inputs.keys()) {\r\n        if (inputFrame < frame) {\r\n            manager.inputBuffer.inputs.delete(inputFrame);\r\n        }\r\n    }\r\n}\r\n\r\nexport function removePlayer(manager: RollbackManager, playerId: string): void {\r\n    manager.players.delete(playerId);\r\n    manager.inputBuffer.lastReceivedFrame.delete(playerId);\r\n}\r\n\r\n// ============================================\r\n// Input Management\r\n// ============================================\r\n\r\n/** Add local input (will be delayed by inputDelay frames) */\r\nexport function addLocalInput(manager: RollbackManager, data: any): void {\r\n    const { currentFrame, config, localPlayerId, inputBuffer } = manager;\r\n    const targetFrame = currentFrame + config.inputDelay;\r\n\r\n    // Add CONFIRMED input for the target frame (when input will be \"official\")\r\n    const input: PlayerInput = {\r\n        frame: targetFrame,\r\n        playerId: localPlayerId,\r\n        data,\r\n        predicted: false,\r\n    };\r\n\r\n    manager.localInputQueue.push(input);\r\n    addInputToBuffer(manager, input);\r\n\r\n    // Update lastReceivedFrame for local player\r\n    // This is critical for confirmedFrame calculation\r\n    const lastReceived = inputBuffer.lastReceivedFrame.get(localPlayerId) ?? -1;\r\n    if (targetFrame > lastReceived) {\r\n        inputBuffer.lastReceivedFrame.set(localPlayerId, targetFrame);\r\n    }\r\n\r\n    // KEY FOR ZERO PERCEIVED LATENCY:\r\n    // Also add PREDICTIONS for frames between current and target.\r\n    // This gives immediate local response while maintaining network sync.\r\n    //\r\n    // For LOCAL player predictions:\r\n    // - We MUST update existing predictions with the latest input data\r\n    // - When we send input for frame N+delay, remote clients backfill frames N to N+delay-1\r\n    // - If we don't update our own predictions, we desync because remote has new data, we have old\r\n    //\r\n    // For REMOTE player predictions (handled in addRemoteInput):\r\n    // - Only add if no prediction exists, to avoid overwriting with outdated data\r\n    for (let f = currentFrame; f < targetFrame; f++) {\r\n        const frameInputs = inputBuffer.inputs.get(f);\r\n        const existingInput = frameInputs?.find(i => i.playerId === localPlayerId);\r\n\r\n        // For local player: always update predictions with latest input\r\n        // (Remote players receive this same data via backfill in addRemoteInput)\r\n        if (!existingInput) {\r\n            // No input exists - add new prediction\r\n            const prediction: PlayerInput = {\r\n                frame: f,\r\n                playerId: localPlayerId,\r\n                data,\r\n                predicted: true,\r\n            };\r\n            addInputToBuffer(manager, prediction);\r\n        } else if (existingInput.predicted) {\r\n            // Existing prediction - update with latest data\r\n            existingInput.data = data;\r\n        } else if (f === currentFrame) {\r\n            // CRITICAL FIX: For the CURRENT frame, also update confirmed inputs!\r\n            // The \"confirmed\" input was scheduled from a previous frame (currentFrame - inputDelay).\r\n            // But the player's CURRENT input (what they're pressing NOW) should take precedence\r\n            // for the frame we're about to simulate. This gives zero-latency local response.\r\n            // Without this, old scheduled inputs would override the player's current intent.\r\n            existingInput.data = data;\r\n        }\r\n        // For future confirmed inputs (f > currentFrame), don't touch - they're properly scheduled\r\n    }\r\n}\r\n\r\n/** Add remote input received from network */\r\nexport function addRemoteInput(manager: RollbackManager, frame: number, playerId: string, data: any): void {\r\n    const { config, inputBuffer, currentFrame } = manager;\r\n\r\n    const input: PlayerInput = {\r\n        frame,\r\n        playerId,\r\n        data,\r\n        predicted: false,\r\n    };\r\n\r\n    addInputToBuffer(manager, input);\r\n\r\n    // CRITICAL FOR ZERO-LATENCY SYNC:\r\n    // When remote player sent input for frame F, they ALSO predicted the same input\r\n    // for frames (F - inputDelay) to (F - 1) via addLocalInput's zero-latency feature.\r\n    // We need to match this by adding predictions here, which will trigger rollback\r\n    // if our existing predictions were different.\r\n    //\r\n    // This ensures: when remote player pressed W at frame 100 (confirmed at 104),\r\n    // we also add W predictions for frames 100-103, which triggers rollback if\r\n    // we predicted differently.\r\n    const predictionStartFrame = Math.max(0, frame - config.inputDelay);\r\n    const predictionEndFrame = frame; // exclusive\r\n\r\n    for (let f = predictionStartFrame; f < predictionEndFrame; f++) {\r\n        // Backfill frames that are either:\r\n        // 1. In the past (already simulated) - need rollback\r\n        // 2. In the near future (within inputDelay) - will be simulated soon with wrong prediction\r\n        // Only skip frames that are too old to rollback\r\n        const isPastFrame = f <= currentFrame;\r\n        const isFutureButSoon = f > currentFrame && f < currentFrame + config.inputDelay;\r\n        const isTooOld = f < currentFrame - config.maxRollbackFrames;\r\n\r\n        if ((isPastFrame || isFutureButSoon) && !isTooOld) {\r\n            const frameInputs = inputBuffer.inputs.get(f);\r\n\r\n            // Check for existing confirmed input\r\n            const existingConfirmed = frameInputs?.find(i => i.playerId === playerId && !i.predicted);\r\n            if (existingConfirmed) {\r\n                // CRITICAL FIX: For the CURRENT frame, update confirmed inputs with newer data!\r\n                // The existing confirmed was scheduled from inputDelay frames ago.\r\n                // The new backfill represents the player's actual input for this frame.\r\n                // Without this, old scheduled inputs override the player's current intent.\r\n                if (f === currentFrame) {\r\n                    existingConfirmed.data = data;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            // Add as CONFIRMED input (predicted: false)\r\n            // The remote player used this input for their local prediction, so it's authoritative.\r\n            // addInputToBuffer will handle checking for prediction mismatch and setting needsRollback.\r\n            const backfilledInput: PlayerInput = {\r\n                frame: f,\r\n                playerId,\r\n                data,\r\n                predicted: false,\r\n            };\r\n\r\n            addInputToBuffer(manager, backfilledInput);\r\n        }\r\n    }\r\n\r\n    // Update last received frame for this player\r\n    const lastReceived = inputBuffer.lastReceivedFrame.get(playerId) ?? -1;\r\n    if (frame > lastReceived) {\r\n        inputBuffer.lastReceivedFrame.set(playerId, frame);\r\n    }\r\n}\r\n\r\nfunction addInputToBuffer(manager: RollbackManager, input: PlayerInput): void {\r\n    const { inputBuffer } = manager;\r\n\r\n    if (!inputBuffer.inputs.has(input.frame)) {\r\n        inputBuffer.inputs.set(input.frame, []);\r\n    }\r\n\r\n    const frameInputs = inputBuffer.inputs.get(input.frame)!;\r\n\r\n    // Replace any existing input from this player for this frame\r\n    const existingIdx = frameInputs.findIndex(i => i.playerId === input.playerId);\r\n    if (existingIdx >= 0) {\r\n        const existing = frameInputs[existingIdx];\r\n        // Check if this was a prediction that's now confirmed\r\n        if (existing.predicted && !input.predicted) {\r\n            // Check if prediction was correct (compare only discrete inputs, not continuous values like yaw)\r\n            if (inputsDifferSignificantly(existing.data, input.data)) {\r\n                manager.predictionMisses++;\r\n                // Store the earliest frame needing rollback directly on manager\r\n                // This ensures we don't miss it even if the frame is outside the scan window\r\n                const pendingRollback = manager.pendingRollbackFrame;\r\n                if (pendingRollback === undefined || input.frame < pendingRollback) {\r\n                    manager.pendingRollbackFrame = input.frame;\r\n                }\r\n                if (DEBUG_ROLLBACK) {\r\n                    console.log(`[MISMATCH] frame=${input.frame} player=${input.playerId} predicted=${JSON.stringify(existing.data)} actual=${JSON.stringify(input.data)}`);\r\n                }\r\n            }\r\n        }\r\n        frameInputs[existingIdx] = input;\r\n    } else {\r\n        frameInputs.push(input);\r\n    }\r\n}\r\n\r\n/** Compare inputs, ignoring continuously-changing values like yaw/pitch */\r\nfunction inputsDifferSignificantly(a: any, b: any): boolean {\r\n    if (!a && !b) return false;\r\n    if (!a || !b) return true;\r\n\r\n    // Compare ALL discrete inputs - any boolean or action key\r\n    // Continuous values to ignore: yaw, pitch, shootDirX/Y/Z, rotX/Y/Z, lookX/Y\r\n    // yawFp is the fixed-point version of yaw used in the browser demo\r\n    const continuousKeys = new Set([\r\n        'yaw', 'yawFp', 'pitch', 'pitchFp', 'roll', 'rollFp',\r\n        'shootDirX', 'shootDirY', 'shootDirZ',\r\n        'lookX', 'lookY',\r\n        'rotX', 'rotY', 'rotZ',\r\n        'mouseX', 'mouseY',\r\n        'aimX', 'aimY', 'aimZ'\r\n    ]);\r\n\r\n    // Compare all keys in both objects\r\n    const allKeys = new Set([...Object.keys(a || {}), ...Object.keys(b || {})]);\r\n\r\n    for (const key of allKeys) {\r\n        // Skip continuous values\r\n        if (continuousKeys.has(key)) continue;\r\n\r\n        // Compare the values\r\n        if (a[key] !== b[key]) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Get inputs for a specific frame, predicting if necessary */\r\nexport function getInputsForFrame(manager: RollbackManager, frame: number): PlayerInput[] {\r\n    const { inputBuffer, players, localPlayerId } = manager;\r\n    const inputs: PlayerInput[] = [];\r\n\r\n    // CRITICAL: Sort players for deterministic iteration order\r\n    // Without this, Set insertion order differs per client, causing simulation divergence\r\n    const sortedPlayers = Array.from(players).sort();\r\n\r\n    for (const playerId of sortedPlayers) {\r\n        const frameInputs = inputBuffer.inputs.get(frame);\r\n\r\n        // 1. First check for confirmed input\r\n        const confirmed = frameInputs?.find(i => i.playerId === playerId && !i.predicted);\r\n        if (confirmed) {\r\n            inputs.push(confirmed);\r\n            continue;\r\n        }\r\n\r\n        // 2. Then check for EXISTING prediction (from addLocalInput's zero-latency prediction)\r\n        // This is CRITICAL for immediate local response - addLocalInput adds predictions\r\n        // for frames currentFrame to currentFrame+inputDelay-1, so we must USE them here\r\n        const existingPrediction = frameInputs?.find(i => i.playerId === playerId && i.predicted);\r\n        if (existingPrediction) {\r\n            inputs.push(existingPrediction);\r\n            continue;\r\n        }\r\n\r\n        // 3. Only create new prediction from history if nothing exists\r\n        const predicted = predictInput(manager, frame, playerId);\r\n        inputs.push(predicted);\r\n        addInputToBuffer(manager, predicted);\r\n    }\r\n\r\n    return inputs;\r\n}\r\n\r\n/** Predict input for a player based on their last known input */\r\nfunction predictInput(manager: RollbackManager, frame: number, playerId: string): PlayerInput {\r\n    const { inputBuffer } = manager;\r\n\r\n    // Find the most recent confirmed input from this player\r\n    let lastInput: PlayerInput | null = null;\r\n\r\n    for (let f = frame - 1; f >= Math.max(0, frame - 60); f--) {\r\n        const frameInputs = inputBuffer.inputs.get(f);\r\n        const input = frameInputs?.find(i => i.playerId === playerId && !i.predicted);\r\n        if (input) {\r\n            lastInput = input;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Predict: repeat last input, or use neutral defaults if no input exists\r\n    // CRITICAL: Default to neutral state (no movement, no actions) rather than empty object\r\n    // Empty object causes issues because fields like yawFp would be missing\r\n    const predictedData = lastInput ? { ...lastInput.data } : {\r\n        w: false, a: false, s: false, d: false, jump: false, yawFp: 0\r\n    };\r\n\r\n    return {\r\n        frame,\r\n        playerId,\r\n        data: predictedData,\r\n        predicted: true,\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Snapshot Management\r\n// ============================================\r\n\r\nexport function saveSnapshot(manager: RollbackManager): void {\r\n    const { currentFrame, config, snapshots } = manager;\r\n\r\n    // Only save on interval\r\n    if (currentFrame % config.snapshotInterval !== 0) return;\r\n\r\n    const snapshot: Snapshot = {\r\n        frame: currentFrame,\r\n        state: manager.saveState(),\r\n    };\r\n\r\n    snapshots.set(currentFrame, snapshot);\r\n\r\n    // Clean up old snapshots (keep last maxRollbackFrames + some buffer)\r\n    const keepFrom = currentFrame - config.maxRollbackFrames - 10;\r\n    for (const frame of snapshots.keys()) {\r\n        if (frame < keepFrom) {\r\n            snapshots.delete(frame);\r\n        }\r\n    }\r\n}\r\n\r\nexport function loadSnapshot(manager: RollbackManager, frame: number): boolean {\r\n    const snapshot = manager.snapshots.get(frame);\r\n    if (!snapshot) return false;\r\n\r\n    manager.loadState(snapshot.state);\r\n    return true;\r\n}\r\n\r\n// ============================================\r\n// Rollback Logic\r\n// ============================================\r\n\r\n/** Check if rollback is needed and return the frame to rollback to */\r\nexport function checkRollback(manager: RollbackManager): number | null {\r\n    const { currentFrame, config } = manager;\r\n\r\n    // Check if there's a pending rollback frame stored by addInputToBuffer\r\n    const pendingRollback = manager.pendingRollbackFrame;\r\n    if (pendingRollback !== undefined) {\r\n        // Clear the pending rollback\r\n        manager.pendingRollbackFrame = undefined;\r\n\r\n        // Only rollback if within the max rollback window\r\n        if (currentFrame - pendingRollback <= config.maxRollbackFrames) {\r\n            return pendingRollback;\r\n        } else if (DEBUG_ROLLBACK) {\r\n            console.warn(`[ROLLBACK_MISSED] frame=${pendingRollback} is too old (current=${currentFrame}, max=${config.maxRollbackFrames})`);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/** Perform rollback and resimulation */\r\nexport function performRollback(\r\n    manager: RollbackManager,\r\n    toFrame: number\r\n): void {\r\n    const { currentFrame } = manager;\r\n\r\n    // Find nearest snapshot at or before toFrame\r\n    let snapshotFrame = toFrame;\r\n    while (snapshotFrame >= 0 && !manager.snapshots.has(snapshotFrame)) {\r\n        snapshotFrame--;\r\n    }\r\n\r\n    if (snapshotFrame < 0) {\r\n        if (DEBUG_ROLLBACK) console.warn('[ROLLBACK] No snapshot found for rollback');\r\n        return;\r\n    }\r\n\r\n    // Load snapshot\r\n    if (!loadSnapshot(manager, snapshotFrame)) {\r\n        if (DEBUG_ROLLBACK) console.warn('[ROLLBACK] Failed to load snapshot');\r\n        return;\r\n    }\r\n\r\n    manager.rollbackCount++;\r\n    const rollbackDepth = currentFrame - snapshotFrame;\r\n    if (rollbackDepth > manager.maxRollbackDepth) {\r\n        manager.maxRollbackDepth = rollbackDepth;\r\n    }\r\n\r\n    if (DEBUG_ROLLBACK) {\r\n        console.log(`[ROLLBACK] Rolling back from ${currentFrame} to ${snapshotFrame} (${rollbackDepth} frames), available snapshots: ${[...manager.snapshots.keys()].sort((a,b)=>a-b).join(',')}`);\r\n    }\r\n\r\n    // Resimulate from snapshot to current frame\r\n    for (let frame = snapshotFrame; frame < currentFrame; frame++) {\r\n        manager.currentFrame = frame;\r\n\r\n        // Save snapshot BEFORE tick\r\n        saveSnapshot(manager);\r\n\r\n        // Get inputs for this frame (now with confirmed inputs)\r\n        const inputs = getInputsForFrame(manager, frame);\r\n\r\n        // Execute frame (game applies inputs and steps physics)\r\n        manager.tick(frame, inputs);\r\n\r\n        manager.currentFrame = frame + 1;\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Frame Advance\r\n// ============================================\r\n\r\n/** Advance simulation by one frame */\r\nexport function advanceFrame(\r\n    manager: RollbackManager\r\n): { inputs: PlayerInput[]; didRollback: boolean } {\r\n    let didRollback = false;\r\n\r\n    // Check if we need to rollback\r\n    const rollbackTo = checkRollback(manager);\r\n    if (rollbackTo !== null && rollbackTo < manager.currentFrame) {\r\n        performRollback(manager, rollbackTo);\r\n        didRollback = true;\r\n    }\r\n\r\n    // Save snapshot before advancing\r\n    saveSnapshot(manager);\r\n\r\n    // Get inputs for current frame\r\n    const inputs = getInputsForFrame(manager, manager.currentFrame);\r\n\r\n    // Execute frame (game applies inputs and steps physics)\r\n    manager.tick(manager.currentFrame, inputs);\r\n\r\n    // Advance frame counter\r\n    manager.currentFrame++;\r\n\r\n    // Update last confirmed frame\r\n    updateConfirmedFrame(manager);\r\n\r\n    // Clean up old inputs\r\n    cleanupInputs(manager);\r\n\r\n    return { inputs, didRollback };\r\n}\r\n\r\nfunction updateConfirmedFrame(manager: RollbackManager): void {\r\n    const { inputBuffer, players, currentFrame, config } = manager;\r\n\r\n    // Start from the next unconfirmed frame\r\n    // Skip very early frames that won't have inputs due to inputDelay\r\n    const startFrame = Math.max(\r\n        inputBuffer.lastConfirmedFrame + 1,\r\n        config.inputDelay  // First frame that could possibly have inputs\r\n    );\r\n\r\n    // DETERMINISM: Sort players for consistent iteration order\r\n    const sortedPlayers = Array.from(players).sort();\r\n\r\n    // Find the latest frame where all players have confirmed inputs\r\n    for (let frame = startFrame; frame < currentFrame; frame++) {\r\n        const frameInputs = inputBuffer.inputs.get(frame);\r\n        if (!frameInputs) {\r\n            // No inputs for this frame yet, can't confirm further\r\n            break;\r\n        }\r\n\r\n        let allConfirmed = true;\r\n        for (const playerId of sortedPlayers) {\r\n            const input = frameInputs.find(i => i.playerId === playerId && !i.predicted);\r\n            if (!input) {\r\n                allConfirmed = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (allConfirmed) {\r\n            inputBuffer.lastConfirmedFrame = frame;\r\n        } else {\r\n            // Can't confirm this frame, stop checking\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nfunction cleanupInputs(manager: RollbackManager): void {\r\n    const { inputBuffer, config, currentFrame } = manager;\r\n\r\n    // Keep inputs for potential rollback\r\n    const keepFrom = currentFrame - config.maxRollbackFrames - 10;\r\n\r\n    for (const frame of inputBuffer.inputs.keys()) {\r\n        if (frame < keepFrom) {\r\n            inputBuffer.inputs.delete(frame);\r\n        }\r\n    }\r\n}\r\n\r\n// ============================================\r\n// Network Integration\r\n// ============================================\r\n\r\n/** Get local inputs that need to be sent to network */\r\nexport function getInputsToSend(manager: RollbackManager): PlayerInput[] {\r\n    // Return inputs from local queue that are ready to send\r\n    const ready = manager.localInputQueue.filter(i => i.frame <= manager.currentFrame + manager.config.inputDelay);\r\n\r\n    // Remove sent inputs from queue\r\n    manager.localInputQueue = manager.localInputQueue.filter(i => i.frame > manager.currentFrame + manager.config.inputDelay);\r\n\r\n    return ready;\r\n}\r\n\r\n/** Get sync state for network (frame + checksum) */\r\nexport function getSyncState(manager: RollbackManager): { frame: number; checksum: number } {\r\n    return {\r\n        frame: manager.currentFrame,\r\n        checksum: manager.computeChecksum()\r\n    };\r\n}\r\n\r\n// ============================================\r\n// Debugging\r\n// ============================================\r\n\r\nexport function getRollbackStats(manager: RollbackManager): {\r\n    currentFrame: number;\r\n    confirmedFrame: number;\r\n    rollbackCount: number;\r\n    maxRollbackDepth: number;\r\n    predictionMisses: number;\r\n    snapshotCount: number;\r\n    inputBufferSize: number;\r\n} {\r\n    return {\r\n        currentFrame: manager.currentFrame,\r\n        confirmedFrame: manager.inputBuffer.lastConfirmedFrame,\r\n        rollbackCount: manager.rollbackCount,\r\n        maxRollbackDepth: manager.maxRollbackDepth,\r\n        predictionMisses: manager.predictionMisses,\r\n        snapshotCount: manager.snapshots.size,\r\n        inputBufferSize: manager.inputBuffer.inputs.size,\r\n    };\r\n}\r\n"],
  "mappings": "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AM;AAAA,IAAM;AAAA,IAAM;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAChG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IAAO;AAAA,IACzG;AAAA;AAAA,EACJ;AAIA,MAAM,oBAAoB;AAGnB,WAAS,MAAM,OAAq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",
  "names": ["buffer", "def", "syncFieldsSet", "vec2", "vec2Add", "vec2Clone", "vec2Cross", "vec2Dot", "vec2LengthSq", "vec2Scale", "vec2Sub", "vec2Zero", "Shape2DType", "BodyType2D", "vec2Zero", "vec2", "vec2Clone", "vec2Add", "vec2Sub", "vec2Scale", "vec2Dot", "vec2LengthSq", "vec2Cross", "vec2Add", "vec2Scale", "vec2LengthSq", "vec2Zero", "FP_ONE_TWELFTH", "DEFAULT_FILTER", "Layers", "TriggerState", "createFilter", "filterCollidingWith", "filterExcluding", "makeTrigger", "shouldCollide", "ShapeType", "Layers", "DEFAULT_FILTER", "createFilter", "shouldCollide", "filterCollidingWith", "filterExcluding", "RESTITUTION_DEFAULT", "FRICTION_DEFAULT", "BodyType", "DEFAULT_FILTER", "a", "b", "TriggerState", "makeTrigger", "LINEAR_DAMPING", "ANGULAR_DAMPING", "SLEEP_THRESHOLD", "SLEEP_FRAMES_REQUIRED", "TriggerState", "shouldCollide"]
}
